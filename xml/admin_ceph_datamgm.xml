<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "generic-entities.ent">
    %entities;
]>
<!-- Converted by suse-upgrade version 1.1 -->
<chapter xmlns="http://docbook.org/ns/docbook"
 xmlns:xi="http://www.w3.org/2001/XInclude"
 xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
 xml:id="cha-storage-datamgm">
 <title>Stored Data Management</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:editurl>https://github.com/SUSE/doc-ses/edit/master/xml/</dm:editurl>
   <dm:translation>yes</dm:translation>
   <dm:release>SES 7</dm:release>
  </dm:docmanager>
 </info>
 <para>
  The CRUSH algorithm determines how to store and retrieve data by computing
  data storage locations. CRUSH empowers &ceph; clients to communicate with
  OSDs directly rather than through a centralized server or broker. With an
  algorithmically determined method of storing and retrieving data, &ceph;
  avoids a single point of failure, a performance bottleneck, and a physical
  limit to its scalability.
 </para>
 <para>
  CRUSH requires a map of your cluster, and uses the &crushmap; to
  pseudo-randomly store and retrieve data in OSDs with a uniform distribution
  of data across the cluster.
 </para>
 <para>
  CRUSH maps contain a list of OSDs, a list of 'buckets' for aggregating the
  devices into physical locations, and a list of rules that tell CRUSH how it
  should replicate data in a &ceph; cluster’s pools. By reflecting the
  underlying physical organization of the installation, CRUSH can model—and
  thereby address—potential sources of correlated device failures. Typical
  sources include physical proximity, a shared power source, and a shared
  network. By encoding this information into the cluster map, CRUSH placement
  policies can separate object replicas across different failure domains while
  still maintaining the desired distribution. For example, to address the
  possibility of concurrent failures, it may be desirable to ensure that data
  replicas are on devices using different shelves, racks, power supplies,
  controllers, and/or physical locations.
 </para>
 <para>
  After you deploy a &ceph; cluster, a default &crushmap; is generated. It is
  fine for your &ceph; sandbox environment. However, when you deploy a
  large-scale data cluster, you should give significant consideration to
  developing a custom &crushmap;, because it will help you manage your &ceph;
  cluster, improve performance and ensure data safety.
 </para>
 <para>
  For example, if an OSD goes down, a &crushmap; can help you locate the
  physical data center, room, row and rack of the host with the failed OSD in
  the event you need to use on-site support or replace hardware.
 </para>
 <para>
  Similarly, CRUSH may help you identify faults more quickly. For example, if
  all OSDs in a particular rack go down simultaneously, the fault may lie with
  a network switch or power to the rack or the network switch rather than the
  OSDs themselves.
 </para>
 <para>
  A custom &crushmap; can also help you identify the physical locations where
  &ceph; stores redundant copies of data when the placement group(s) (refer to
  <xref linkend="op-pgs"/>) associated with a failed host are in a degraded
  state.
 </para>
 <para>
  There are three main sections to a &crushmap;.
 </para>
 <itemizedlist mark="bullet" spacing="normal">
  <listitem>
   <para>
    <xref linkend="datamgm-devices" xrefstyle="select: title"/> consist
    of any object storage device corresponding to a
    <systemitem>ceph-osd</systemitem> daemon.
   </para>
  </listitem>
  <listitem>
   <para>
    <xref linkend="datamgm-buckets" xrefstyle="select: title"/> consist of
    a hierarchical aggregation of storage locations (for example rows, racks,
    hosts, etc.) and their assigned weights.
   </para>
  </listitem>
  <listitem>
   <para>
    <xref linkend="datamgm-rules" xrefstyle="select: title"/> consist of
    the manner of selecting buckets.
   </para>
  </listitem>
 </itemizedlist>
 <sect1 xml:id="datamgm-devices">
  <title>OSD Devices</title>

  <para>
   To map placement groups to OSDs, a &crushmap; requires a list of OSD devices
   (the name of the OSD daemon). The list of devices appears first in the
   &crushmap;.
  </para>

<screen>#devices
device <replaceable>NUM</replaceable> osd.<replaceable>OSD_NAME</replaceable> class <replaceable>CLASS_NAME</replaceable></screen>

  <para>
   For example:
  </para>

<screen>
#devices
device 0 osd.0 class hdd
device 1 osd.1 class ssd
device 2 osd.2 class nvme
device 3 osd.3class ssd
</screen>

  <para>
   As a general rule, an OSD daemon maps to a single disk.
  </para>

  <sect2 xml:id="crush-devclasses">
   <title>Device Classes</title>
   <para>
    The flexibility of the &crushmap; in controlling data placement is one of
    the &ceph;'s strengths. It is also one of the most difficult parts of the
    cluster to manage. <emphasis>Device classes</emphasis> automate the most
    common changes to &crushmap;s that the administrator had to do manually
    previously.
   </para>
   <sect3 xml:id="crush-management-problem">
    <title>The CRUSH Management Problem</title>
    <para>
     &ceph; clusters are frequently built with multiple types of storage
     devices: HDD, SSD, NVMe, or even mixed classes of the above. We call these
     different types of storage devices <emphasis>device classes</emphasis> to
     avoid confusion between the <emphasis>type</emphasis> property of CRUSH
     buckets (for example, host, rack, row, see
     <xref linkend="datamgm-buckets"/> for more details). &ceph;
     OSDs backed by SSDs are much faster than those backed by spinning disks,
     making them better suited for certain workloads. &ceph; makes it easy to
     create RADOS pools for different data sets or workloads and to assign
     different CRUSH rules to control data placement for those pools.
    </para>
    <figure>
     <title>OSDs with Mixed Device Classes</title>
     <mediaobject>
      <imageobject role="fo">
       <imagedata fileref="device_classes.svg" width="70%" format="SVG"/>
      </imageobject>
      <imageobject role="html">
       <imagedata fileref="device_classes.svg" width="70%" format="SVG"/>
      </imageobject>
     </mediaobject>
    </figure>
    <para>
     However, setting up the CRUSH rules to place data only on a certain class
     of device is tedious. Rules work in terms of the CRUSH hierarchy, but if
     the devices are mixed into the same hosts or racks (as in the sample
     hierarchy above), they will (by default) be mixed together and appear in
     the same sub-trees of the hierarchy. Manually separating them out into
     separate trees involved creating multiple versions of each intermediate
     node for each device class in previous versions of &productname;.
    </para>
   </sect3>
   <sect3 xml:id="osd-crush-device-classes">
    <title>Device Classes</title>
    <para>
     An elegant solution that &ceph; offers is to add a property called
     <emphasis>device class</emphasis> to each OSD. By default, OSDs will
     automatically set their device classes to either 'hdd', 'ssd', or 'nvme'
     based on the hardware properties exposed by the Linux kernel. These device
     classes are reported in a new column of the <command>ceph osd
     tree</command> command output:
    </para>
<screen>&prompt.cephuser;ceph osd tree
 ID CLASS WEIGHT   TYPE NAME      STATUS REWEIGHT PRI-AFF
 -1       83.17899 root default
 -4       23.86200     host cpach
 2   hdd  1.81898         osd.2      up  1.00000 1.00000
 3   hdd  1.81898         osd.3      up  1.00000 1.00000
 4   hdd  1.81898         osd.4      up  1.00000 1.00000
 5   hdd  1.81898         osd.5      up  1.00000 1.00000
 6   hdd  1.81898         osd.6      up  1.00000 1.00000
 7   hdd  1.81898         osd.7      up  1.00000 1.00000
 8   hdd  1.81898         osd.8      up  1.00000 1.00000
 15  hdd  1.81898         osd.15     up  1.00000 1.00000
 10  nvme 0.93100         osd.10     up  1.00000 1.00000
 0   ssd  0.93100         osd.0      up  1.00000 1.00000
 9   ssd  0.93100         osd.9      up  1.00000 1.00000</screen>
    <para>
     If the automatic device class detection fails, for example because the
     device driver is not properly exposing information about the device via
     <filename>/sys/block</filename>, you can adjust device classes from the
     command line:
    </para>
<screen>
&prompt.cephuser;ceph osd crush rm-device-class osd.2 osd.3
done removing class of osd(s): 2,3
&prompt.cephuser;ceph osd crush set-device-class ssd osd.2 osd.3
set osd(s) 2,3 to class 'ssd'
</screen>
   </sect3>
   <sect3 xml:id="crush-placement-rules">
    <title>Setting CRUSH Placement Rules</title>
    <para>
     CRUSH rules can restrict placement to a specific device class. For
     example, you can create a 'fast'
     <emphasis role="bold">replicated</emphasis> pool that distributes data only
     over SSD disks by running the following command:
    </para>
<screen>
&prompt.cephuser;ceph osd crush rule create-replicated <replaceable>RULE_NAME</replaceable> <replaceable>ROOT</replaceable> <replaceable>FAILURE_DOMAIN_TYPE</replaceable> <replaceable>DEVICE_CLASS</replaceable>
</screen>
    <para>
     For example:
    </para>
<screen>
&prompt.cephuser;ceph osd crush rule create-replicated fast default host ssd
</screen>
    <para>
     Create a pool named 'fast_pool' and assign it to the 'fast' rule:
    </para>
<screen>&prompt.cephuser;ceph osd pool create fast_pool 128 128 replicated fast</screen>
    <para>
     The process for creating <emphasis role="bold" >erasure code</emphasis>
     rules is slightly different. First, you create an erasure code profile that
     includes a property for your desired device class. Then, use that profile
     when creating the erasure coded pool:
    </para>
<screen>
&prompt.cephuser;ceph osd erasure-code-profile set myprofile \
 k=4 m=2 crush-device-class=ssd crush-failure-domain=host
&prompt.cephuser;ceph osd pool create mypool 64 erasure myprofile
</screen>
    <para>
     In case you need to manually edit the &crushmap; to customize your rule,
     the syntax has been extended to allow the device class to be specified.
     For example, the CRUSH rule generated by the above commands looks as
     follows:
    </para>
<screen>
rule ecpool {
  id 2
  type erasure
  min_size 3
  max_size 6
  step set_chooseleaf_tries 5
  step set_choose_tries 100
  step take default <emphasis role="bold">class ssd</emphasis>
  step chooseleaf indep 0 type host
  step emit
}
</screen>
    <para>
     The important difference here is that the 'take' command includes the
     additional 'class <replaceable>CLASS_NAME</replaceable>' suffix.
    </para>
   </sect3>
   <sect3 xml:id="crush-additional-commands">
    <title>Additional Commands</title>
    <para>
     To list device classes used in a &crushmap;, run:
    </para>
<screen>
&prompt.cephuser;ceph osd crush class ls
[
  "hdd",
  "ssd"
]
</screen>
    <para>
     To list existing CRUSH rules, run:
    </para>
<screen>&prompt.cephuser;ceph osd crush rule ls
replicated_rule
fast</screen>
    <para>
     To view details of the CRUSH rule named 'fast', run:
    </para>
<screen>&prompt.cephuser;ceph osd crush rule dump fast
{
		"rule_id": 1,
		"rule_name": "fast",
		"ruleset": 1,
		"type": 1,
		"min_size": 1,
		"max_size": 10,
		"steps": [
						{
										"op": "take",
										"item": -21,
										"item_name": "default~ssd"
						},
						{
										"op": "chooseleaf_firstn",
										"num": 0,
										"type": "host"
						},
						{
										"op": "emit"
						}
		]
}</screen>
    <para>
     To list OSDs that belong to an 'ssd' class, run:
    </para>
<screen>
&prompt.cephuser;ceph osd crush class ls-osd ssd
0
1
</screen>
   </sect3>
   <sect3 xml:id="device-classes-reclassify">
    <title>Migrating from a Legacy SSD Rule to Device Classes</title>
    <para>
     In &productname; prior to version 5, you needed to manually edit the
     &crushmap; and maintain a parallel hierarchy for each specialized device
     type (such as SSD) in order to write rules that apply to these devices.
     Since &productname; 5, the device class feature has enabled this
     transparently.
    </para>
    <para>
     You can transform a legacy rule and hierarchy to the new class-based rules
     by using the <command>crushtool</command> command. There are several types
     of transformation possible:
    </para>
    <variablelist>
     <varlistentry>
      <term><command>crushtool --reclassify-root <replaceable>ROOT_NAME</replaceable> <replaceable>DEVICE_CLASS</replaceable></command></term>
      <listitem>
       <para>
        This command takes everything in the hierarchy beneath
        <replaceable>ROOT_NAME</replaceable> and adjusts any rules that
        reference that root via
       </para>
<screen>
take <replaceable>ROOT_NAME</replaceable>
</screen>
       <para>
        to instead
       </para>
<screen>
take <replaceable>ROOT_NAME</replaceable> class <replaceable>DEVICE_CLASS</replaceable>
</screen>
       <para>
        It renumbers the buckets so that the old IDs are used for the specified
        class’s 'shadow tree'. As a consequence, no data movement occurs.
       </para>
       <example>
        <title><command>crushtool --reclassify-root</command></title>
        <para>
         Consider the following existing rule:
        </para>
<screen>
rule replicated_ruleset {
   id 0
   type replicated
   min_size 1
   max_size 10
   step take default
   step chooseleaf firstn 0 type rack
   step emit
}
</screen>
        <para>
         If you reclassify the root 'default' as class 'hdd', the rule will
         become
        </para>
<screen>
rule replicated_ruleset {
   id 0
   type replicated
   min_size 1
   max_size 10
   step take default class hdd
   step chooseleaf firstn 0 type rack
   step emit
}
</screen>
       </example>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><command>crushtool --set-subtree-class <replaceable>BUCKET_NAME</replaceable> <replaceable>DEVICE_CLASS</replaceable></command></term>
      <listitem>
       <para>
        This method marks every device in the subtree rooted at
        <replaceable>BUCKET_NAME</replaceable> with the specified device class.
       </para>
       <para>
        <option>--set-subtree-class</option> is normally used in conjunction
        with the <option>--reclassify-root</option> option to ensure that all
        devices in that root are labeled with the correct class. However, some
        of those devices may intentionally have a different class, and
        therefore you do not want to relabel them. In such cases, exclude the
        <option>--set-subtree-class</option> option. Keep in mind that such
        remapping will not be perfect, because the previous rule is distributed
        across devices of multiple classes but the adjusted rules will only map
        to devices of the specified device class.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><command>crushtool --reclassify-bucket <replaceable>MATCH_PATTERN</replaceable> <replaceable>DEVICE_CLASS</replaceable> <replaceable>DEFAULT_PATTERN</replaceable></command></term>
      <listitem>
       <para>
        This method allows merging a parallel type-specific hierarchy with the
        normal hierarchy. For example, many users have &crushmap;s similar to
        the following one:
       </para>
       <example>
        <title><command>crushtool --reclassify-bucket</command></title>
<screen>
host node1 {
   id -2           # do not change unnecessarily
   # weight 109.152
   alg straw
   hash 0  # rjenkins1
   item osd.0 weight 9.096
   item osd.1 weight 9.096
   item osd.2 weight 9.096
   item osd.3 weight 9.096
   item osd.4 weight 9.096
   item osd.5 weight 9.096
   [...]
}

host node1-ssd {
   id -10          # do not change unnecessarily
   # weight 2.000
   alg straw
   hash 0  # rjenkins1
   item osd.80 weight 2.000
   [...]
}

root default {
   id -1           # do not change unnecessarily
   alg straw
   hash 0  # rjenkins1
   item node1 weight 110.967
   [...]
}

root ssd {
   id -18          # do not change unnecessarily
   # weight 16.000
   alg straw
   hash 0  # rjenkins1
   item node1-ssd weight 2.000
   [...]
}
</screen>
       </example>
       <para>
        This function reclassifies each bucket that matches a given pattern.
        The pattern can look like <literal>%suffix</literal> or
        <literal>prefix%</literal>. In the above example, you would use the
        pattern <literal>%-ssd</literal>. For each matched bucket, the
        remaining portion of the name that matches the '%' wild card specifies
        the base bucket. All devices in the matched bucket are labeled with the
        specified device class and then moved to the base bucket. If the base
        bucket does not exist (for example, if 'node12-ssd' exists but 'node12'
        does not), then it is created and linked underneath the specified
        default parent bucket. The old bucket IDs are preserved for the new
        shadow buckets to prevent data movement. Rules with the
        <literal>take</literal> steps that reference the old buckets are
        adjusted.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><command>crushtool --reclassify-bucket <replaceable>BUCKET_NAME</replaceable> <replaceable>DEVICE_CLASS</replaceable> <replaceable>BASE_BUCKET</replaceable></command></term>
      <listitem>
       <para>
        You can use the <option>--reclassify-bucket</option> option without a
        wild card to map a single bucket. For example, in the previous example,
        we want the 'ssd' bucket to be mapped to the default bucket.
       </para>
       <para>
        The final command to convert the map comprised of the above fragments
        would be as follows:
       </para>
<screen>
&prompt.cephuser;ceph osd getcrushmap -o original
&prompt.cephuser;crushtool -i original --reclassify \
  --set-subtree-class default hdd \
  --reclassify-root default hdd \
  --reclassify-bucket %-ssd ssd default \
  --reclassify-bucket ssd ssd default \
  -o adjusted
</screen>
       <para>
        In order to verify that the conversion is correct, there is a
        <option>--compare</option> option that tests a large sample of inputs
        to the &crushmap; and compares if the same result comes back out. These
        inputs are controlled by the same options that apply to the
        <option>--test</option>. For the above example, the command would be as
        follows:
       </para>
<screen>
&prompt.cephuser;crushtool -i original --compare adjusted
rule 0 had 0/10240 mismatched mappings (0)
rule 1 had 0/10240 mismatched mappings (0)
maps appear equivalent
</screen>
       <tip>
        <para>
         If there were differences, you would see what ratio of inputs are
         remapped in the parentheses.
        </para>
       </tip>
       <para>
        If you are satisfied with the adjusted &crushmap;, you can apply it to
        the cluster:
       </para>
<screen>
&prompt.cephuser;ceph osd setcrushmap -i adjusted
</screen>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3>
    <title>For More Information</title>
    <para>
     Find more details on &crushmap;s in <xref linkend="op-crush"/>.
    </para>
    <para>
     Find more details on &ceph; pools in general in
     <xref linkend="ceph-pools"/>.
    </para>
    <para>
     Find more details about erasure coded pools in
     <xref linkend="cha-ceph-erasure"/>.
    </para>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="datamgm-buckets">
  <title>Buckets</title>

  <para>
   CRUSH maps contain a list of OSDs, which can be organized into a
   tree-structured arrangement of buckets for aggregating the devices into
   physical locations. Individual OSDs comprise the leaves on the tree.
  </para>

  <informaltable frame="none">
   <tgroup cols="3">
    <colspec colwidth="10*"/>
    <colspec colwidth="30*"/>
    <colspec colwidth="70*"/>
    <tbody>
     <row>
      <entry>
       <para>
        0
       </para>
      </entry>
      <entry>
       <para>
        osd
       </para>
      </entry>
      <entry>
       <para>
        A specific device or OSD (<literal>osd.1</literal>, <literal>osd.2</literal>, etc.).
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        1
       </para>
      </entry>
      <entry>
       <para>
        host
       </para>
      </entry>
      <entry>
       <para>
        The name of a host containing one or more OSDs.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        2
       </para>
      </entry>
      <entry>
       <para>
        chassis
       </para>
      </entry>
      <entry>
       <para>
        Identifier for which chassis in the rack contains the
        <literal>host</literal>.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        3
       </para>
      </entry>
      <entry>
       <para>
        rack
       </para>
      </entry>
      <entry>
       <para>
        A computer rack. The default is <literal>unknownrack</literal>.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        4
       </para>
      </entry>
      <entry>
       <para>
        row
       </para>
      </entry>
      <entry>
       <para>
        A row in a series of racks.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        5
       </para>
      </entry>
      <entry>
       <para>
        pdu
       </para>
      </entry>
      <entry>
       <para>
        Abbreviation for "Power Distribution Unit".
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        6
       </para>
      </entry>
      <entry>
       <para>
        pod
       </para>
      </entry>
      <entry>
       <para>
        Abbreviation for "Point of Delivery": in this context, a group of PDUs,
        or a group of rows of racks.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        7
       </para>
      </entry>
      <entry>
       <para>
        room
       </para>
      </entry>
      <entry>
       <para>
        A room containing rows of racks.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        8
       </para>
      </entry>
      <entry>
       <para>
        datacenter
       </para>
      </entry>
      <entry>
       <para>
        A physical data center containing one or more rooms.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        9
       </para>
      </entry>
      <entry>
       <para>
        region
       </para>
      </entry>
      <entry>
       <para>
        Geographical region of the world (e.g. NAM, LAM, EMEA, APAC etc.)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        10
       </para>
      </entry>
      <entry>
       <para>
        root
       </para>
      </entry>
      <entry>
       <para>
        The root node of the tree of OSD buckets (normally set to <literal>default</literal>).
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>

  <tip>
   <para>
    You can modify the existing types and create your own bucket types.
   </para>
  </tip>

  <para>
   &ceph;’s deployment tools generate a &crushmap; that contains a bucket for
   each host, and a root named 'default', which is useful for the default
   <literal>rbd</literal> pool. The remaining bucket types provide a means for
   storing information about the physical location of nodes/buckets, which
   makes cluster administration much easier when OSDs, hosts, or network
   hardware malfunction and the administrator needs access to physical
   hardware.
  </para>

  <para>
   A bucket has a type, a unique name (string), a unique ID expressed as a
   negative integer, a weight relative to the total capacity/capability of its
   item(s), the bucket algorithm ( <literal>straw2</literal> by default), and
   the hash (<literal>0</literal> by default, reflecting CRUSH Hash
   <literal>rjenkins1</literal>). A bucket may have one or more items. The
   items may consist of other buckets or OSDs. Items may have a weight that
   reflects the relative weight of the item.
  </para>

<screen>[bucket-type] [bucket-name] {
  id [a unique negative numeric ID]
  weight [the relative capacity/capability of the item(s)]
  alg [the bucket type: uniform | list | tree | straw2 | straw ]
  hash [the hash type: 0 by default]
  item [item-name] weight [weight]
}</screen>

  <para>
   The following example illustrates how you can use buckets to aggregate a
   pool and physical locations like a data center, a room, a rack and a row.
  </para>

<screen>host ceph-osd-server-1 {
        id -17
        alg straw2
        hash 0
        item osd.0 weight 0.546
        item osd.1 weight 0.546
}

row rack-1-row-1 {
        id -16
        alg straw2
        hash 0
        item ceph-osd-server-1 weight 2.00
}

rack rack-3 {
        id -15
        alg straw2
        hash 0
        item rack-3-row-1 weight 2.00
        item rack-3-row-2 weight 2.00
        item rack-3-row-3 weight 2.00
        item rack-3-row-4 weight 2.00
        item rack-3-row-5 weight 2.00
}

rack rack-2 {
        id -14
        alg straw2
        hash 0
        item rack-2-row-1 weight 2.00
        item rack-2-row-2 weight 2.00
        item rack-2-row-3 weight 2.00
        item rack-2-row-4 weight 2.00
        item rack-2-row-5 weight 2.00
}

rack rack-1 {
        id -13
        alg straw2
        hash 0
        item rack-1-row-1 weight 2.00
        item rack-1-row-2 weight 2.00
        item rack-1-row-3 weight 2.00
        item rack-1-row-4 weight 2.00
        item rack-1-row-5 weight 2.00
}

room server-room-1 {
        id -12
        alg straw2
        hash 0
        item rack-1 weight 10.00
        item rack-2 weight 10.00
        item rack-3 weight 10.00
}

datacenter dc-1 {
        id -11
        alg straw2
        hash 0
        item server-room-1 weight 30.00
        item server-room-2 weight 30.00
}

root data {
        id -10
        alg straw2
        hash 0
        item dc-1 weight 60.00
        item dc-2 weight 60.00
}</screen>
 </sect1>
 <sect1 xml:id="datamgm-rules">
  <title>Rule Sets</title>

  <para>
   CRUSH maps support the notion of 'CRUSH rules', which are the rules that
   determine data placement for a pool. For large clusters, you will likely
   create many pools where each pool may have its own CRUSH ruleset and rules.
   The default &crushmap; has a rule for the default root. If you want more
   roots and more rules, you need to create them later or they will be created
   automatically when new pools are created.
  </para>

  <note>
   <para>
    In most cases, you will not need to modify the default rules. When you
    create a new pool, its default ruleset is 0.
   </para>
  </note>

  <para>
   A rule takes the following form:
  </para>

<screen>rule <replaceable>rulename</replaceable> {

        ruleset <replaceable>ruleset</replaceable>
        type <replaceable>type</replaceable>
        min_size <replaceable>min-size</replaceable>
        max_size <replaceable>max-size</replaceable>
        step <replaceable>step</replaceable>

}</screen>

  <variablelist>
   <varlistentry>
    <term>ruleset</term>
    <listitem>
     <para>
      An integer. Classifies a rule as belonging to a set of rules. Activated
      by setting the ruleset in a pool. This option is required. Default is
      <literal>0</literal>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>type</term>
    <listitem>
     <para>
      A string. Describes a rule for either a 'replicated' or 'erasure' coded
      pool. This option is required. Default is <literal>replicated</literal>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>min_size</term>
    <listitem>
     <para>
      An integer. If a pool group makes fewer replicas than this number, CRUSH
      will NOT select this rule. This option is required. Default is
      <literal>2</literal>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>max_size</term>
    <listitem>
     <para>
      An integer. If a pool group makes more replicas than this number, CRUSH
      will NOT select this rule. This option is required. Default is
      <literal>10</literal>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>step take <replaceable>bucket</replaceable></term>
    <listitem>
     <para>
      Takes a bucket specified by a name, and begins iterating down the tree.
      This option is required. For an explanation about iterating through the
      tree, see <xref linkend="datamgm-rules-step-iterate"/>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>step <replaceable>target</replaceable><replaceable>mode</replaceable><replaceable>num</replaceable> type <replaceable>bucket-type</replaceable></term>
    <listitem>
     <para>
      <replaceable>target</replaceable> can either be <literal>choose</literal>
      or <literal>chooseleaf</literal>. When set to <literal>choose</literal>,
      a number of buckets is selected. <literal>chooseleaf</literal> directly
      selects the OSDs (leaf nodes) from the sub-tree of each bucket in the set
      of buckets.
     </para>
     <para>
      <replaceable>mode</replaceable> can either be <literal>firstn</literal>
      or <literal>indep</literal>. See
      <xref linkend="datamgm-rules-step-mode"/>.
     </para>
     <para>
      Selects the number of buckets of the given type. Where N is the number of
      options available, if <replaceable>num</replaceable> &gt; 0 &amp;&amp;
      &lt; N, choose that many buckets; if <replaceable>num</replaceable> &lt;
      0, it means N - <replaceable>num</replaceable>; and, if
      <replaceable>num</replaceable> == 0, choose N buckets (all available).
      Follows <literal>step take</literal> or <literal>step choose</literal>.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>step emit</term>
    <listitem>
     <para>
      Outputs the current value and empties the stack. Typically used at the
      end of a rule, but may also be used to form different trees in the same
      rule. Follows <literal>step choose</literal>.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <sect2 xml:id="datamgm-rules-step-iterate">
   <title>Iterating the Node Tree</title>
   <para>
    The structure defined with the buckets can be viewed as a node tree.
    Buckets are nodes and OSDs are leafs in this tree.
   </para>
   <para>
    Rules in the &crushmap; define how OSDs are selected from this tree. A rule
    starts with a node and then iterates down the tree to return a set of OSDs.
    It is not possible to define which branch needs to be selected. Instead the
    CRUSH algorithm assures that the set of OSDs fulfills the replication
    requirements and evenly distributes the data.
   </para>
   <para>
    With <literal>step take</literal> <replaceable>bucket</replaceable> the
    iteration through the node tree begins at the given bucket (not bucket
    type). If OSDs from all branches in the tree are to be returned, the bucket
    must be the root bucket. Otherwise the following steps are only iterating
    through a sub-tree.
   </para>
   <para>
    After <literal>step take</literal> one or more <literal>step
    choose</literal> entries follow in the rule definition. Each <literal>step
    choose</literal> chooses a defined number of nodes (or branches) from the
    previously selected upper node.
   </para>
   <para>
    In the end the selected OSDs are returned with <literal>step
    emit</literal>.
   </para>
   <para>
    <literal>step chooseleaf</literal> is a convenience function that directly
    selects OSDs from branches of the given bucket.
   </para>
   <para>
    <xref linkend="datamgm-rules-step-iterate-figure"/> provides an
    example of how <literal>step</literal> is used to iterate through a tree.
    The orange arrows and numbers correspond to <literal>example1a</literal>
    and <literal>example1b</literal>, while blue corresponds to
    <literal>example2</literal> in the following rule definitions.
   </para>
   <figure xml:id="datamgm-rules-step-iterate-figure">
    <title>Example Tree</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="crush-step.svg" width="100%" format="SVG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="crush-step.png" width="100%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
<screen># orange arrows
rule example1a {
        ruleset 0
        type replicated
        min_size 2
        max_size 10
        # orange (1)
        step take rack1
        # orange (2)
        step choose firstn 0 host
        # orange (3)
        step choose firstn 1 osd
        step emit
}

rule example1b {
        ruleset 0
        type replicated
        min_size 2
        max_size 10
        # orange (1)
        step take rack1
        # orange (2) + (3)
        step chooseleaf firstn 0 host
        step emit
}

# blue arrows
rule example2 {
        ruleset 0
        type replicated
        min_size 2
        max_size 10
        # blue (1)
        step take room1
        # blue (2)
        step chooseleaf firstn 0 rack
        step emit
}</screen>
  </sect2>

  <sect2 xml:id="datamgm-rules-step-mode">
   <title><literal>firstn</literal> and <literal>indep</literal></title>
   <para>
    A CRUSH rule defines replacements for failed nodes or OSDs (see
    <xref linkend="datamgm-rules"/>). The keyword
    <literal>step</literal> requires either <literal>firstn</literal> or
    <literal>indep</literal> as parameter.
    <xref linkend="datamgm-rules-step-mode-indep-figure"/> provides
    an example.
   </para>
   <para>
    <literal>firstn</literal> adds replacement nodes to the end of the list of
    active nodes. In case of a failed node, the following healthy nodes are
    shifted to the left to fill the gap of the failed node. This is the default
    and desired method for <emphasis>replicated pools</emphasis>, because a
    secondary node already has all data and therefore can take over the duties
    of the primary node immediately.
   </para>
   <para>
    <literal>indep</literal> selects fixed replacement nodes for each active
    node. The replacement of a failed node does not change the order of the
    remaining nodes. This is desired for <emphasis>erasure coded
    pools</emphasis>. In erasure coded pools the data stored on a node depends
    on its position in the node selection. When the order of nodes changes, all
    data on affected nodes needs to be relocated.
   </para>
   <figure xml:id="datamgm-rules-step-mode-indep-figure">
    <title>Node Replacement Methods</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="crush-firstn-indep.svg" width="100%" format="SVG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="crush-firstn-indep.png" width="100%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
  </sect2>
 </sect1>
 <sect1 xml:id="op-pgs">
  <title>Placement Groups</title>

  <para>
   &ceph; maps objects to placement groups (PGs). Placement groups are shards
   or fragments of a logical object pool that place objects as a group into
   OSDs. Placement groups reduce the amount of per-object metadata when &ceph;
   stores the data in OSDs. A larger number of placement groups&mdash;for
   example, 100 per OSD&mdash;leads to better balancing.
  </para>

  <sect2 xml:id="op-pgs-usage">
   <title>Using Placement Groups</title>
   <para>
    A placement group (PG) aggregates objects within a pool. The main reason is
    that tracking object placement and metadata on a per-object basis is
    computationally expensive. For example, a system with millions of objects
    cannot track placement of each of its objects directly.
   </para>
   <figure>
    <title>Placement Groups in a Pool</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="ceph_pgs_schema.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="ceph_pgs_schema.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    The &ceph; client will calculate to which placement group an object will
    belong to. It does this by hashing the object ID and applying an operation
    based on the number of PGs in the defined pool and the ID of the pool.
   </para>
   <para>
    The object’s contents within a placement group are stored in a set of
    OSDs. For example, in a replicated pool of size two, each placement group
    will store objects on two OSDs:
   </para>
   <figure>
    <title>Placement Groups and OSDs</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="ceph_pgs_osds.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="ceph_pgs_osds.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
   <para>
    If OSD #2 fails, another OSD will be assigned to placement group #1 and
    will be filled with copies of all objects in OSD #1. If the pool size is
    changed from two to three, an additional OSD will be assigned to the
    placement group and will receive copies of all objects in the placement
    group.
   </para>
   <para>
    Placement groups do not own the OSD, they share it with other placement
    groups from the same pool or even other pools. If OSD #2 fails, the
    placement group #2 will also need to restore copies of objects, using OSD
    #3.
   </para>
   <para>
    When the number of placement groups increases, the new placement groups
    will be assigned OSDs. The result of the CRUSH function will also change
    and some objects from the former placement groups will be copied over to
    the new placement groups and removed from the old ones.
   </para>
  </sect2>

  <sect2 xml:id="op-pgs-pg-num">
   <title>Determining the Value of <replaceable>PG_NUM</replaceable></title>
   <para>
    When creating a new pool, it is mandatory to choose the value of
    <replaceable>PG_NUM</replaceable>:
   </para>
<screen>
&prompt.root;ceph osd pool create <replaceable>POOL_NAME</replaceable> <replaceable>PG_NUM</replaceable>
</screen>
   <para>
    <replaceable>PG_NUM</replaceable> cannot be calculated automatically.
    Following are a few commonly used values, depending on the number of OSDs
    in the cluster:
   </para>
   <variablelist>
    <varlistentry>
     <term>Less than 5 OSDs:</term>
     <listitem>
      <para>
       Set <replaceable>PG_NUM</replaceable> to 128.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Between 5 and 10 OSDs:</term>
     <listitem>
      <para>
       Set <replaceable>PG_NUM</replaceable> to 512.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Between 10 and 50 OSDs:</term>
     <listitem>
      <para>
       Set <replaceable>PG_NUM</replaceable> to 1024.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    As the number of OSDs increases, choosing the right value for
    <replaceable>PG_NUM</replaceable> becomes more important.
    <replaceable>PG_NUM</replaceable> strongly affects the behavior of the
    cluster as well as the durability of the data in case of OSD failure.
   </para>
   <sect3 xml:id="op-pgs-choosing">
    <title>Calculating Placement Groups for More Than 50 OSDs</title>
    <para>
     If you have less than 50 OSDs, use the preselection described in
     <xref linkend="op-pgs-pg-num"/>. If you have more than 50
     OSDs, we recommend approximately 50-100 placement groups per OSD to
     balance out resource usage, data durability, and distribution. For a
     single pool of objects, you can use the following formula to get a
     baseline:
    </para>
<screen>total PGs = (OSDs * 100) / <replaceable>POOL_SIZE</replaceable></screen>
    <para>
     Where <replaceable>POOL_SIZE</replaceable> is either the number of
     replicas for replicated pools, or the 'k'+'m' sum for erasure coded pools
     as returned by the <command>ceph osd erasure-code-profile get</command>
     command. You should round the result up to the nearest power of 2.
     Rounding up is recommended for the CRUSH algorithm to evenly balance the
     number of objects among placement groups.
    </para>
    <para>
     As an example, for a cluster with 200 OSDs and a pool size of 3 replicas,
     you would estimate the number of PGs as follows:
    </para>
<screen>
          (200 * 100) / 3 = 6667
</screen>
    <para>
     The nearest power of 2 is <emphasis role="bold">8192</emphasis>.
    </para>
    <para>
     When using multiple data pools for storing objects, you need to ensure
     that you balance the number of placement groups per pool with the number
     of placement groups per OSD. You need to reach a reasonable total number
     of placement groups that provides reasonably low variance per OSD without
     taxing system resources or making the peering process too slow.
    </para>
    <para>
     For example, a cluster of 10 pools, each with 512 placement groups on 10
     OSDs, is a total of 5,120 placement groups spread over 10 OSDs, that is
     512 placement groups per OSD. Such a setup does not use too many
     resources. However, if 1000 pools were created with 512 placement groups
     each, the OSDs would handle approximately 50,000 placement groups each and
     it would require significantly more resources and time for peering.
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="op-pg-set">
   <title>Setting the Number of Placement Groups</title>
   <para>
    To set the number of placement groups in a pool, you need to specify the
    number of placement groups at the time you create the pool (see
    <xref linkend="ceph-pools-operate-add-pool"/>). Once you have set
    placement groups for a pool, you may increase the number of placement
    groups, but you cannot decrease them. To increase the number of placement
    groups, run the following:
   </para>
<screen>
&prompt.root;ceph osd pool set <replaceable>POOL_NAME</replaceable> pg_num <replaceable>PG_NUM</replaceable>
</screen>
   <para>
    After you increase the number of placement groups, you also need to
    increase the number of placement groups for placement
    (<option>PGP_NUM</option>) before your cluster will rebalance.
    <option>PGP_NUM</option> will be the number of placement groups that will
    be considered for placement by the CRUSH algorithm. Increasing
    <option>PG_NUM</option> splits the placement groups but data will not be
    migrated to the newer placement groups until <option>PGP_NUM</option> is
    increased. <option>PGP_NUM</option> should be equal to
    <option>PG_NUM</option>. To increase the number of placement groups for
    placement, run the following:
   </para>
<screen>
&prompt.root;ceph osd pool set <replaceable>POOL_NAME</replaceable> pgp_num <replaceable>PGP_NUM</replaceable>
</screen>
  </sect2>

  <sect2 xml:id="op-pg-get">
   <title>Finding the Number of Placement Groups</title>
   <para>
    To find out the number of placement groups in a pool, run the following
    <command>get</command> command:
   </para>
<screen>
&prompt.root;ceph osd pool get <replaceable>POOL_NAME</replaceable> pg_num
</screen>
  </sect2>

  <sect2 xml:id="op-pg-getpgstat">
   <title>Finding a Cluster's PG Statistics</title>
   <para>
    To find out the statistics for the placement groups in your cluster, run the
    following command:
   </para>
<screen>
&prompt.root;ceph pg dump [--format <replaceable>FORMAT</replaceable>]
</screen>
   <para>
    Valid formats are 'plain' (default) and 'json'.
   </para>
  </sect2>

  <sect2 xml:id="op-pg-getstuckstat">
   <title>Finding Statistics for Stuck PGs</title>
   <para>
    To find out the statistics for all placement groups stuck in a specified state,
    run the following:
   </para>
<screen>
&prompt.root;ceph pg dump_stuck <replaceable>STATE</replaceable> \
 [--format <replaceable>FORMAT</replaceable>] [--threshold <replaceable>THRESHOLD</replaceable>]
</screen>
   <para>
    <replaceable>STATE</replaceable> is one of 'inactive' (PGs cannot process
    reads or writes because they are waiting for an OSD with the most
    up-to-date data to come up), 'unclean' (PGs contain objects that are not
    replicated the desired number of times), 'stale' (PGs are in an unknown
    state&mdash;the OSDs that host them have not reported to the monitor
    cluster in a time interval specified by the
    <option>mon_osd_report_timeout</option> option), 'undersized', or
    'degraded'.
   </para>
   <para>
    Valid formats are 'plain' (default) and 'json'.
   </para>
   <para>
    The threshold defines the minimum number of seconds the placement group is
    stuck before including it in the returned statistics (300 seconds by
    default).
   </para>
  </sect2>

  <sect2 xml:id="op-pgs-pgmap">
   <title>Searching a Placement Group Map</title>
   <para>
    To search for the placement group map for a particular placement group, run the
    following:
   </para>
<screen>
&prompt.root;ceph pg map <replaceable>PG_ID</replaceable>
</screen>
   <para>
    &ceph; will return the placement group map, the placement group, and the
    OSD status:
   </para>
<screen>
&prompt.root;ceph pg map 1.6c
osdmap e13 pg 1.6c (1.6c) -> up [1,0] acting [1,0]
</screen>
  </sect2>

  <sect2 xml:id="op-pg-pgstats">
   <title>Retrieving a Placement Groups Statistics</title>
   <para>
    To retrieve statistics for a particular placement group, run the following:
   </para>
<screen>
&prompt.root;ceph pg <replaceable>PG_ID</replaceable> query
</screen>
  </sect2>

  <sect2 xml:id="op-pg-scrubpg">
   <title>Scrubbing a Placement Group</title>
   <para>
    To scrub (<xref linkend="scrubbing-pgs"/>) a placement group, run the
    following:
   </para>
<screen>
&prompt.root;ceph pg scrub <replaceable>PG_ID</replaceable>
</screen>
   <para>
    &ceph; checks the primary and replica nodes, generates a catalog of all
    objects in the placement group, and compares them to ensure that no objects
    are missing or mismatched and their contents are consistent. Assuming the
    replicas all match, a final semantic sweep ensures that all of the
    snapshot-related object metadata is consistent. Errors are reported via
    logs.
   </para>
  </sect2>

  <sect2 xml:id="op-pg-backfill">
   <title>Prioritizing Backfill and Recovery of Placement Groups</title>
   <para>
    You may run into a situation where several placement groups require
    recovery and/or back-fill, while some groups hold data more important than
    others. For example, those PGs may hold data for images used by running
    machines and other PGs may be used by inactive machines or less relevant
    data. In that case, you may want to prioritize recovery of those groups so
    that performance and availability of data stored on those groups is
    restored earlier. To mark particular placement groups as prioritized during
    backfill or recovery, run the following:
   </para>
<screen>
&prompt.root;ceph pg force-recovery <replaceable>PG_ID1</replaceable> [<replaceable>PG_ID2</replaceable> ... ]
&prompt.root;ceph pg force-backfill <replaceable>PG_ID1</replaceable> [<replaceable>PG_ID2</replaceable> ... ]
</screen>
   <para>
    This will cause &ceph; to perform recovery or backfill on specified
    placement groups first, before other placement groups. This does not
    interrupt currently ongoing backfills or recovery, but causes specified PGs
    to be processed as soon as possible. If you change your mind or prioritize
    wrong groups, cancel the prioritization:
   </para>
<screen>
&prompt.root;ceph pg cancel-force-recovery <replaceable>PG_ID1</replaceable> [<replaceable>PG_ID2</replaceable> ... ]
&prompt.root;ceph pg cancel-force-backfill <replaceable>PG_ID1</replaceable> [<replaceable>PG_ID2</replaceable> ... ]
</screen>
   <para>
    The <command>cancel-*</command> commands remove the 'force' flag from the
    PGs so that they are processed in default order. Again, this does not
    affect placement groups currently being processed, only those that are
    still queued. The 'force' flag is cleared automatically after recovery or
    backfill of the group is done.
   </para>
  </sect2>
  <sect2 xml:id="op-pgs-revert">
     <title>Reverting Lost Objects</title>
     <para>
      If the cluster has lost one or more objects and you have decided to abandon
      the search for the lost data, you need to mark the unfound objects as
      'lost'.
     </para>
     <para>
      If the objects are still lost after having queried all possible locations,
      you may need to give up on the lost objects. This is possible given unusual
      combinations of failures that allow the cluster to learn about writes that
      were performed before the writes themselves are recovered.
     </para>
     <para>
      Currently the only supported option is 'revert', which will either roll
      back to a previous version of the object, or forget about it entirely in
      case of a new object. To mark the 'unfound' objects as 'lost', run the
      following:
     </para>
  <screen>
  &prompt.cephuser;ceph pg <replaceable>PG_ID</replaceable> mark_unfound_lost revert|delete
  </screen>
    </sect2>
    <sect2 xml:id="op-pgs-autoscaler">
     <title>Enabling the PG Auto-scaler</title>
     <para>
       Placement groups (PGs) are an internal implementation detail of how
       &ceph; distributes data. By enabling pg-autoscaling, you can allow
       the cluster to either make or automatically tune PGs based on how
       the cluster is used.
     </para>
     <para>
       Each pool in the system has a <option>pg_autoscale_mode</option> property that can be
       set to <literal>off</literal>, <literal>on</literal>, or <literal>warn</literal>:
     </para>
     <para>
       The autoscaler is configured on a per-pool basis, and can run in
       three modes:
     </para>
     <variablelist>
       <varlistentry><term>off</term>
        <listitem>
          <para>
            Disable autoscaling for this pool. It is up to the administrator
            to choose an appropriate PG number for each pool.
          </para>
        </listitem>
       </varlistentry>
       <varlistentry><term>on</term>
        <listitem>
          <para>
            Enable automated adjustments of the PG count for the given pool.
          </para>
        </listitem>
       </varlistentry>
       <varlistentry><term>warn</term>
        <listitem>
          <para>
            Raise health alerts when the PG count should be adjusted.
          </para>
        </listitem>
       </varlistentry>
     </variablelist>
     <para>
       To set the autoscaling mode for existing pools:
     </para>
<screen>&prompt.cephuser;ceph osd pool set <replaceable>POOL_NAME</replaceable> pg_autoscale_mode <replaceable>mode</replaceable></screen>
     <para>
       You can also configure the default <option>pg_autoscale_mode</option>
       that is applied to any pools that are created in the future with:
     </para>
<screen>&prompt.cephuser;ceph config set global osd_pool_default_pg_autoscale_mode <replaceable>MODE</replaceable></screen>
     <para>
       You can view each pool, its relative utilization, and any suggested
       changes to the PG count with this command:
     </para>
<screen>&prompt.cephuser;ceph osd pool autoscale-status</screen>
    </sect2>
 </sect1>
 <sect1 xml:id="op-crush">
  <title>&crushmap; Manipulation</title>

  <para>
   This section introduces ways to basic &crushmap; manipulation, such as
   editing a &crushmap;, changing &crushmap; parameters, and
   adding/moving/removing an OSD.
  </para>

  <sect2>
   <title>Editing a &crushmap;</title>
   <para>
    To edit an existing CRUSH map, do the following:
   </para>
   <procedure>
    <step>
     <para>
      Get a &crushmap;. To get the &crushmap; for your cluster, execute the
      following:
     </para>
<screen>&prompt.cephuser;ceph osd getcrushmap -o <replaceable>compiled-crushmap-filename</replaceable></screen>
     <para>
      &ceph; will output (<option>-o</option>) a compiled &crushmap; to the
      file name you specified. Since the &crushmap; is in a compiled form, you
      must decompile it first before you can edit it.
     </para>
    </step>
    <step>
     <para>
      Decompile a &crushmap;. To decompile a &crushmap;, execute the following:
     </para>
<screen>&prompt.cephuser;crushtool -d <replaceable>compiled-crushmap-filename</replaceable> \
 -o <replaceable>decompiled-crushmap-filename</replaceable></screen>
     <para>
      &ceph; will decompile (<option>-d</option>) the compiled &crushmap;and
      output (<option>-o</option>) it to the file name you specified.
     </para>
    </step>
    <step>
     <para>
      Edit at least one of Devices, Buckets and Rules parameters.
     </para>
    </step>
    <step>
     <para>
      Compile a &crushmap;. To compile a &crushmap;, execute the following:
     </para>
<screen>&prompt.cephuser;crushtool -c <replaceable>decompiled-crush-map-filename</replaceable> \
 -o <replaceable>compiled-crush-map-filename</replaceable></screen>
     <para>
      &ceph; will store a compiled &crushmap;to the file name you specified.
     </para>
    </step>
    <step>
     <para>
      Set a &crushmap;. To set the &crushmap; for your cluster, execute the
      following:
     </para>
<screen>&prompt.cephuser;ceph osd setcrushmap -i <replaceable>compiled-crushmap-filename</replaceable></screen>
     <para>
      &ceph; will input the compiled &crushmap; of the file name you specified
      as the &crushmap; for the cluster.
     </para>
    </step>
   </procedure>
   <tip>
    <title>Use Versioning System</title>
    <para>
     Use a versioning system&mdash;such as git or svn&mdash;for the exported
     and modified &crushmap; files. It makes a possible rollback simple.
    </para>
   </tip>
   <tip>
    <title>Test the New &crushmap;</title>
    <para>
     Test the new adjusted &crushmap; using the <command>crushtool
     --test</command> command, and compare to the state before applying the new
     &crushmap;. You may find the following command switches useful:
     <option>--show-statistics</option>, <option>--show-mappings</option>,
     <option>--show-bad-mappings</option>, <option>--show-utilization</option>,
     <option>--show-utilization-all</option>,
     <option>--show-choose-tries</option>
    </para>
   </tip>
  </sect2>

  <sect2 xml:id="op-crush-addosd">
   <title>Adding or Moving an OSD</title>
   <para>
    To add or move an OSD in the &crushmap; of a running cluster, execute the
    following:
   </para>
<screen>&prompt.cephuser;ceph osd crush set <replaceable>id_or_name</replaceable> <replaceable>weight</replaceable> root=<replaceable>pool-name</replaceable>
<replaceable>bucket-type</replaceable>=<replaceable>bucket-name</replaceable> ...</screen>
   <variablelist>
    <varlistentry>
     <term>id</term>
     <listitem>
      <para>
       An integer. The numeric ID of the OSD. This option is required.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>name</term>
     <listitem>
      <para>
       A string. The full name of the OSD. This option is required.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>weight</term>
     <listitem>
      <para>
       A double. The CRUSH weight for the OSD. This option is required.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>root</term>
     <listitem>
      <para>
       A key/value pair. By default, the CRUSH hierarchy contains the pool
       default as its root. This option is required.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>bucket-type</term>
     <listitem>
      <para>
       Key/value pairs. You may specify the OSD’s location in the CRUSH
       hierarchy.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    The following example adds <literal>osd.0</literal> to the hierarchy, or
    moves the OSD from a previous location.
   </para>
<screen>&prompt.cephuser;ceph osd crush set osd.0 1.0 root=data datacenter=dc1 room=room1 \
row=foo rack=bar host=foo-bar-1</screen>
  </sect2>

  <sect2 xml:id="op-crush-osdweight">
   <title>Difference between <command>ceph osd reweight</command> and <command>ceph osd crush reweight</command></title>
   <para>
    There are two similar commands that change the 'weight' of a &osd;. The
    context of their usage is different and may cause confusion.
   </para>
   <sect3 xml:id="ceph-osd-reweight">
    <title><command>ceph osd reweight</command></title>
    <para>
     Usage:
    </para>
<screen>&prompt.cephuser;ceph osd reweight <replaceable>OSD_NAME</replaceable> <replaceable>NEW_WEIGHT</replaceable></screen>
    <para>
     <command>ceph osd reweight</command> sets an override weight on the &osd;.
     This value is in the range of 0 to 1, and forces CRUSH to reposition the
     data that would otherwise live on this drive. It does
     <emphasis
      role="bold"
     >not</emphasis> change the weights
     assigned to the buckets above the OSD, and is a corrective measure in case
     the normal CRUSH distribution is not working out quite right. For example,
     if one of your OSDs is at 90% and the others are at 40%, you could reduce
     this weight to try and compensate for it.
    </para>
    <note>
     <title>OSD Weight Is Temporary</title>
     <para>
      Note that <command>ceph osd reweight</command> is not a persistent
      setting. When an OSD gets marked out, its weight will be set to 0 and
      when it gets marked in again, the weight will be changed to 1.
     </para>
    </note>
   </sect3>
   <sect3 xml:id="ceph-osd-crush-reweight">
    <title><command>ceph osd crush reweight</command></title>
    <para>
     Usage:
    </para>
<screen>&prompt.cephuser;ceph osd crush reweight <replaceable>OSD_NAME</replaceable> <replaceable>NEW_WEIGHT</replaceable></screen>
    <para>
     <command>ceph osd crush reweight</command> sets the
     <emphasis role="bold"
      >CRUSH</emphasis> weight of the OSD. This
     weight is an arbitrary value&mdash;generally the size of the disk in
     TB&mdash;and controls how much data the system tries to allocate to the
     OSD.
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="op-crush-osdremove">
   <title>Removing an OSD</title>
   <para>
    To remove an OSD from the &crushmap; of a running cluster, execute the
    following:
   </para>
<screen>&prompt.cephuser;ceph osd crush remove <replaceable>OSD_NAME</replaceable></screen>
  </sect2>

  <sect2 xml:id="op-crush-addbaucket">
   <title>Adding a Bucket</title>
   <para>
    To add a bucket to the &crushmap; of a running cluster, execute the
    <command>ceph osd crush add-bucket</command> command:
   </para>
<screen>&prompt.cephuser;ceph osd crush add-bucket <replaceable>BUCKET_NAME</replaceable> <replaceable>BUCKET_TYPE</replaceable></screen>
  </sect2>

  <sect2 xml:id="op-crush-movebucket">
   <title>Moving a Bucket</title>
   <para>
    To move a bucket to a different location or position in the &crushmap;
    hierarchy, execute the following:
   </para>
<screen>&prompt.cephuser;ceph osd crush move <replaceable>BUCKET_NAME</replaceable> <replaceable>BUCKET_TYPE</replaceable>=<replaceable>BUCKET_NAME</replaceable> [...]</screen>
   <para>
    For example:
   </para>
<screen>
&prompt.cephuser;ceph osd crush move bucket1 datacenter=dc1 room=room1 row=foo rack=bar host=foo-bar-1
</screen>
  </sect2>

  <sect2 xml:id="op-crush-rmbucket">
   <title>Removing a Bucket</title>
   <para>
    To remove a bucket from the &crushmap; hierarchy, execute the following:
   </para>
<screen>
&prompt.cephuser;ceph osd crush remove <replaceable>BUCKET_NAME</replaceable>
</screen>
   <note>
    <title>Empty Bucket Only</title>
    <para>
     A bucket must be empty before removing it from the CRUSH hierarchy.
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 xml:id="scrubbing-pgs">
  <title>Scrubbing Placement Groups</title>

  <para>
   In addition to making multiple copies of objects, &ceph; ensures data
   integrity by <emphasis>scrubbing</emphasis> placement groups (find more
   information about placement groups in
   <xref linkend="storage-intro-structure-pg"/>). &ceph; scrubbing is
   analogous to running <command>fsck</command> on the object storage layer.
   For each placement group, &ceph; generates a catalog of all objects and
   compares each primary object and its replicas to ensure that no objects are
   missing or mismatched. Daily light scrubbing checks the object size and
   attributes, while weekly deep scrubbing reads the data and uses checksums to
   ensure data integrity.
  </para>

  <para>
   Scrubbing is important for maintaining data integrity, but it can reduce
   performance. You can adjust the following settings to increase or decrease
   scrubbing operations:
  </para>

  <variablelist>
   <varlistentry>
    <term><option>osd max scrubs</option></term>
    <listitem>
     <para>
      The maximum number of simultaneous scrub operations for a &osd;. Default
      is 1.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>osd scrub begin hour</option>, <option>osd scrub end hour</option></term>
    <listitem>
     <para>
      The hours of day (0 to 24) that define a time window during which the
      scrubbing can happen. By default, begins at 0 and ends at 24.
     </para>
     <important>
      <para>
       If the placement group’s scrub interval exceeds the <option>osd scrub
       max interval</option> setting, the scrub will happen no matter what time
       window you define for scrubbing.
      </para>
     </important>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>osd scrub during recovery</option></term>
    <listitem>
     <para>
      Allows scrubs during recovery. Setting this to 'false' will disable
      scheduling new scrubs while there is an active recovery. Already running
      scrubs will continue. This option is useful for reducing load on busy
      clusters. Default is 'true'.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>osd scrub thread timeout</option></term>
    <listitem>
     <para>
      The maximum time in seconds before a scrub thread times out. Default is
      60.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>osd scrub finalize thread timeout</option></term>
    <listitem>
     <para>
      The maximum time in seconds before a scrub finalize thread times out.
      Default is 60*10.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>osd scrub load threshold</option></term>
    <listitem>
     <para>
      The normalized maximum load. &ceph; will not scrub when the system load
      (as defined by the ratio of <literal>getloadavg()</literal> / number of
      <literal>online cpus</literal>) is higher than this number. Default is
      0.5.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>osd scrub min interval</option></term>
    <listitem>
     <para>
      The minimal interval in seconds for scrubbing &osd; when the &ceph;
      cluster load is low. Default is 60*60*24 (once a day).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>osd scrub max interval</option></term>
    <listitem>
     <para>
      The maximum interval in seconds for scrubbing &osd;, irrespective of
      cluster load. Default is 7*60*60*24 (once a week).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>osd scrub chunk min</option></term>
    <listitem>
     <para>
      The minimum number of object store chunks to scrub during a single
      operation. &ceph; blocks writes to a single chunk during a scrub. Default
      is 5.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>osd scrub chunk max</option></term>
    <listitem>
     <para>
      The maximum number of object store chunks to scrub during a single
      operation. Default is 25.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>osd scrub sleep</option></term>
    <listitem>
     <para>
      Time to sleep before scrubbing the next group of chunks. Increasing this
      value slows down the whole scrub operation, while client operations are
      less impacted. Default is 0.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>osd deep scrub interval</option></term>
    <listitem>
     <para>
      The interval for 'deep' scrubbing (fully reading all data). The
      <option>osd scrub load threshold</option> option does not affect this
      setting. Default is 60*60*24*7 (once a week).
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>osd scrub interval randomize ratio</option></term>
    <listitem>
     <para>
      Add a random delay to the <option>osd scrub min interval</option> value
      when scheduling the next scrub job for a placement group. The delay is a
      random value smaller than the result of <option>osd scrub min
      interval</option> * <option>osd scrub interval randomized ratio</option>.
      Therefore, the default setting practically randomly spreads the scrubs
      out in the allowed time window of [1, 1.5] * <option>osd scrub min
      interval</option>. Default is 0.5.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>osd deep scrub stride</option></term>
    <listitem>
     <para>
      Read size when doing a deep scrub. Default is 524288 (512 kB).
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
</chapter>
