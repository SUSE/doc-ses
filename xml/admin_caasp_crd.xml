<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="admin-caasp-crd">
<!-- ============================================================== -->
 <title>&ceph; Cluster Custom Resource Definitions</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:editurl>https://github.com/SUSE/doc-ses/edit/master/xml/</dm:editurl>
   <dm:translation>yes</dm:translation>
   <dm:release>SES 7</dm:release>
  </dm:docmanager>
 </info>
 <sect1 xml:id="rook-ceph-cluster-crd">
  <title>&ceph; Cluster CRD</title>

  <para>
   &rook; allows the creation and customization of storage clusters through
   Custom Resource Definitions (CRDs). There are two different modes of cluster
   creation, depending on whether the storage on which to base the &ceph;
   cluster can be dynamically provisioned.
  </para>

  <orderedlist>
   <listitem>
    <para>
     Specify host paths and raw devices.
    </para>
   </listitem>
   <listitem>
    <para>
     Specify the storage class &rook; should use to consume storage via PVCs.
    </para>
   </listitem>
  </orderedlist>

  <para>
   An example for each of these approaches follows.
  </para>

  <sect2 xml:id="rook-host-based-cluster">
   <title>Host-Based Cluster</title>
   <para>
    To get you started, here is a simple example of a CRD to configure a &ceph;
    cluster with all nodes and all devices. In the next example, the MONs and
    OSDs are backed by PVCs.
   </para>
   <note>
    <para>
     In addition to your CephCluster object, you need to create the namespace,
     service accounts, and RBAC rules for the namespace you are going to create
     the CephCluster in. These resources are defined in the example
     <filename>common.yaml</filename>.
    </para>
   </note>
<screen>
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    # see the &quot;Cluster Settings&quot; section below for more details on which image of &ceph; to run
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: true
  storage:
    useAllNodes: true
    useAllDevices: true
</screen>
  </sect2>

  <sect2 xml:id="rook-pvc-based-cluster">
   <title>PVC-based Cluster</title>
   <note>
    <para>
     &kube; version 1.13.0 or greater is required to provision OSDs on PVCs.
    </para>
   </note>
<screen>
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    # see the &quot;Cluster Settings&quot; section below for more details on which image of &ceph; to run
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    volumeClaimTemplate:
      spec:
        storageClassName: local-storage
        resources:
          requests:
            storage: 10Gi
  storage:
   storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      encrypted: false
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)
          storageClassName: local-storage
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</screen>
   <para>
    For a more advanced scenario, such as adding a dedicated device, please
    refer to
    <xref linkend="rook-dedicated-metadata-and-wal-device-for-osd-on-pvc"/>.
   </para>
  </sect2>

  <sect2 xml:id="rook-settings">
   <title>Settings</title>
   <para>
    Settings can be specified at the global level to apply to the cluster as a
    whole, while other settings can be specified at more fine-grained levels.
    If any setting is unspecified, a suitable default will be used
    automatically.
   </para>
   <sect3 xml:id="rook-cluster-metadata">
    <title>Cluster Metadata</title>
    <itemizedlist>
     <listitem>
      <para>
       <literal>name</literal>: The name that will be used internally for the
       &ceph; cluster. Most commonly the name is the same as the namespace
       since multiple clusters are not supported in the same namespace.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>namespace</literal>: The &kube; namespace that will be created
       for the &rook; cluster. The services, pods, and other resources created
       by the operator will be added to this namespace. The common scenario is
       to create a single &rook; cluster. If multiple clusters are created,
       they must not have conflicting devices or host paths.
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
   <sect3 xml:id="rook-cluster-settings">
    <title>Cluster Settings</title>
    <itemizedlist>
     <listitem>
      <para>
       <literal>external</literal>:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>enable</literal>: if <literal>true</literal>, the cluster
         will not be managed by &rook; but via an external entity. This mode is
         intended to connect to an existing cluster. In this case, &rook; will
         only consume the external cluster. However, &rook; will be able to
         deploy various daemons in &kube; such as object gateways, MDS and NFS
         if an image is provided and will refuse otherwise. If this setting is
         enabled <emphasis role="strong">all</emphasis> the other options will
         be ignored except <literal>cephVersion.image</literal> and
         <literal>dataDirHostPath</literal>. See
         <xref linkend="rook-external-cluster"/>. If
         <literal>cephVersion.image</literal> is left blank, &rook; will refuse
         the creation of extra CRs like object, file and nfs.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>cephVersion</literal>: The version information for launching
       the &ceph; daemons.
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>image</literal>: The image used for running the &ceph;
         daemons. For example, <literal>ceph/ceph:v14.2.10</literal> or
         <literal>ceph/ceph:v15.2.4</literal>. To ensure a consistent version
         of the image is running across all nodes in the cluster, we recommend
         to use a very specific image version. Tags also exist that would give
         the latest version, but they are only recommended for test
         environments. For example, the tag <literal>v14</literal> will be
         updated each time a new nautilus build is released. Using the
         <literal>v14</literal> or similar tag is not recommended in production
         because it may lead to inconsistent versions of the image running
         across different nodes in the cluster.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>dataDirHostPath</literal>: The path on the host where config
       and data should be stored for each of the services. If the directory
       does not exist, it will be created. Because this directory persists on
       the host, it will remain after pods are deleted. Following paths and any
       of their subpaths <emphasis role="strong">must not be used</emphasis>:
       <command>/etc/ceph</command>, <command>/rook</command> or
       <command>/var/log/ceph</command>.
      </para>
      <itemizedlist>
       <listitem>
        <para>
         On <emphasis role="strong">Minikube</emphasis> environments, use
         <command>/data/rook</command>. Minikube boots into a tmpfs but it
         provides some directories where files can be persisted across reboots.
         Using one of these directories will ensure that &rook;’s data and
         configuration files are persisted and that enough storage space is
         available.
        </para>
        <warning>
         <para>
          <emphasis role="strong">WARNING</emphasis>: For test scenarios, if
          you delete a cluster and start a new cluster on the same hosts, the
          path used by <literal>dataDirHostPath</literal> must be deleted.
          Otherwise, stale keys and other config will remain from the previous
          cluster and the new MONs will fail to start. If this value is empty,
          each pod will get an ephemeral directory to store their config files
          that is tied to the lifetime of the pod running on that node.
         </para>
        </warning>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>continueUpgradeAfterChecksEvenIfNotHealthy</literal>: if set to
       true &rook; will continue the OSD daemon upgrade process even if the PGs
       are not clean, or continue with the MDS upgrade even the file system is
       not healthy.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>dashboard</literal>: Settings for the &dashboard;. To view the
       dashboard in your browser see <xref linkend="ceph-dashboard"/>.
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>enabled</literal>: Whether to enable the dashboard to view
         cluster status.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>urlPrefix</literal>: Allows to serve the dashboard under a
         subpath (useful when you are accessing the dashboard via a reverse
         proxy).
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>port</literal>: Allows to change the default port where the
         dashboard is served.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>ssl</literal>: Whether to serve the dashboard via SSL,
         ignored on &ceph; versions older than <literal>13.2.2</literal>.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>monitoring</literal>: Settings for monitoring &ceph; using
       &prometheus;. To enable monitoring on your cluster see the
       <xref linkend="monitoring-alerting"/>.
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>enabled</literal>: Whether to enable &prometheus; based
         mostnitoring for this cluster.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>rulesNamespace</literal>: Namespace to deploy
         <literal>prometheusRule</literal>. If empty, namespace of the cluster
         will be used. We recommend:
        </para>
        <itemizedlist>
         <listitem>
          <para>
           If you have a single &rook; &ceph; cluster, set the
           <literal>rulesNamespace</literal> to the same namespace as the
           cluster or keep it empty.
          </para>
         </listitem>
         <listitem>
          <para>
           If you have multiple &rook; &ceph; clusters in the same &kube;
           cluster, choose the same namespace to set
           <literal>rulesNamespace</literal> for all the clusters (ideally,
           namespace with &prometheus; deployed). Otherwise, you will get
           duplicate alerts with duplicate alert definitions.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>network</literal>: For the network settings for the cluster,
       refer to <xref linkend="rook-network-configuration-settings"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>mon</literal>: contains MON related options
       <xref linkend="rook-mon-settings"/>.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>mgr</literal>: manager top level section.
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>modules</literal>: is the list of &mgr; modules to enable.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>crashCollector</literal>: The settings for crash collector
       daemon(s).
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>disable</literal>: is set to <literal>true</literal>, the
         crash collector will not run on any node where a &ceph; daemon runs.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>annotations</literal>:
       <xref linkend="rook-annotations-and-labels"/>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>labels</literal>: <xref linkend="rook-annotations-and-labels"/>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>placement</literal>:
       <xref linkend="rook-placement-configuration-settings"/>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>resources</literal>:
       <xref linkend="rook-cluster-wide-resources-configuration-settings"/>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>priorityClassNames</literal>:
       <xref linkend="rook-priority-class-names-configuration-settings"/>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>storage</literal>: Storage selection and configuration that
       will be used across the cluster. Note that these settings can be
       overridden for specific nodes.
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>useAllNodes</literal>: <literal>true</literal> or
         <literal>false</literal>, indicating if all nodes in the cluster
         should be used for storage according to the cluster level storage
         selection and configuration values. If individual nodes are specified
         under the <literal>nodes</literal> field, then
         <literal>useAllNodes</literal> must be set to
         <literal>false</literal>.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>nodes</literal>: Names of individual nodes in the cluster
         that should have their storage included in accordance with either the
         cluster level configuration specified above or any node specific
         overrides described in the next section below.
         <literal>useAllNodes</literal> must be set to <literal>false</literal>
         to use specific nodes and their config. See
         <xref linkend="rook-node-settings"/> below.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>config</literal>: Config settings applied to all OSDs on the
         node unless overridden by <literal>devices</literal>.
        </para>
       </listitem>
       <listitem>
        <para>
         <xref linkend="rook-storage-selection-settings"/>
        </para>
       </listitem>
       <listitem>
        <para>
         <xref linkend="rook-storage-class-device-sets"/>
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>disruptionManagement</literal>: The section for configuring
       management of daemon disruptions
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>managePodBudgets</literal>: if <literal>true</literal>, the
         operator will create and manage
         <literal>PodDisruptionBudgets</literal> for OSD, MON, RGW, and MDS
         daemons. The operator will block eviction of OSDs by default and
         unblock them safely when drains are detected.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>osdMaintenanceTimeout</literal>: is a duration in minutes
         that determines how long an entire failure domain like
         <literal>region/zone/host</literal> will be held in
         <literal>noout</literal> (in addition to the default DOWN/OUT
         interval) when it is draining. This is only relevant when
         <literal>managePodBudgets</literal> is <literal>true</literal>. The
         default value is <literal>30</literal> minutes.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>manageMachineDisruptionBudgets</literal>: if
         <literal>true</literal>, the operator will create and manage
         <literal>MachineDisruptionBudgets</literal> to ensure OSDs are only
         fenced when the cluster is healthy. Only available on OpenShift.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>machineDisruptionBudgetNamespace</literal>: the namespace in
         which to watch the <literal>MachineDisruptionBudgets</literal>.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>removeOSDsIfOutAndSafeToRemove</literal>: If
       <literal>true</literal> the operator will remove the OSDs that are down
       and whose data has been restored to other OSDs.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>cleanupPolicy</literal>: <xref linkend="rook-cleanup-policy"/>
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
   <sect3 xml:id="rook-mon-settings">
    <title>MON Settings</title>
    <itemizedlist>
     <listitem>
      <para>
       <literal>count</literal>: Set the number of MONs to be started. The
       number should be odd and between one and nine. If not specified, the
       default is set to three and <literal>allowMultiplePerNode</literal> is
       also set to <literal>true</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>allowMultiplePerNode</literal>: Enable
       (<literal>true</literal>) or disable (<literal>false</literal>) the
       placement of multiple MONs on one node. Default is
       <literal>false</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>volumeClaimTemplate</literal>: A
       <literal>PersistentVolumeSpec</literal> used by &rook; to create PVCs
       for monitor storage. This field is optional, and when not provided,
       HostPath volume mounts are used. The current set of fields from template
       that are used are <literal>storageClassName</literal> and the
       <literal>storage</literal> resource request and limit. The default
       storage size request for new PVCs is <literal>10Gi</literal>. Ensure
       that associated storage class is configured to use
       <literal>volumeBindingMode: WaitForFirstConsumer</literal>. This setting
       only applies to new monitors that are created when the requested number
       of monitors increases, or when a monitor fails and is recreated.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     If these settings are changed in the CRD, the operator will update the
     number of MONs during a periodic check of the MON health, which by default
     is every 45 seconds.
    </para>
    <para>
     To change the defaults that the operator uses to determine the MON health
     and whether to failover a MON, refer to the
     <xref linkend="rook-health-settings"/>. The intervals should be small
     enough that you have confidence the MONs will maintain quorum, while also
     being long enough to ignore network blips where MONs are failed over too
     often.
    </para>
   </sect3>
   <sect3 xml:id="rook-mgr-settings">
    <title>&mgr; Settings</title>
    <para>
     You can use the cluster CR to enable or disable any manager module. For
     example, this can be configured:
    </para>
<screen>
mgr:
  modules:
  - name: &lt;name of the module&gt;
    enabled: true
</screen>
    <para>
     Some modules will have special configuration to ensure the module is fully
     functional after being enabled. Specifically the
     <literal>pg_autoscaler</literal>: &rook; will configure all new pools with
     PG autoscaling by setting: <literal>osd_pool_default_pg_autoscale_mode =
     on</literal>
    </para>
   </sect3>
   <sect3 xml:id="rook-network-configuration-settings">
    <title>Network Configuration Settings</title>
    <para>
     If not specified, the default SDN will be used. Configure the network that
     will be enabled for the cluster and services.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>provider</literal>: Specifies the network provider that will be
       used to connect the network interface.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>selectors</literal>: List the network selector(s) that will be
       used associated by a key.
      </para>
     </listitem>
    </itemizedlist>
    <note>
     <para>
      Changing networking configuration after a &ceph; cluster has been
      deployed is not supported and will result in a non-functioning cluster.
     </para>
    </note>
    <para>
     To use host networking, set <literal>provider: host</literal>.
    </para>
   </sect3>
   <sect3 xml:id="rook-node-settings">
    <title>Node Settings</title>
    <para>
     In addition to the cluster level settings specified above, each individual
     node can also specify configuration to override the cluster level settings
     and defaults. If a node does not specify any configuration then it will
     inherit the cluster level settings.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>name</literal>: The name of the node, which should match its
       <literal>kubernetes.io/hostname</literal> label.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>config</literal>: Config settings applied to all OSDs on the
       node unless overridden by <literal>devices</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       <xref linkend="rook-storage-selection-settings"/>
      </para>
     </listitem>
    </itemizedlist>
    <para>
     When <literal>useAllNodes</literal> is set to <literal>true</literal>,
     &rook; attempts to make &ceph; cluster management as hands-off as possible
     while still maintaining reasonable data safety. If a usable node comes
     online, &rook; will begin to use it automatically. To maintain a balance
     between hands-off usability and data safety, Nodes are removed from &ceph;
     as OSD hosts only (1) if the node is deleted from &kube; itself or (2) if
     the node has its taints or affinities modified in such a way that the node
     is no longer usable by &rook;. Any changes to taints or affinities,
     intentional or unintentional, may affect the data reliability of the
     &ceph; cluster. In order to help protect against this somewhat, deletion
     of nodes by taint or affinity modifications must be confirmed by deleting
     the &rookceph; operator pod and allowing the operator deployment to
     restart the pod.
    </para>
    <para>
     For production clusters, we recommend that <literal>useAllNodes</literal>
     is set to <literal>false</literal> to prevent the &ceph; cluster from
     suffering reduced data reliability unintentionally due to a user mistake.
     When <literal>useAllNodes</literal> is set to <literal>false</literal>,
     &rook; relies on the user to be explicit about when nodes are added to or
     removed from the &ceph; cluster. Nodes are only added to the &ceph;
     cluster if the node is added to the &ceph; cluster resource. Similarly,
     nodes are only removed if the node is removed from the &ceph; cluster
     resource.
    </para>
    <sect4 xml:id="rook-node-updates">
     <title>Node Updates</title>
     <para>
      Nodes can be added and removed over time by updating the cluster CRD, for
      example with the following command:
     </para>
<screen>kubectl -n rook-ceph edit cephcluster rook-ceph</screen>
     <para>
      This will bring up your default text editor and allow you to add and
      remove storage nodes from the cluster. This feature is only available
      when <literal>useAllNodes</literal> has been set to
      <literal>false</literal>.
     </para>
    </sect4>
   </sect3>
   <sect3 xml:id="rook-storage-selection-settings">
    <title>Storage Selection Settings</title>
    <para>
     Below are the settings available, both at the cluster and individual node
     level, for selecting which storage resources will be included in the
     cluster.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>useAllDevices</literal>: <literal>true</literal> or
       <literal>false</literal>, indicating whether all devices found on nodes
       in the cluster should be automatically consumed by OSDs. This is
       <emphasis role="strong">Not recommended</emphasis> unless you have a
       very controlled environment where you will not risk formatting of
       devices with existing data. When <literal>true</literal>, all
       devices/partitions will be used. Is overridden by
       <literal>deviceFilter</literal> if specified.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>deviceFilter</literal>: A regular expression for short kernel
       names of devices (for example, <literal>sda</literal>) that allows
       selection of devices to be consumed by OSDs. If individual devices have
       been specified for a node then this filter will be ignored. For example:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>sdb</literal>: Only selects the <literal>sdb</literal> device
         if found.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>^sd</literal>: Selects all devices starting with
         <literal>sd</literal>.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>^sd[a-d]</literal>: Selects devices starting with
         <literal>sda</literal>, <literal>sdb</literal>,
         <literal>sdc</literal>, and <literal>sdd</literal> if found.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>^s</literal>: Selects all devices that start with
         <literal>s</literal>.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>^[^r]</literal>: Selects all devices that do
         <emphasis>not</emphasis> start with <literal>r</literal>
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>devicePathFilter</literal>: A regular expression for device
       paths (for
       example, <literal>/dev/disk/by-path/pci-0:1:2:3-scsi-1</literal>) that
       allows selection of devices to be consumed by OSDs. If individual
       devices or <literal>deviceFilter</literal> have been specified for a
       node then this filter will be ignored. For example:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>^/dev/sd.</literal>: Selects all devices starting with
         <literal>sd</literal>
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>^/dev/disk/by-path/pci-.*</literal>: Selects all devices
         which are connected to PCI bus
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>devices</literal>: A list of individual device names belonging
       to this node to include in the storage cluster.
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>name</literal>: The name of the device (for example,
         <literal>sda</literal>), or full udev path (such
         as, <literal>/dev/disk/by-id/ata-ST4000DM004-XXXX</literal> - this
         will not change after reboots).
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>config</literal>: Device-specific config settings.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>storageClassDeviceSets</literal>: Explained in
       <xref linkend="rook-storage-class-device-sets"/>.
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
   <sect3 xml:id="rook-storage-class-device-sets">
    <title>Storage Class Device Sets</title>
    <para>
     The following are the settings for Storage Class Device Sets which can be
     configured to create OSDs that are backed by block mode PVs.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>name</literal>: A name for the set.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>count</literal>: The number of devices in the set.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>resources</literal>: The CPU and RAM requests or limits for the
       devices. (Optional)
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>placement</literal>: The placement criteria for the devices.
       (Optional) Default is no placement criteria.
      </para>
      <para>
       The syntax is the same as for
       <xref linkend="rook-placement-configuration-settings"/>. It supports
       <literal>nodeAffinity</literal>, <literal>podAffinity</literal>,
       <literal>podAntiAffinity</literal> and <literal>tolerations</literal>
       keys.
      </para>
      <para>
       We recommend to configure the placement such that the OSDs will be as
       evenly spread across nodes as possible. At a minimum, anti-affinity
       should be added so at least one OSD will be placed on each available
       nodes.
      </para>
      <para>
       However, if there are more OSDs than nodes, this anti-affinity will not
       be effective. Another placement scheme to consider is to add labels to
       the nodes in such a way that the OSDs can be grouped on those nodes,
       create multiple storageClassDeviceSets, and add node affinity to each of
       the device sets that will place the OSDs in those sets of nodes.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>preparePlacement</literal>: The placement criteria for the
       preparation of the OSD devices. Creating OSDs is a two-step process and
       the prepare job may require different placement than the OSD daemons. If
       the <literal>preparePlacement</literal> is not specified, the
       <literal>placement</literal> will instead be applied for consistent
       placement for the OSD prepare jobs and OSD deployments. The
       <literal>preparePlacement</literal> is only useful for
       <literal>portable</literal> OSDs in the device sets. OSDs that are not
       portable will be tied to the host where the OSD prepare job initially
       runs.
      </para>
      <itemizedlist>
       <listitem>
        <para>
         For example, provisioning may require topology spread constraints
         across zones, but the OSD daemons may require constraints across hosts
         within the zones.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>portable</literal>: If <literal>true</literal>, the OSDs will
       be allowed to move between nodes during failover. This requires a
       storage class that supports portability (for
       example, <literal>aws-ebs</literal>, but not the local storage
       provisioner). If <literal>false</literal>, the OSDs will be assigned to
       a node permanently. &rook; will configure &ceph;’s CRUSH map to
       support the portability.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>tuneDeviceClass</literal>: If <literal>true</literal>, because
       the OSD can be on a slow device class, &rook; will adapt to that by
       tuning the OSD process. This will make &ceph; perform better under that
       slow device.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>volumeClaimTemplates</literal>: A list of PVC templates to use
       for provisioning the underlying storage devices.
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>resources.requests.storage</literal>: The desired capacity
         for the underlying storage devices.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>storageClassName</literal>: The StorageClass to provision
         PVCs from. Default would be to use the cluster-default StorageClass.
         This StorageClass should provide a raw block device, multipath device,
         or logical volume. Other types are not supported. If you want to use
         logical volume, please see
         <link xlink:href="ceph-common-issues.md#lvm-metadata-can-be-corrupted-with-osd-on-lv-backed-pvc">known
         issue of OSD on LV-backed PVC</link>
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>volumeMode</literal>: The volume mode to be set for the PVC.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>accessModes</literal>: The access mode for the PVC to be
         bound by OSD.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>schedulerName</literal>: Scheduler name for OSD pod placement.
       (Optional)
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>encrypted</literal>: whether to encrypt all the OSDs in a given
       storageClassDeviceSet
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
<!--  2020-09-23 asettle: consider removing this section as we already detail
ceph-specific configurations elsewhere and upstream.

   <sect3 xml:id="rook-osd-configuration-settings">
      <title>OSD Configuration Settings</title>
      <para>
        The following storage selection settings are specific to Ceph
        and do not apply to other backends. All variables are key-value
        pairs represented as strings.
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <literal>metadataDevice</literal>: Name of a device to use
            for the metadata of OSDs on each node. Performance can be
            improved by using a low latency device (such as SSD or NVMe)
            as the metadata device, while other spinning platter (HDD)
            devices on a node are used to store data. Provisioning will
            fail if the user specifies a
            <literal>metadataDevice</literal> but that device is not
            used as a metadata device by Ceph. Notably,
            <literal>ceph-volume</literal> will not use a device of the
            same device class (HDD, SSD, NVMe) as OSD devices for
            metadata, resulting in this failure.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>storeType</literal>: <literal>bluestore</literal>,
            the underlying storage format to use for each OSD. The
            default is set dynamically to <literal>bluestore</literal>
            for devices and is the only supported format at this point.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>databaseSizeMB</literal>: The size in MB of a
            bluestore database. Include quotes around the size.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>walSizeMB</literal>: The size in MB of a bluestore
            write ahead log (WAL). Include quotes around the size.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>deviceClass</literal>: The
            <link xlink:href="https://ceph.io/community/new-luminous-crush-device-classes/">CRUSH
            device class</link> to use for this selection of storage
            devices. (By default, if a device’s class has not already
            been set, OSDs will automatically set a device’s class to
            either <literal>hdd</literal>, <literal>ssd</literal>, or
            <literal>nvme</literal> based on the hardware properties
            exposed by the Linux kernel.) These storage classes can then
            be used to select the devices backing a storage pool by
            specifying them as the value of
            <link xlink:href="ceph-pool-crd.md#spec">the pool spec’s
            <literal>deviceClass</literal> field</link>.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>osdsPerDevice</literal>**: The number of OSDs to
            create on each device. High performance devices such as NVMe
            can handle running multiple OSDs. If desired, this can be
            overridden for each node and each device.
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>encryptedDevice</literal>**: Encrypt OSD volumes
            using dmcrypt (<quote>true</quote> or <quote>false</quote>).
            By default this option is disabled. See
            <link xlink:href="http://docs.ceph.com/docs/nautilus/ceph-volume/lvm/encryption/">encryption</link>
            for more information on encryption in Ceph.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        ** <emphasis role="strong">NOTE</emphasis>: Depending on the
        Ceph image running in your cluster, OSDs will be configured
        differently. Newer images will configure OSDs with
        <literal>ceph-volume</literal>, which provides support for
        <literal>osdsPerDevice</literal>,
        <literal>encryptedDevice</literal>, as well as other features
        that will be exposed in future &rook; releases. OSDs created prior
        to &rook; v0.9 or with older images of Luminous and Mimic are not
        created with <literal>ceph-volume</literal> and thus would not
        support the same features. For <literal>ceph-volume</literal>,
        the following images are supported:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Luminous 12.2.10 or newer
          </para>
        </listitem>
        <listitem>
          <para>
            Mimic 13.2.3 or newer
          </para>
        </listitem>
        <listitem>
          <para>
            Nautilus
          </para>
        </listitem>
      </itemizedlist>
    </sect3>
-->
   <sect3 xml:id="rook-storage-selection-via-ceph-drive-groups">
    <title>Storage Selection via &ceph; &drvgrps;</title>
    <para>
     &ceph; &drvgrps; allow for specifying highly advanced OSD layouts.  Refer
     to <xref linkend="drive-groups"/> for both general information and
     detailed specification of &drvgrps; with useful examples.
    </para>
     <important>
     <para>
      When managing a &rook;/&ceph; cluster’s OSD layouts with &drvgrps;, the
      <literal>storage</literal> config is mostly ignored.
      <literal>storageClassDeviceSets</literal> can still be used to create
      OSDs on PVC, but &rook; will no longer use <literal>storage</literal>
      configs for creating OSDs on a node’s devices. To avoid confusion, we
      recommend using the <literal>storage</literal> config OR
      <literal>&drvgrps;</literal> and never both. Because
      <literal>storage</literal> and <literal>&drvgrps;</literal> should not be
      used simultaneously, &rook; only supports provisioning OSDs with
      &drvgrps; on new &rookceph; clusters.
     </para>
    </important>
    <para>
     A &drvgrps; is defined by a name, a &ceph; &drvgrps; spec, and a &rook;
     placement * <literal>name</literal>: A name for the &drvgrps;. *
     <literal>spec</literal>: The &ceph; &drvgrps; spec. Some components of the
     spec are treated differently in the context of &rook; as noted below: *
     &rook; overrides &ceph;’s definition of <literal>placement</literal> in
     order to use &rook;’s <literal>placement</literal> below. * &rook;
     overrides &ceph;’s deprecated <literal>host_pattern</literal> in order
     to use &rook;’s <literal>placement</literal> below. * &rook; overrides
     &ceph;’s <literal>service_id</literal> field to be the same as the
     &drvgrps; <literal>name</literal> above. * <literal>placement</literal>:
     The placement criteria for nodes to provision with the &drvgrps;.
     (Optional) Default is no placement criteria, which matches all untainted
     nodes. The syntax is the same as for
     <xref linkend="rook-placement-configuration-settings"/>.
    </para>
   </sect3>
   <sect3 xml:id="rook-annotations-and-labels">
    <title>Annotations and Labels</title>
    <para>
     Annotations and Labels can be specified so that the &rook; components will
     have those annotations / labels added to them.
    </para>
    <para>
     You can set annotations / labels for &rook; components for the list of key
     value pairs:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>all</literal>: Set annotations / labels for all components
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>mgr</literal>: Set annotations / labels for MGRs
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>mon</literal>: Set annotations / labels for MONs
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>osd</literal>: Set annotations / labels for OSDs
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>prepareosd</literal>: Set annotations / labels for OSD Prepare
       Jobs
      </para>
     </listitem>
    </itemizedlist>
    <para>
     When other keys are set, <literal>all</literal> will be merged together
     with the specific component.
    </para>
   </sect3>
   <sect3 xml:id="rook-placement-configuration-settings">
    <title>Placement Configuration Settings</title>
    <para>
     Placement configuration for the cluster services. It includes the
     following keys: <literal>mgr</literal>, <literal>mon</literal>,
     <literal>osd</literal>, <literal>cleanup</literal>, and
     <literal>all</literal>. Each service will have its placement configuration
     generated by merging the generic configuration under
     <literal>all</literal> with the most specific one (which will override any
     attributes).
    </para>
    <note>
     <para>
      Placement of OSD pods is controlled using the
      <xref linkend="rook-storage-class-device-sets"/>, not the general
      <literal>placement</literal> configuration.
     </para>
    </note>
    <para>
     A placement configuration is specified (according to the &kube; PodSpec)
     as:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>nodeAffinity</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>podAffinity</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>podAntiAffinity</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>tolerations</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>topologySpreadConstraints</literal>
      </para>
     </listitem>
    </itemizedlist>
    <para>
     If you use <literal>labelSelector</literal> for OSD pods, you must write
     two rules both for <literal>rook-ceph-osd</literal> and
     <literal>rook-ceph-osd-prepare</literal>.
    </para>
    <para>
     The &rook; &ceph; operator creates a job called
     <literal>rook-ceph-detect-version</literal> to detect the full &ceph;
     version used by the given <literal>cephVersion.image</literal>. The
     placement from the MON section is used for the job except for the
     <literal>PodAntiAffinity</literal> field.
    </para>
   </sect3>
   <sect3 xml:id="rook-cluster-wide-resources-configuration-settings">
    <title>Cluster-wide Resources Configuration Settings</title>
    <para>
     Resources should be specified so that the &rook; components are handled
     after &kube; Pod Quality of Service classes. This allows to keep &rook;
     components running when for example a node runs out of memory and the
     &rook; components are not killed depending on their Quality of Service
     class.
    </para>
    <para>
     You can set resource requests/limits for &rook; components through the
     <xref linkend="rook-resource-requirementslimits"/> structure in the
     following keys:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>mgr</literal>: Set resource requests/limits for MGRs.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>mon</literal>: Set resource requests/limits for MONs.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>osd</literal>: Set resource requests/limits for OSDs.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>prepareosd</literal>: Set resource requests/limits for OSD
       prepare job.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>crashcollector</literal>: Set resource requests and limits for
       crash. This pod runs wherever there is a &ceph; pod running. It scrapes
       for &ceph; daemon core dumps and sends them to the &ceph; manager crash
       module so that core dumps are centralized and can be easily
       listed/accessed.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>cleanup</literal>: Set resource requests and limits for cleanup
       job, responsible for wiping cluster’s data after uninstall.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     In order to provide the best possible experience running &ceph; in
     containers, &rook; internally recommends minimum memory limits if resource
     limits are passed. If a user configures a limit or request value that is
     too low, &rook; will still run the pod(s) and print a warning to the
     operator log.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>mon</literal>: 1024MB
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>mgr</literal>: 512MB
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>osd</literal>: 2048MB
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>mds</literal>: 4096MB
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>prepareosd</literal>: 50MB
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>crashcollector</literal>: 60MB
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
   <sect3 xml:id="rook-resource-requirementslimits">
    <title>Resource Requirements and Limits</title>
    <itemizedlist>
     <listitem>
      <para>
       <literal>requests</literal>: Requests for CPU or memory.
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>cpu</literal>: Request for CPU (example: one CPU core
         <literal>1</literal>, 50% of one CPU core <literal>500m</literal>).
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>memory</literal>: Limit for Memory (example: one gigabyte of
         memory <literal>1Gi</literal>, half a gigabyte of memory
         <literal>512Mi</literal>).
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>limits</literal>: Limits for CPU or memory.
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>cpu</literal>: Limit for CPU (example: one CPU core
         <literal>1</literal>, 50% of one CPU core <literal>500m</literal>).
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>memory</literal>: Limit for Memory (example: one gigabyte of
         memory <literal>1Gi</literal>, half a gigabyte of memory
         <literal>512Mi</literal>).
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </itemizedlist>
   </sect3>
   <sect3 xml:id="rook-priority-class-names-configuration-settings">
    <title>Priority Class Names Configuration Settings</title>
    <para>
     Priority class names can be specified so that the &rook; components will
     have those priority class names added to them.
    </para>
    <para>
     You can set priority class names for &rook; components for the list of key
     value pairs:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>all</literal>: Set priority class names for MGRs, MONs, OSDs.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>mgr</literal>: Set priority class names for MGRs.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>mon</literal>: Set priority class names for MONs.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>osd</literal>: Set priority class names for OSDs.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     The specific component keys will act as overrides to
     <literal>all</literal>.
    </para>
   </sect3>
   <sect3 xml:id="rook-health-settings">
    <title>Health Settings</title>
    <para>
     &rookceph; will monitor the state of the CephCluster on various components
     by default. The following CRD settings are available:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>healthCheck</literal>: main &ceph; cluster health monitoring
       section
      </para>
     </listitem>
    </itemizedlist>
    <para>
     Currently three health checks are implemented:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>mon</literal>: health check on the &ceph; monitors, basically
       check whether monitors are members of the quorum. If after a certain
       timeout a given monitor has not joined the quorum back it will be failed
       over and replace by a new monitor.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>osd</literal>: health check on the &ceph; osds
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>status</literal>: &ceph; health status check, periodically
       check the &ceph; health state and reflects it in the CephCluster CR
       status field.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     The liveness probe of each daemon can also be controlled via
     <literal>livenessProbe</literal>, the setting is valid for
     <literal>mon</literal>, <literal>mgr</literal> and <literal>osd</literal>.
     Here is a complete example for both <literal>daemonHealth</literal> and
     <literal>livenessProbe</literal>:
    </para>
<screen>
healthCheck:
  daemonHealth:
    mon:
      disabled: false
      interval: 45s
      timeout: 600s
    osd:
      disabled: false
      interval: 60s
    status:
      disabled: false
  livenessProbe:
    mon:
      disabled: false
    mgr:
      disabled: false
    osd:
      disabled: false
</screen>
    <para>
     You can change the <literal>mgr</literal> probe by applying the following:
    </para>
<screen>
healthCheck:
  livenessProbe:
    mgr:
      disabled: false
      probe:
        httpGet:
          path: /
          port: 9283
        initialDelaySeconds: 3
        periodSeconds: 3
</screen>
    <para>
     Changing the liveness probe is an advanced operation and should rarely be
     necessary. If you want to change these settings, start with the probe spec
     &rook; generates by default and then modify the desired settings.
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="rook-samples">
   <title>Samples</title>
   <para>
    Here are several samples for configuring &ceph; clusters. Each of the
    samples must also include the namespace and corresponding access granted
    for management by the &ceph; operator. See the common cluster resources
    below.
   </para>
   <sect3 xml:id="rook-storage-configuration-all-devices">
    <title>Storage Configuration: All Devices</title>
<screen>
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: true
  dashboard:
    enabled: true
  # cluster level storage configuration and selection
  storage:
    useAllNodes: true
    useAllDevices: true
    deviceFilter:
    config:
      metadataDevice:
      databaseSizeMB: &quot;1024&quot; # this value can be removed for environments with normal sized disks (100 GB or larger)
      journalSizeMB: &quot;1024&quot;  # this value can be removed for environments with normal sized disks (20 GB or larger)
      osdsPerDevice: &quot;1&quot;
</screen>
   </sect3>
   <sect3 xml:id="rook-storage-configuration-specific-devices">
    <title>Storage Configuration: Specific devices</title>
    <para>
     Individual nodes and their config can be specified so that only the named
     nodes below will be used as storage resources. Each node’s
     <quote>name</quote> field should match their
     <quote>kubernetes.io/hostname</quote> label.
    </para>
<screen>
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: true
  dashboard:
    enabled: true
  # cluster level storage configuration and selection
  storage:
    useAllNodes: false
    useAllDevices: false
    deviceFilter:
    config:
      metadataDevice:
      databaseSizeMB: &quot;1024&quot; # this value can be removed for environments with normal sized disks (100 GB or larger)
    nodes:
    - name: &quot;172.17.4.201&quot;
      devices:             # specific devices to use for storage can be specified for each node
      - name: &quot;sdb&quot; # Whole storage device
      - name: &quot;sdc1&quot; # One specific partition. Should not have a file system on it.
      - name: &quot;/dev/disk/by-id/ata-ST4000DM004-XXXX&quot; # both device name and explicit udev links are supported
      config:         # configuration can be specified at the node level which overrides the cluster level config
        storeType: bluestore
    - name: &quot;172.17.4.301&quot;
      deviceFilter: &quot;^sd.&quot;
</screen>
   </sect3>
   <sect3 xml:id="rook-node-affinity">
    <title>Node Affinity</title>
    <para>
     To control where various services will be scheduled by &kube;, use the
     placement configuration sections below. The example under
     <quote>all</quote> would have all services scheduled on &kube; nodes
     labeled with <quote>role=storage-node</quote> and tolerate taints with a
     key of <quote>storage-node</quote>.
    </para>
<screen>
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: true
  # enable the &ceph; dashboard for viewing cluster status
  dashboard:
    enabled: true
  placement:
    all:
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: role
              operator: In
              values:
              - storage-node
      tolerations:
      - key: storage-node
        operator: Exists
    mgr:
      nodeAffinity:
      tolerations:
    mon:
      nodeAffinity:
      tolerations:
    osd:
      nodeAffinity:
      tolerations:
</screen>
   </sect3>
   <sect3 xml:id="rook-resource-requestslimits">
    <title>Resource Requests and Limits</title>
    <para>
     To control how many resources the &rook; components can request/use, you
     can set requests and limits in &kube; for them. You can override these
     requests and limits for OSDs per node when using <literal>useAllNodes:
     false</literal> in the <literal>node</literal> item in the
     <literal>nodes</literal> list.
    </para>
    <warning>
     <para>
      Before setting resource requests/limits, review the &ceph; documentation
      for hardware recommendations for each component.
     </para>
    </warning>
<screen>
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: true
  # enable the &ceph; dashboard for viewing cluster status
  dashboard:
    enabled: true
  # cluster level resource requests/limits configuration
  resources:
  storage:
    useAllNodes: false
    nodes:
    - name: &quot;172.17.4.201&quot;
      resources:
        limits:
          cpu: &quot;2&quot;
          memory: &quot;4096Mi&quot;
        requests:
          cpu: &quot;2&quot;
          memory: &quot;4096Mi&quot;
</screen>
   </sect3>
   <sect3 xml:id="rook-osd-topology">
    <title>OSD Topology</title>
    <para>
     The topology of the cluster is important in production environments where
     you want your data spread across failure domains. The topology can be
     controlled by adding labels to the nodes. When the labels are found on a
     node at first OSD deployment, &rook; will add them to the desired level in
     the CRUSH map.
    </para>
    <para>
     The complete list of labels in hierarchy order from highest to lowest is:
    </para>
<screen>
topology.kubernetes.io/region
topology.kubernetes.io/zone
topology.rook.io/datacenter
topology.rook.io/room
topology.rook.io/pod
topology.rook.io/pdu
topology.rook.io/row
topology.rook.io/rack
topology.rook.io/chassis
</screen>
    <para>
     For example, if the following labels were added to a node:
    </para>
<screen>kubectl label node mynode topology.kubernetes.io/zone=zone1
kubectl label node mynode topology.rook.io/rack=rack1
</screen>
    <note>
     <para>
      For versions previous to K8s 1.17, use the topology key:
      <literal>failure-domain.beta.kubernetes.io/zone</literal> or region.
     </para>
    </note>
    <para>
     These labels would result in the following hierarchy for OSDs on that node
     (this command can be run in the &rook; toolbox):
    </para>
<screen>
[root@mynode /]# ceph osd tree
ID CLASS WEIGHT  TYPE NAME                 STATUS REWEIGHT PRI-AFF
-1       0.01358 root default
-5       0.01358     zone zone1
-4       0.01358         rack rack1
-3       0.01358             host mynode
 0   hdd 0.00679                 osd.0         up  1.00000 1.00000
 1   hdd 0.00679                 osd.1         up  1.00000 1.00000
</screen>
    <para>
     &ceph; requires unique names at every level in the hierarchy (CRUSH map).
     For example, you cannot have two racks with the same name that are in
     different zones. Racks in different zones must be named uniquely.
    </para>
    <para>
     Note that the <literal>host</literal> is added automatically to the
     hierarchy by &rook;. The host cannot be specified with a topology label.
     All topology labels are optional.
    </para>
    <tip>
     <para>
      When setting the node labels prior to <literal>CephCluster</literal>
      creation, these settings take immediate effect. However, applying this to
      an already deployed <literal>CephCluster</literal> requires removing each
      node from the cluster first and then re-adding it with new configuration
      to take effect. Do this node by node to keep your data safe! Check the
      result with <literal>ceph osd tree</literal> from the
      <xref linkend ="admin-caasp-cephtoolbox"/>. The OSD tree should display
      the hierarchy for the nodes that already have been re-added.
     </para>
    </tip>
    <para>
     To utilize the <literal>failureDomain</literal> based on the node labels,
     specify the corresponding option in the <literal>CephBlockPool</literal>.
    </para>
<screen>
apiVersion: ceph.rook.io/v1
kind: CephBlockPool
metadata:
  name: replicapool
  namespace: rook-ceph
spec:
  failureDomain: rack  # this matches the topology labels on nodes
  replicated:
    size: 3
</screen>
    <para>
     This configuration will split the replication of volumes across unique
     racks in the data center setup.
    </para>
   </sect3>
   <sect3 xml:id="rook-using-pvc-storage-for-monitors">
    <title>Using PVC Storage for Monitors</title>
    <para>
     In the CRD specification below three monitors are created each using a
     10Gi PVC created by &rook; using the <literal>local-storage</literal>
     storage class.
    </para>
<screen>
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  cephVersion:
    image: ceph/ceph:v15.2.4
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: false
    volumeClaimTemplate:
      spec:
        storageClassName: local-storage
        resources:
          requests:
            storage: 10Gi
  dashboard:
    enabled: true
  storage:
    useAllNodes: true
    useAllDevices: true
    deviceFilter:
    config:
      metadataDevice:
      databaseSizeMB: &quot;1024&quot; # this value can be removed for environments with normal sized disks (100 GB or larger)
      journalSizeMB: &quot;1024&quot;  # this value can be removed for environments with normal sized disks (20 GB or larger)
      osdsPerDevice: &quot;1&quot;
</screen>
   </sect3>
   <sect3 xml:id="rook-using-storageclassdevicesets">
    <title>Using StorageClassDeviceSets</title>
    <para>
     In the CRD specification below, 3 OSDs (having specific placement and
     resource values) and 3 MONs with each using a 10Gi PVC, are created by
     &rook; using the <literal>local-storage</literal> storage class.
    </para>
<screen>
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph
spec:
  dataDirHostPath: /var/lib/rook
  mon:
    count: 3
    allowMultiplePerNode: false
    volumeClaimTemplate:
      spec:
        storageClassName: local-storage
        resources:
          requests:
            storage: 10Gi
  cephVersion:
    image: ceph/ceph:v15.2.4
    allowUnsupported: false
  dashboard:
    enabled: true
  network:
    hostNetwork: false
  storage:
    storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      resources:
        limits:
          cpu: &quot;500m&quot;
          memory: &quot;4Gi&quot;
        requests:
          cpu: &quot;500m&quot;
          memory: &quot;4Gi&quot;
      placement:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: &quot;rook.io/cluster&quot;
                  operator: In
                  values:
                    - cluster1
                topologyKey: &quot;topology.kubernetes.io/zone&quot;
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          storageClassName: local-storage
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</screen>
   </sect3>
   <sect3 xml:id="rook-dedicated-metadata-and-wal-device-for-osd-on-pvc">
    <title>Dedicated Metadata and Wal Device for OSD on PVC</title>
    <para>
     In the simplest case, &ceph; OSD &bluestore; consumes a single (primary)
     storage device. &bluestore; is the engine used by the OSD to store data.
    </para>
    <para>
     The storage device is normally used as a whole, occupying the full device
     that is managed directly by &bluestore;. It is also possible to deploy
     &bluestore; across additional devices such as a DB device. This device can
     be used for storing &bluestore;’s internal metadata. &bluestore; (or
     rather, the embedded RocksDB) will put as much metadata as it can on the
     DB device to improve performance. If the DB device fills up, metadata will
     spill back onto the primary device (where it would have been otherwise).
     Again, it is only helpful to provision a DB device if it is faster than
     the primary device.
    </para>
    <para>
     You can have multiple <literal>volumeClaimTemplates</literal> where each
     might either represent a device or a metadata device. So just taking the
     <literal>storage</literal> section this will give something like:
    </para>
<screen>
  storage:
   storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)
          storageClassName: gp2
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
      - metadata:
          name: metadata
        spec:
          resources:
            requests:
              # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing
              storage: 5Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)
          storageClassName: io1
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</screen>
    <note>
     <para>
      &rook; only supports three naming convention for a given template:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        <emphasis>data</emphasis>: represents the main OSD block device, where
        your data is being stored.
       </para>
      </listitem>
      <listitem>
       <para>
        <emphasis>metadata:</emphasis> represents the metadata (including
        block.db and block.wal) device used to store the &ceph; Bluestore
        database for an OSD.
       </para>
      </listitem>
      <listitem>
       <para>
        <quote>wal</quote>: represents the block.wal device used to store the
        &ceph; &bluestore; database for an OSD. If this device is set,
        <quote>metadata</quote> device will refer specifically to block.db
        device. It is recommended to use a faster storage class for the
        metadata or wal device, with a slower device for the data. Otherwise,
        having a separate metadata device will not improve the performance.
       </para>
      </listitem>
     </itemizedlist>
    </note>
    <para>
     The &bluestore; partition has the following reference combinations
     supported by the ceph-volume utility:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       A single <quote>data</quote> device.
      </para>
<screen>
  storage:
    storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)
          storageClassName: gp2
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</screen>
     </listitem>
     <listitem>
      <para>
       A <emphasis>data</emphasis> device and a <emphasis>metadata</emphasis>
       device.
      </para>
<screen>
  storage:
    storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)
          storageClassName: gp2
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
      - metadata:
          name: metadata
        spec:
          resources:
            requests:
              # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing
              storage: 5Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)
          storageClassName: io1
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</screen>
     </listitem>
     <listitem>
      <para>
       A <emphasis>data</emphasis> device and a <emphasis>WAL</emphasis>
       device. A WAL device can be used for &bluestore;’s internal journal or
       write-ahead log (block.wal), it is only useful to use a WAL device if
       the device is faster than the primary device (data device). There is no
       separate <emphasis>metadata</emphasis> device in this case, the data of
       main OSD block and block.db located in <emphasis>data</emphasis> device.
      </para>
<screen>
  storage:
    storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)
          storageClassName: gp2
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
      - metadata:
          name: wal
        spec:
          resources:
            requests:
              # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing
              storage: 5Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)
          storageClassName: io1
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</screen>
     </listitem>
     <listitem>
      <para>
       A <emphasis>data</emphasis> device, a <emphasis>metadata</emphasis>
       device and a <emphasis>wal</emphasis> device.
      </para>
<screen>
  storage:
    storageClassDeviceSets:
    - name: set1
      count: 3
      portable: false
      tuneDeviceClass: false
      volumeClaimTemplates:
      - metadata:
          name: data
        spec:
          resources:
            requests:
              storage: 10Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, gp2)
          storageClassName: gp2
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
      - metadata:
          name: metadata
        spec:
          resources:
            requests:
              # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing
              storage: 5Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)
          storageClassName: io1
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
      - metadata:
          name: wal
        spec:
          resources:
            requests:
              # Find the right size https://docs.ceph.com/docs/master/rados/configuration/bluestore-config-ref/#sizing
              storage: 5Gi
          # IMPORTANT: Change the storage class depending on your environment (e.g. local-storage, io1)
          storageClassName: io1
          volumeMode: Block
          accessModes:
            - ReadWriteOnce
</screen>
     </listitem>
    </itemizedlist>
    <para>
     With the present configuration, each OSD will have its main block
     allocated a 10GB device as well a 5GB device to act as a &bluestore;
     database.
    </para>
   </sect3>
   <sect3 xml:id="rook-external-cluster">
    <title>External cluster</title>
    <para>
     The minimum supported &ceph; version for the External Cluster is Luminous
     12.2.x.
    </para>
    <para>
     The features available from the external cluster will vary depending on
     the version of Ceph. The following table shows the minimum version of Ceph
     for some of the features:
    </para>
    <informaltable>
     <tgroup cols="2">
      <colspec align="left" />
      <colspec align="left" />
      <thead>
       <row>
        <entry>FEATURE</entry>
        <entry>CEPH VERSION</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>Dynamic provisioning RBD</entry>
        <entry>12.2.X</entry>
       </row>
       <row>
        <entry>Configure extra CRDs (object, file, nfs)<footnote>
          <para>
           Configure an object store, shared file system, or NFS resources in
           the local cluster to connect to the external &ceph; cluster
          </para>
         </footnote>
        </entry>
        <entry>13.2.3</entry>
       </row>
       <row>
        <entry>Dynamic provisioning &cephfs;</entry>
        <entry>14.2.3</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
    <sect4 xml:id="rook-pre-requisites">
     <title>Pre-requisites</title>
     <para>
      In order to configure an external &ceph; cluster with &rook;, we need to
      inject some information in order to connect to that cluster. You can use
      the
      <filename>cluster/examples/kubernetes/ceph/import-external-cluster.sh</filename>
      script to achieve that. The script will look for the following populated
      environment variables:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        <literal>NAMESPACE</literal>: the namespace where the configmap and
        secrets should be injected
       </para>
      </listitem>
      <listitem>
       <para>
        <literal>ROOK_EXTERNAL_FSID</literal>: the fsid of the external &ceph;
        cluster, it can be retrieved via the <literal>ceph fsid</literal>
        command
       </para>
      </listitem>
      <listitem>
       <para>
        <literal>ROOK_EXTERNAL_CEPH_MON_DATA</literal>: is a common-separated
        list of running monitors IP address along with their ports. For
        example,
        <literal>a=172.17.0.4:6789,b=172.17.0.5:6789,c=172.17.0.6:6789</literal>.
        You do not need to specify all the monitors, you can simply pass one
        and the operator will discover the rest. The name of the monitor is the
        name that appears in the <command>ceph status</command> output.
       </para>
      </listitem>
     </itemizedlist>
     <para>
      Now, we need to give &rook; a key to connect to the cluster in order to
      perform various operations such as health cluster check, CSI keys
      management etc. We recommend generating keys with minimal access so the
      admin key does not need to be used by the external cluster. In this case,
      the admin key is only needed to generate the keys that will be used by
      the external cluster. But if the admin key is to be used by the external
      cluster, set the following variable:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        <literal>ROOK_EXTERNAL_ADMIN_SECRET</literal>:
        <emphasis role="strong">OPTIONAL:</emphasis> the external &ceph;
        cluster admin secret key, it can be retrieved via the <literal>ceph
        auth get-key client.admin</literal> command.
       </para>
      </listitem>
     </itemizedlist>
     <note>
      <para>
       <emphasis role="strong">WARNING</emphasis>: If you plan to create CRs
       (pool, rgw, mds, nfs) in the external cluster, you
       <emphasis role="strong">MUST</emphasis> inject the client.admin keyring
       as well as injecting <literal>cluster-external-management.yaml</literal>
      </para>
     </note>
     <para>
      <emphasis role="strong">Example</emphasis>:
     </para>
<screen>
export NAMESPACE=rook-ceph-external
export ROOK_EXTERNAL_FSID=3240b4aa-ddbc-42ee-98ba-4ea7b2a61514
export ROOK_EXTERNAL_CEPH_MON_DATA=a=172.17.0.4:6789
export ROOK_EXTERNAL_ADMIN_SECRET=AQC6Ylxdja+NDBAAB7qy9MEAr4VLLq4dCIvxtg==
</screen>
     <para>
      If the &ceph; admin key is not provided, the following script needs to be
      executed on a machine that can connect to the &ceph; cluster using the
      &ceph; admin key. On that machine, run
      <filename>cluster/examples/kubernetes/ceph/create-external-cluster-resources.sh</filename>.
      The script will automatically create users and keys with the lowest
      possible privileges and populate the necessary environment variables for
      <filename>cluster/examples/kubernetes/ceph/import-external-cluster.sh</filename>
      to work correctly.
     </para>
     <para>
      Finally, execute the script like this from a machine that has access to
      your &kube; cluster:
     </para>
<screen>bash cluster/examples/kubernetes/ceph/import-external-cluster.sh</screen>
    </sect4>
    <sect4 xml:id="rook-cephcluster-example-consumer">
     <title>CephCluster example (consumer)</title>
     <para>
      Assuming the above section has successfully completed, here is a CR
      example:
     </para>
<screen>
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph-external
  namespace: rook-ceph-external
spec:
  external:
    enable: true
  crashCollector:
    disable: true
  # optionally, the ceph-mgr IP address can be pass to gather metric from the prometheus exporter
  #monitoring:
    #enabled: true
    #rulesNamespace: rook-ceph
    #externalMgrEndpoints:
      #- ip: 192.168.39.182
</screen>
     <para>
      Choose the namespace carefully, if you have an existing cluster managed
      by &rook;, you have likely already injected
      <filename>common.yaml</filename>. Additionally, you need to inject
      <filename>common-external.yaml</filename> too.
     </para>
     <para>
      You can now create it like this:
     </para>
<screen>kubectl create -f cluster/examples/kubernetes/ceph/cluster-external.yaml</screen>
     <para>
      If the previous section has not been completed, the &rook; Operator will
      still acknowledge the CR creation but will wait forever to receive
      connection information.
     </para>
     <warning>
      <para>
       If no cluster is managed by the current &rook; Operator, you need to
       inject <filename>common.yaml</filename>, then modify
       <filename>cluster-external.yaml</filename> and specify
       <filename>rook-ceph</filename> as <filename>namespace</filename>.
      </para>
     </warning>
     <para>
      If this is successful you will see the CephCluster status as connected.
     </para>
<screen>kubectl get CephCluster -n rook-ceph-external
NAME                 DATADIRHOSTPATH   MONCOUNT   AGE    STATE       HEALTH
rook-ceph-external   /var/lib/rook                162m   Connected   HEALTH_OK
</screen>
     <para>
      Before you create a StorageClass with this cluster you will need to
      create a pool in your external &ceph; Cluster.
     </para>
    </sect4>
    <sect4 xml:id="rook-example-storageclass-based-on-external-ceph-pool">
     <title>Example StorageClass Based on External &ceph; Pool</title>
     <para>
      In the cluster, list the pools available:
     </para>
<screen>rados df
POOL_NAME     USED OBJECTS CLONES COPIES MISSING_ON_PRIMARY UNFOUND DEGRADED RD_OPS  RD WR_OPS  WR USED COMPR UNDER COMPR
replicated_2g  0 B       0      0      0                  0       0        0      0 0 B      0 0 B        0 B         0 B
</screen>
     <para>
      Here is an example StorageClass configuration that uses the
      <literal>replicated_2g</literal> pool from the external cluster:
     </para>
<screen>cat &lt;&lt; EOF | kubectl apply -f -
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
   name: rook-ceph-block-ext
# Change &quot;rook-ceph&quot; provisioner prefix to match the operator namespace if needed
provisioner: rook-ceph.rbd.csi.ceph.com
parameters:
    # clusterID is the namespace where the rook cluster is running
    clusterID: rook-ceph-external
    # Ceph pool into which the RBD image shall be created
    pool: replicated_2g

    # RBD image format. Defaults to &quot;2&quot;.
    imageFormat: &quot;2&quot;

    # RBD image features. Available for imageFormat: &quot;2&quot;. CSI RBD currently supports only `layering` feature.
    imageFeatures: layering

    # The secrets contain Ceph admin credentials.
    csi.storage.k8s.io/provisioner-secret-name: rook-csi-rbd-provisioner
    csi.storage.k8s.io/provisioner-secret-namespace: rook-ceph-external
    csi.storage.k8s.io/controller-expand-secret-name: rook-csi-rbd-provisioner
    csi.storage.k8s.io/controller-expand-secret-namespace: rook-ceph-external
    csi.storage.k8s.io/node-stage-secret-name: rook-csi-rbd-node
    csi.storage.k8s.io/node-stage-secret-namespace: rook-ceph-external

    # Specify the filesystem type of the volume. If not specified, csi-provisioner
    # will set default as `ext4`. Note that `xfs` is not recommended due to potential deadlock
    # in hyperconverged settings where the volume is mounted on the same node as the osds.
    csi.storage.k8s.io/fstype: ext4

# Delete the rbd volume when a PVC is deleted
reclaimPolicy: Delete
allowVolumeExpansion: true
EOF
</screen>
     <para>
      You can now create a persistent volume based on this StorageClass.
     </para>
    </sect4>
    <sect4 xml:id="rook-cephcluster-example-management">
     <title>CephCluster example (management)</title>
     <para>
      The following CephCluster CR represents a cluster that will perform
      management tasks on the external cluster. It will not only act as a
      consumer but will also allow the deployment of other CRDs such as
      CephFilesystem or CephObjectStore. As mentioned above, you would need to
      inject the admin keyring for that.
     </para>
     <para>
      The corresponding YAML example:
     </para>
<screen>
apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph-external
  namespace: rook-ceph-external
spec:
  external:
    enable: true
  dataDirHostPath: /var/lib/rook
  cephVersion:
    image: ceph/ceph:v15.2.4 # Should match external cluster version
</screen>
    </sect4>
   </sect3>
   <sect3 xml:id="rook-cleanup-policy">
    <title>Cleanup Policy</title>
    <para>
     &rook; has the ability to cleanup resources and data that were deployed
     when a <command>delete cephcluster</command> command is issued. The policy
     represents the confirmation that cluster data should be forcibly deleted.
     The <literal>cleanupPolicy</literal> should only be added to the cluster
     when the cluster is about to be deleted. After the
     <literal>confirmation</literal> field of the cleanup policy is set, &rook;
     will stop configuring the cluster as if the cluster is about to be
     destroyed in order to prevent these settings from being deployed
     unintentionally. The <literal>cleanupPolicy</literal> CR settings has
     different fields:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>confirmation</literal>: Only an empty string and
       <literal>yes-really-destroy-data</literal> are valid values for this
       field. If an empty string is set, &rook; will only remove &ceph;’s
       metadata. A re-installation will not be possible unless the hosts are
       cleaned first. If <literal>yes-really-destroy-data</literal> the
       operator will automatically delete data on the hostpath of cluster nodes
       and clean devices with OSDs. The cluster can then be re-installed if
       desired with no further steps.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>sanitizeDisks</literal>: sanitizeDisks represents advanced
       settings that can be used to sanitize drives. This field only affects if
       <literal>confirmation</literal> is set to
       <literal>yes-really-destroy-data</literal>. However, the administrator
       might want to sanitize the drives in more depth with the following
       flags:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>method</literal>: indicates whether the entire disk should be
         sanitized or &ceph; metadata only. Possible choices are
         <quote>quick</quote> (default) or <quote>complete</quote>.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>dataSource</literal>: indicate where to get random bytes from
         to write on the disk. Possible choices are <quote>zero</quote>
         (default) or <quote>random</quote>. Using random sources will consume
         entropy from the system and will take much more time then the zero
         source.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>iteration</literal>: overwrite N times instead of the default
         (1). Takes an integer value.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>allowUninstallWithVolumes</literal>: If set to true, then the
       cephCluster deletion does not wait for the PVCs to be deleted. Default
       is <literal>false</literal>.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     To automate activation of the cleanup, you can use the following command:
    </para>
    <warning>
     <para>
      Data will be permanently deleted.
     </para>
    </warning>
<screen>
kubectl -n rook-ceph patch cephcluster rook-ceph --type merge \
 -p '{&quot;spec&quot;:{&quot;cleanupPolicy&quot;:{&quot;confirmation&quot;:&quot;yes-really-destroy-data&quot;}}}'
</screen>
    <para>
     Nothing will happen until the deletion of the CR is requested, so this can
     still be reverted. However, all new configuration by the operator will be
     blocked with this cleanup policy enabled.
    </para>
    <para>
     &rook; waits for the deletion of PVs provisioned using the CephCluster
     before proceeding to delete the CephCluster. To force deletion of the
     CephCluster without waiting for the PVs to be deleted, you can set the
     <literal>allowUninstallWithVolumes</literal> to <literal>true</literal>
     under <filename>spec.CleanupPolicy</filename>.
    </para>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="rook-ceph-block-pool-crd">
  <title>&ceph; Block Pool CRD</title>

  <para>
   &rook; allows creation and customization of storage pools through the custom
   resource definitions (CRDs). The following settings are available for pools.
  </para>

  <sect2 xml:id="rook-samples-rep">
   <title>Samples</title>
   <sect3 xml:id="replicated">
    <title>Replicated</title>
    <para>
     For optimal performance, while also adding redundancy, this sample will
     configure &ceph; to make three full copies of the data on multiple nodes.
    </para>
    <note>
     <para>
      This sample requires at least one OSD per node, with each OSD located on
      3 different nodes.
     </para>
    </note>
    <para>
     Each OSD must be located on a different node, because the
     <literal>failureDomain</literal> is set to <literal>host</literal> and the
     <literal>replicated.size</literal> is set to three.
    </para>
<screen>
apiVersion: ceph.rook.io/v1
kind: CephBlockPool
metadata:
  name: replicapool
  namespace: rook-ceph
spec:
  failureDomain: host
  replicated:
    size: 3
  deviceClass: hdd
</screen>
   </sect3>
   <sect3 xml:id="rook-erasure-coded-sample">
    <title>Erasure Coded</title>
    <para>
     This sample will lower the overall storage capacity requirement, while
     also adding redundancy by using <xref linkend="rook-erasure-coding"/>.
    </para>
    <note>
     <para>
      This sample requires at least 3 &bluestore; OSDs.
     </para>
    </note>
    <para>
     The OSDs can be located on a single &ceph; node or spread across multiple
     nodes, because the <literal>failureDomain</literal> is set to
     <literal>osd</literal> and the <literal>erasureCoded</literal> chunk
     settings require at least three different OSDs (two
     <literal>dataChunks</literal> + one <literal>codingChunks</literal>).
    </para>
<screen>
apiVersion: ceph.rook.io/v1
kind: CephBlockPool
metadata:
  name: ecpool
  namespace: rook-ceph
spec:
  failureDomain: osd
  erasureCoded:
    dataChunks: 2
    codingChunks: 1
  deviceClass: hdd
</screen>
    <para>
     High performance applications typically will not use erasure coding due to
     the performance overhead of creating and distributing the chunks in the
     cluster.
    </para>
    <para>
     When creating an erasure-coded pool, we recommend creating the pool when
     you have &bluestore; OSDs in your cluster.
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="rook-pool-settings">
   <title>Pool Settings</title>
   <sect3 xml:id="rook-metadata-pool-settings">
    <title>Metadata</title>
    <itemizedlist>
     <listitem>
      <para>
       <literal>name</literal>: The name of the pool to create.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>namespace</literal>: The namespace of the &rook; cluster where
       the pool is created.
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
   <sect3 xml:id="rook-spec">
    <title>Spec</title>
    <itemizedlist>
     <listitem>
      <para>
       <literal>replicated</literal>: Settings for a replicated pool. If
       specified, <literal>erasureCoded</literal> settings must not be
       specified.
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>size</literal>: The desired number of copies to make of the
         data in the pool.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>requireSafeReplicaSize</literal>: set to false if you want to
         create a pool with size one, setting pool size one could lead to data
         loss without recovery.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>erasureCoded</literal>: Settings for an erasure-coded pool. If
       specified, <literal>replicated</literal> settings must not be specified.
       See below for more details on <xref linkend="rook-erasure-coding"/>.
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>dataChunks</literal>: Number of chunks to divide the original
         object into
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>codingChunks</literal>: Number of coding chunks to generate
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <literal>failureDomain</literal>: The failure domain across which the
       data will be spread. This can be set to a value of either
       <literal>osd</literal> or <literal>host</literal>, with
       <literal>host</literal> being the default setting. A failure domain can
       also be set to a different type (for example, <literal>rack</literal>),
       if it is added as a <literal>location</literal> Storage Selection
       Settings. If a replicated pool of size three is configured and the
       <literal>failureDomain</literal> is set to <literal>host</literal>, all
       three copies of the replicated data will be placed on OSDs located on
       three different &ceph; hosts. This case is guaranteed to tolerate a
       failure of two hosts without a loss of data. Similarly, a failure domain
       set to <literal>osd</literal>, can tolerate a loss of two OSD devices.
      </para>
      <para>
       If erasure coding is used, the data and coding chunks are spread across
       the configured failure domain.
      </para>
      <note>
       <para>
        Neither &rook;, nor &ceph;, prevent the creation of a cluster where the
        replicated data (or erasure coded chunks) can be written safely. By
        design, &ceph; will delay checking for suitable OSDs until a write
        request is made and this write can hang if there are not sufficient
        OSDs to satisfy the request.
       </para>
      </note>
     </listitem>
     <listitem>
      <para>
       <literal>deviceClass</literal>: Sets up the CRUSH rule for the pool to
       distribute data only on the specified device class. If left empty or
       unspecified, the pool will use the cluster’s default CRUSH root, which
       usually distributes data over all OSDs, regardless of their class.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>crushRoot</literal>: The root in the crush map to be used by
       the pool. If left empty or unspecified, the default root will be used.
       Creating a crush hierarchy for the OSDs currently requires the &rook;
       toolbox to run the &ceph; tools.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>enableRBDStats</literal>: Enables collecting RBD per-image IO
       statistics by enabling dynamic OSD performance counters. Defaults to
       <literal>false</literal>.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>parameters</literal>: Sets any parameters listed to the given
       pool
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>target_size_ratio:</literal> gives a hint (%) to &ceph; in
         terms of expected consumption of the total cluster capacity of a given
         pool.
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>compression_mode</literal>: Sets up the pool for inline
         compression when using a &bluestore; OSD. If left unspecified does not
         setup any compression mode for the pool. Values supported are the same
         as &bluestore; inline compression modes, such as
         <literal>none</literal>,
         <literal>passive</literal>,<literal>aggressive</literal>, and
         <literal>force</literal>.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </itemizedlist>
   </sect3>
   <sect3 xml:id="rook-add-specific-pool-properties">
    <title>Add Specific Pool Properties</title>
    <para>
     With <literal>poolProperties</literal> you can set any pool property:
    </para>
<screen>
spec:
  parameters:
    &lt;name of the parameter&gt;: &lt;parameter value&gt;
</screen>
    <para>
     For example:
    </para>
<screen>
spec:
  parameters:
    min_size: 1
</screen>
   </sect3>
   <sect3 xml:id="rook-erasure-coding">
    <title>Erasure Coding</title>
    <para>
     <link xlink:href="http://docs.ceph.com/docs/master/rados/operations/erasure-code/">Erasure
     coding</link> allows you to keep your data safe while reducing the storage
     overhead. Instead of creating multiple replicas of the data, erasure
     coding divides the original data into chunks of equal size, then generates
     extra chunks of that same size for redundancy.
    </para>
    <para>
     For example, if you have an object of size 2 MB, the simplest erasure
     coding with two data chunks would divide the object into two chunks of
     size 1 MB each (data chunks). One more chunk (coding chunk) of size 1 MB
     will be generated. In total, 3 MB will be stored in the cluster. The
     object will be able to suffer the loss of any one of the chunks and still
     be able to reconstruct the original object.
    </para>
    <para>
     The number of data and coding chunks you choose will depend on your
     resiliency to loss and how much storage overhead is acceptable in your
     storage cluster. Here are some examples to illustrate how the number of
     chunks affects the storage and loss toleration.
    </para>
    <informaltable>
     <tgroup cols="5">
      <colspec colwidth="20*" align="left" />
      <colspec colwidth="22*" align="left" />
      <colspec colwidth="17*" align="left" />
      <colspec colwidth="21*" align="left" />
      <colspec colwidth="17*" align="left" />
      <thead>
       <row>
        <entry> Data chunks (k) </entry>
        <entry> Coding chunks (m) </entry>
        <entry> Total storage </entry>
        <entry> Losses Tolerated </entry>
        <entry> OSDs required </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> 2 </entry>
        <entry> 1 </entry>
        <entry> 1.5x </entry>
        <entry> 1 </entry>
        <entry> 3 </entry>
       </row>
       <row>
        <entry> 2 </entry>
        <entry> 2 </entry>
        <entry> 2x </entry>
        <entry> 2 </entry>
        <entry> 4 </entry>
       </row>
       <row>
        <entry> 4 </entry>
        <entry> 2 </entry>
        <entry> 1.5x </entry>
        <entry> 2 </entry>
        <entry> 6 </entry>
       </row>
       <row>
        <entry> 16 </entry>
        <entry> 4 </entry>
        <entry> 1.25x </entry>
        <entry> 4 </entry>
        <entry> 20 </entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
    <para>
     The <literal>failureDomain</literal> must be also be taken into account
     when determining the number of chunks. The failure domain determines the
     level in the &ceph; CRUSH hierarchy where the chunks must be uniquely
     distributed. This decision will impact whether node losses or disk losses
     are tolerated. There could also be performance differences of placing the
     data across nodes or OSDs.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>host</literal>: All chunks will be placed on unique hosts
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>osd</literal>: All chunks will be placed on unique OSDs
      </para>
     </listitem>
    </itemizedlist>
    <para>
     If you do not have a sufficient number of hosts or OSDs for unique
     placement the pool can be created, writing to the pool will hang.
    </para>
    <para>
     &rook; currently only configures two levels in the CRUSH map. It is also
     possible to configure other levels such as <literal>rack</literal> with by
     adding topology labels to the nodes.
    </para>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="rook-ceph-shared-filesystem-crd">
  <title>&ceph; Shared File System CRD</title>

  <para>
   &rook; allows creation and customization of shared file systems through the
   custom resource definitions (CRDs). The following settings are available for
   &ceph; file systems.
  </para>

  <sect2 xml:id="rook-samples-rook-rep">
   <title>Samples</title>
   <sect3 xml:id="rook-replicated">
    <title>Replicated</title>
    <note>
     <para>
      This sample requires at least one OSD per node, with each OSD located on
      three different nodes.
     </para>
    </note>
    <para>
     Each OSD must be located on a different node, because both of the defined
     pools set the <literal>failureDomain</literal> to <literal>host</literal>
     and the <literal>replicated.size</literal> to three.
    </para>
    <para>
     The <literal>failureDomain</literal> can also be set to another location
     type (for example, <literal>rack</literal>), if it has been added as a
     <literal>location</literal> in the Storage Selection Settings.
    </para>
<screen>
  apiVersion: ceph.rook.io/v1
  kind: CephFilesystem
  metadata:
    name: myfs
    namespace: rook-ceph
  spec:
    metadataPool:
      failureDomain: host
      replicated:
        size: 3
    dataPools:
      - failureDomain: host
        replicated:
          size: 3
    preservePoolsOnDelete: true
    metadataServer:
      activeCount: 1
      activeStandby: true
      # A key/value list of annotations
      annotations:
      #  key: value
      placement:
      #  nodeAffinity:
      #    requiredDuringSchedulingIgnoredDuringExecution:
      #      nodeSelectorTerms:
      #      - matchExpressions:
      #        - key: role
      #          operator: In
      #          values:
      #          - mds-node
      #  tolerations:
      #  - key: mds-node
      #    operator: Exists
      #  podAffinity:
      #  podAntiAffinity:
      #  topologySpreadConstraints:
      resources:
      #  limits:
      #    cpu: "500m"
      #    memory: "1024Mi"
      #  requests:
      #    cpu: "500m"
      #    memory: "1024Mi"
</screen>
    <para>
     These definitions can be found in the <filename>filesystem.yaml</filename>
     file.
    </para>
   </sect3>
   <sect3 xml:id="rook-erasure-coded">
    <title>Erasure Coded</title>
    <para>
     Erasure coded pools require the OSDs to use &bluestore; for the configured
     <literal>storeType</literal>. Additionally, erasure coded pools can only
     be used with <literal>dataPools</literal>. The
     <literal>metadataPool</literal> must use a replicated pool.
    </para>
    <note>
     <para>
      This sample requires at least three &bluestore; OSDs, with each OSD
      located on a different node.
     </para>
    </note>
    <para>
     The OSDs must be located on different nodes, because the
     <literal>failureDomain</literal> will be set to <literal>host</literal> by
     default, and the <literal>erasureCoded</literal> chunk settings require at
     least three different OSDs (two <literal>dataChunks</literal> + one
     <literal>codingChunks</literal>).
    </para>
<screen>
  apiVersion: ceph.rook.io/v1
  kind: CephFilesystem
  metadata:
    name: myfs-ec
    namespace: rook-ceph
  spec:
    metadataPool:
      replicated:
        size: 3
    dataPools:
      - erasureCoded:
          dataChunks: 2
          codingChunks: 1
    metadataServer:
      activeCount: 1
      activeStandby: true
</screen>
    <para>
     These definitions can also be found in the
     <filename>filesystem-ec.yaml</filename> file.
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="rook-filesystem-settings">
   <title>File System Settings</title>
   <sect3 xml:id="rook-metadata-filesystem">
    <title>Metadata</title>
    <itemizedlist>
     <listitem>
      <para>
       <literal>name</literal>: The name of the file system to create, which
       will be reflected in the pool and other resource names.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>namespace</literal>: The namespace of the &rook; cluster where
       the file system is created.
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
   <sect3 xml:id="rook-pools">
    <title>Pools</title>
    <para>
     The pools allow all of the settings defined in the Pool CRD spec. In the
     example above, there must be at least three hosts (size three) and at
     least eight devices (six data + two coding chunks) in the cluster.
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>metadataPool</literal>: The settings used to create the
       filesystem metadata pool. Must use replication.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>dataPools</literal>: The settings to create the file system
       data pools. If multiple pools are specified, &rook; will add the pools
       to the file system. The data pools can use replication or erasure
       coding. If erasure coding pools are specified, the cluster must be
       running with &bluestore; enabled on the OSDs.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>preservePoolsOnDelete</literal>: If it is set to
       <literal>true</literal> the pools used to support the file system will
       remain when the file system will be deleted. This is a security measure
       to avoid accidental loss of data. It is set to <literal>false</literal>
       by default. If not specified is also deemed as <literal>false</literal>.
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
  </sect2>

  <sect2 xml:id="rook-metadata-server-settings">
   <title>Metadata Server Settings</title>
   <para>
    The metadata server settings correspond to the MDS daemon settings.
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>activeCount</literal>: The number of active MDS instances. As
      load increases, &cephfs; will automatically partition the file system
      across the MDS instances. &rook; will create double the number of MDS
      instances as requested by the active count. The extra instances will be
      in standby mode for failover.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>activeStandby</literal>: If true, the extra MDS instances will
      be in active standby mode and will keep a warm cache of the file system
      metadata for faster failover. The instances will be assigned by &cephfs;
      in failover pairs. If false, the extra MDS instances will all be on
      passive standby mode and will not maintain a warm cache of the metadata.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>annotations</literal>: Key value pair list of annotations to
      add.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>labels</literal>: Key value pair list of labels to add.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>placement</literal>: The mds pods can be given standard
      Kubernetes placement restrictions with <literal>nodeAffinity</literal>,
      <literal>tolerations</literal>, <literal>podAffinity</literal>, and
      <literal>podAntiAffinity</literal> similar to placement defined for
      daemons configured by the cluster CRD.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>resources</literal>: Set resource requests and limits for the
      Filesystem MDS Pod(s).
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>priorityClassName</literal>: Set priority class name for the
      File system MDS Pod(s)
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>
</chapter>
