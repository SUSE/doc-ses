<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"  xml:id="monitoring-alerting">
 <title>Monitoring and Alerting</title>
 <para>
  In &productname; 6, &deepsea; no longer deploys a monitoring and alerting
  stack on the &smaster;. Users have to define the &prometheus; role
  for &prometheus; and &alertmanager;, and the &grafana; role for &grafana;.
  When multiple nodes are assigned with the &prometheus; or &grafana; role, a
  highly available setup is deployed.
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <emphasis role="bold">&prometheus;</emphasis> is the monitoring and alerting
    toolkit.
   </para>
 </listitem>
 <listitem>
  <para>
   <emphasis role="bold">&alertmanager;</emphasis> handles alerts sent by
   the &prometheus; server.
  </para>
 </listitem>
  <listitem>
   <para>
    <emphasis role="bold">&grafana;</emphasis> is the visualization and alerting
    software.
   </para>
  </listitem>
  <listitem>
   <para>
    The <systemitem class="daemon">prometheus-node_exporter</systemitem>
    is the service running on all &sminion;s.
   </para>
  </listitem>
 </itemizedlist>
 <para>
  The &prometheus; configuration and <emphasis>scrape</emphasis> targets
  (exporting daemons) are setup automatically by &deepsea;. &deepsea; also
  deploys a list of default alerts, for example <literal>health
  error</literal>, <literal>10% OSDs down</literal>, or <literal>pgs
  inactive</literal>.
 </para>

 <sect1 xml:id="pillar-variables">
  <title>Pillar Variables</title>
  <para>The &spillar; is a key-value store that provides information and
    configuration values to minions. It is available to all minions, each
    with differing content. The &spillar; is pre-populated with default
    values and can be customized in two different ways:</para>
   <itemizedlist>
    <listitem>
     <para>
      <emphasis role="bold"><filename>/srv/pillar/ceph/stack/global.yml</filename></emphasis>:
      to change pillar variables for all nodes.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><filename>/srv/pillar/ceph/stack/<replaceable>CLUSTER_NAME</replaceable>/minions/<replaceable>HOST</replaceable></filename></emphasis>:
      to change specific minion configurations.
     </para>
    </listitem>
   </itemizedlist>
  <para>
    The pillar variables below are available to all nodes by default:
  </para>
<screen>
  monitoring:
  alertmanager:
    config: salt://path/to/config
    additional_flags: ''
  grafana:
    ssl_cert: False # self-signed certs are created by default
    ssl_key: False # self-signed certs are created by default
  prometheus:
    # pass additional configration to prometheus
    additional_flags: ''
    alert_relabel_config: []
    rule_files: []
    # per exporter config variables
    scrape_interval:
      ceph: 10
      node_exporter: 10
      prometheus: 10
      grafana: 10
    relabel_config:
      alertmanager: []
      ceph: []
      node_exporter: []
      prometheus: []
      grafana: []
    metric_relabel_config:
      ceph: []
      node_exporter: []
      prometheus: []
      grafana: []
    target_partition:
      ceph: '1/1'
      node_exporter: '1/1'
      prometheus: '1/1'
      grafana: '1/1'
</screen>
</sect1>

<sect1 xml:id="grafana">
  <title>&grafana;</title>
  <para>
    All traffic is encrypted through &grafana;. You can either supply your
    own SSL certs or create self-signed one.</para>
  <para>&grafana; uses the following variables:</para>
  <itemizedlist>
    <listitem>
      <para>
        <emphasis role="bold"><literal>ssl_cert</literal></emphasis>
      </para>
    </listitem>
    <listitem>
      <para>
        <emphasis role="bold"><literal>ssl_key</literal></emphasis>
      </para>
    </listitem>
  </itemizedlist>
  <para>For more information on supplying your own SSL certificates, see <xref linkend="cert-sign-CA"/>
    or for creating your own, see <xref linkend="self-sign-certificates"/>.
  </para>
</sect1>

 <sect1 xml:id="prometheus">
   <title>&prometheus;</title>
  <para>The exporter based configuration that can be passed through the pillar.
    These groups map to exporters that provide data. The node exporter is
    present on all nodes, &ceph; is exported by the &mgr; nodes, &prometheus;
    and &grafana; is exported by the respective &prometheus; and &grafana; nodes.</para>
  <para>&prometheus; uses the following variables:</para>
    <itemizedlist>
    <listitem>
     <para>
      <emphasis role="bold"><literal>scrape_interval</literal></emphasis>:
       change the scrape interval, how often an exporter is to be scraped.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>target_partition</literal></emphasis>:
       partition scrape targets when multiple &prometheus; instnaces are
       deployed and have some instances scrape only part of all
       exporter instances.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>relabel_config</literal></emphasis>:
       dynamically rewrites the label set of a target before it gets scraped.
       Multiple relabeling steps can be configured per scrape configuration.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis role="bold"><literal>metrics_relabel_config</literal></emphasis>:
       applied to samples as the last step before ingestion.
     </para>
    </listitem>
   </itemizedlist>
 </sect1>

 <sect1 xml:id="alerting-alertmanager">
  <title>&alertmanager;</title>
  <para>
   The &alertmanager; handles alerts sent by the &prometheus; server. It takes
   care of deduplicating, grouping, and routing them to the correct receiver.
   It also takes care of silencing of alerts. &alertmanager; is configured via
   the command line flags and a configuration file that defines inhibition
   rules, notification routing and notification receivers.
  </para>
  <sect2>
   <title>Configuration File</title>
   <para>
    &alertmanager;'s configuration is different for each deployment. Therefore,
    &deepsea; does not ship any related defaults. You need to provide your own
    <filename>alertmanager.yml</filename> configuration file. The
    <package>alertmanager</package> package by default installs a
    configuration file <filename>/etc/prometheus/alertmanager.yml</filename>
    which can serve as an example configuration. If you prefer to have your
    &alertmanager; configuration managed by &deepsea;, add the following key to
    your pillar, for example to the
    <filename>/srv/pillar/ceph/stack/ceph/minions/<replaceable>YOUR_SALT_MASTER_MINION_ID</replaceable>.sls</filename>
    file:
   </para>
   <para>
    For a complete example of &alertmanager;'s configuration file, see
    <xref linkend="app-alerting-default"/>.
   </para>
<screen>
monitoring:
 alertmanager_config:
   /path/to/your/alertmanager/config.yml
</screen>
   <para>
    &alertmanager;'s configuration file is written in the YAML format. It
    follows the scheme described below. Parameters in brackets are optional.
    For non-list parameters the default value is used. The following generic
    placeholders are used in the scheme:
   </para>
   <variablelist>
    <varlistentry>
     <term><replaceable>DURATION</replaceable></term>
     <listitem>
      <para>
       A duration matching the regular expression
       <literal>[0-9]+(ms|[smhdwy])</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>LABELNAME</replaceable></term>
     <listitem>
      <para>
       A string matching the regular expression
       <literal>[a-zA-Z_][a-zA-Z0-9_]*</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>LABELVALUE</replaceable></term>
     <listitem>
      <para>
       A string of Unicode characters.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>FILEPATH</replaceable></term>
     <listitem>
      <para>
       A valid path in the current working directory.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>BOOLEAN</replaceable></term>
     <listitem>
      <para>
       A Boolean that can take the values 'true' or 'false'.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>STRING</replaceable></term>
     <listitem>
      <para>
       A regular string.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>SECRET</replaceable></term>
     <listitem>
      <para>
       A regular string that is a secret, for example a password.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>TMPL_STRING</replaceable></term>
     <listitem>
      <para>
       A string which is template-expanded before usage.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><replaceable>TMPL_SECRET</replaceable></term>
     <listitem>
      <para>
       A secret string which is template-expanded before usage.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <example>
    <title>Global Configuration</title>
    <para>
     Parameters in the <literal>global:</literal> configuration are valid in
     all other configuration contexts. They also serve as defaults for other
     configuration sections.
    </para>
<screen>
global:
# the time after which an alert is declared resolved if it has not been updated
[ resolve_timeout: <replaceable>DURATION</replaceable> | default = 5m ]

# The default SMTP From header field.
[ smtp_from: <replaceable>TMPL_STRING</replaceable> ]
# The default SMTP smarthost used for sending emails, including port number.
# Port number usually is 25, or 587 for SMTP over TLS
# (sometimes referred to as STARTTLS).
# Example: smtp.example.org:587
[ smtp_smarthost: <replaceable>STRING</replaceable> ]
# The default host name to identify to the SMTP server.
[ smtp_hello: <replaceable>STRING</replaceable> | default = "localhost" ]
[ smtp_auth_username: <replaceable>STRING</replaceable> ]
# SMTP Auth using LOGIN and PLAIN.
[ smtp_auth_password: <replaceable>SECRET</replaceable> ]
# SMTP Auth using PLAIN.
[ smtp_auth_identity: <replaceable>STRING</replaceable> ]
# SMTP Auth using CRAM-MD5.
[ smtp_auth_secret: <replaceable>SECRET</replaceable> ]
# The default SMTP TLS requirement.
[ smtp_require_tls: <replaceable>BOOL</replaceable> | default = true ]

# The API URL to use for Slack notifications.
[ slack_api_url: <replaceable>STRING</replaceable> ]
[ victorops_api_key: <replaceable>STRING</replaceable> ]
[ victorops_api_url: <replaceable>STRING</replaceable> | default = "https://victorops.example.com/integrations/alert/" ]
[ pagerduty_url: <replaceable>STRING</replaceable> | default = "https://pagerduty.example.com/v2/enqueue" ]
[ opsgenie_api_key: <replaceable>STRING</replaceable> ]
[ opsgenie_api_url: <replaceable>STRING</replaceable> | default = "https://opsgenie.example.com/" ]
[ hipchat_api_url: <replaceable>STRING</replaceable> | default = "https://hipchat.example.com/" ]
[ hipchat_auth_token: <replaceable>SECRET</replaceable> ]
[ wechat_api_url: <replaceable>STRING</replaceable> | default = "https://wechat.example.com/cgi-bin/" ]
[ wechat_api_secret: <replaceable>SECRET</replaceable> ]
[ wechat_api_corp_id: <replaceable>STRING</replaceable> ]

# The default HTTP client configuration
[ http_config: <replaceable>HTTP_CONFIG</replaceable> ]

# Files from which custom notification template definitions are read.
# The last component may use a wildcard matcher, e.g. 'templates/*.tmpl'.
templates:
[ - <replaceable>FILEPATH</replaceable> ... ]

# The root node of the routing tree.
route: <replaceable>ROUTE</replaceable>

# A list of notification receivers.
receivers:
- <replaceable>RECEIVER</replaceable> ...

# A list of inhibition rules.
inhibit_rules:
[ - <replaceable>INHIBIT_RULE</replaceable> ... ]
</screen>
   </example>
   <example>
    <title><replaceable>ROUTE</replaceable></title>
    <para>
     A <replaceable>ROUTE</replaceable> block defines a node in a routing
     tree. Unspecified parameters are inherited from its parent node. Every
     alert enters the routing tree at the configured top-level route, which
     needs to match all alerts. It then traverses the child nodes. If the
     <option>continue</option> option is set to 'false', the traversing stops
     after the first matched child. Setting the option to 'true' on a matched
     node, the alert will continue matching against subsequent siblings. If an
     alert does not match any children of a node, the alert is handled based
     on the configuration parameters of the current node.
    </para>
<screen>
[ receiver: <replaceable>STRING</replaceable> ]
[ group_by: '[' <replaceable>LABELNAME</replaceable>, ... ']' ]

# If an alert should continue matching subsequent sibling nodes.
[ continue: <replaceable>BOOLEAN</replaceable> | default = false ]

# A set of equality matchers an alert has to fulfill to match a node.
match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]

# A set of regex-matchers an alert has to fulfill to match a node.
match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Time to wait before sending a notification for a group of alerts.
[ group_wait: <replaceable>DURATION</replaceable> | default = 30s ]

# Time to wait before sending a notification about new alerts
# added to a group of alerts for which an initial notification has
# already been sent.
[ group_interval: <replaceable>DURATION</replaceable> | default = 5m ]

# Time to wait before re-sending a notification
[ repeat_interval: <replaceable>DURATION</replaceable> | default = 4h ]

# Possible child routes.
routes:
 [ - <replaceable>ROUTE</replaceable> ... ]
</screen>
   </example>
   <example>
    <title><replaceable>INHIBIT_RULE</replaceable></title>
    <para>
     An inhibition rule mutes a target alert that matches a set of matchers
     when a source alert exists that matches another set of matchers. Both
     alerts need to share the same label values for the label names in the
     <option>equal</option> list.
    </para>
    <para>
     Alerts can match and therefore inhibit themselves. Do not write
     inhibition rules where an alert matches both source and target.
    </para>
<screen>
# Matchers that need to be fulfilled for the alerts to be muted.
target_match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]
target_match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Matchers for which at least one alert needs to exist so that the
# inhibition occurs.
source_match:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>LABELVALUE</replaceable>, ... ]
source_match_re:
 [ <replaceable>LABELNAME</replaceable>: <replaceable>REGEX</replaceable>, ... ]

# Labels with an equal value in the source and target
# alert for the inhibition to take effect.
[ equal: '[' <replaceable>LABELNAME</replaceable>, ... ']' ]
</screen>
   </example>
   <example>
    <title><replaceable>HTTP_CONFIG</replaceable></title>
    <para>
     <replaceable>HTTP_CONFIG</replaceable> configures the HTTP client used by
     the receiver to communicate with API services.
    </para>
    <para>
     Note that <option>basic_auth</option>, <option>bearer_token</option> and
     <option>bearer_token_file</option> options are mutually exclusive.
    </para>
<screen>
# Sets the 'Authorization' header with the user name and password.
basic_auth:
[ username: <replaceable>STRING</replaceable> ]
[ password: <replaceable>SECRET</replaceable> ]

# Sets the 'Authorization' header with the bearer token.
[ bearer_token: <replaceable>SECRET</replaceable> ]

# Sets the 'Authorization' header with the bearer token read from a file.
[ bearer_token_file: <replaceable>FILEPATH</replaceable> ]

# TLS settings.
tls_config:
# CA certificate to validate the server certificate with.
[ ca_file: <replaceable>FILEPATH</replaceable> ]
# Certificate and key files for client cert authentication to the server.
[ cert_file: <replaceable>FILEPATH</replaceable> ]
[ key_file: <replaceable>FILEPATH</replaceable> ]
# ServerName extension to indicate the name of the server.
# http://tools.ietf.org/html/rfc4366#section-3.1
[ server_name: <replaceable>STRING</replaceable> ]
# Disable validation of the server certificate.
[ insecure_skip_verify: <replaceable>BOOLEAN</replaceable> | default = false]

# Optional proxy URL.
[ proxy_url: <replaceable>STRING</replaceable> ]
</screen>
   </example>
   <example>
    <title><replaceable>RECEIVER</replaceable></title>
    <para>
     Receiver is a named configuration for one or more notification
     integrations.
    </para>
    <para>
     Instead of adding new receivers, we recommend implementing custom
     notification integrations using the webhook receiver (see
     <xref linkend="alert-webhook"/>).
    </para>
<screen>
# The unique name of the receiver.
name: <replaceable>STRING</replaceable>

# Configurations for several notification integrations.
email_configs:
[ - <replaceable>EMAIL_CONFIG</replaceable>, ... ]
hipchat_configs:
[ - <replaceable>HIPCHAT_CONFIG</replaceable>, ... ]
pagerduty_configs:
[ - <replaceable>PAGERDUTY_CONFIG</replaceable>, ... ]
pushover_configs:
[ - <replaceable>PUSHOVER_CONFIG</replaceable>, ... ]
slack_configs:
[ - <replaceable>SLACK_CONFIG</replaceable>, ... ]
opsgenie_configs:
[ - <replaceable>OPSGENIE_CONFIG</replaceable>, ... ]
webhook_configs:
[ - <replaceable>WEBHOOK_CONFIG</replaceable>, ... ]
victorops_configs:
[ - <replaceable>VICTOROPS_CONFIG</replaceable>, ... ]
wechat_configs:
[ - <replaceable>WECHAT_CONFIG</replaceable>, ... ]
</screen>
   </example>
   <example>
    <title><replaceable>EMAIL_CONFIG</replaceable></title>
<screen>
# Whether to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The email address to send notifications to.
to: <replaceable>TMPL_STRING</replaceable>

# The sender address.
[ from: <replaceable>TMPL_STRING</replaceable> | default = global.smtp_from ]

# The SMTP host through which emails are sent.
[ smarthost: <replaceable>STRING</replaceable> | default = global.smtp_smarthost ]

# The host name to identify to the SMTP server.
[ hello: <replaceable>STRING</replaceable> | default = global.smtp_hello ]

# SMTP authentication details.
[ auth_username: <replaceable>STRING</replaceable> | default = global.smtp_auth_username ]
[ auth_password: <replaceable>SECRET</replaceable> | default = global.smtp_auth_password ]
[ auth_secret: <replaceable>SECRET</replaceable> | default = global.smtp_auth_secret ]
[ auth_identity: <replaceable>STRING</replaceable> | default = global.smtp_auth_identity ]

# The SMTP TLS requirement.
[ require_tls: <replaceable>BOOL</replaceable> | default = global.smtp_require_tls ]

# The HTML body of the email notification.
[ html: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "email.default.html" . }}' ]
# The text body of the email notification.
[ text: <replaceable>TMPL_STRING</replaceable> ]

# Further headers email header key/value pairs. Overrides any headers
# previously set by the notification implementation.
[ headers: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } ]
</screen>
   </example>
   <example>
    <title><replaceable>HIPCHAT_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The HipChat Room ID.
room_id: <replaceable>TMPL_STRING</replaceable>
# The authentication token.
[ auth_token: <replaceable>SECRET</replaceable> | default = global.hipchat_auth_token ]
# The URL to send API requests to.
[ api_url: <replaceable>STRING</replaceable> | default = global.hipchat_api_url ]

# A label to be shown in addition to the sender's name.
[ from:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "hipchat.default.from" . }}' ]
# The message body.
[ message:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "hipchat.default.message" . }}' ]
# Whether this message will trigger a user notification.
[ notify:  <replaceable>BOOLEAN</replaceable> | default = false ]
# Determines how the message is treated by the alertmanager and rendered inside HipChat. Valid values are 'text' and 'html'.
[ message_format:  <replaceable>STRING</replaceable> | default = 'text' ]
# Background color for message.
[ color:  <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}red{{ else }}green{{ end }}' ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>PAGERDUTY_CONFIG</replaceable></title>
    <para>
     The <option>routing_key</option> and <option>service_key</option> options
     are mutually exclusive.
    </para>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The PagerDuty integration key (when using 'Events API v2').
routing_key: <replaceable>TMPL_SECRET</replaceable>
# The PagerDuty integration key (when using 'Prometheus').
service_key: <replaceable>TMPL_SECRET</replaceable>

# The URL to send API requests to.
[ url: <replaceable>STRING</replaceable> | default = global.pagerduty_url ]

# The client identification of the Alertmanager.
[ client:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.client" . }}' ]
# A backlink to the notification sender.
[ client_url:  <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.clientURL" . }}' ]

# The incident description.
[ description: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pagerduty.default.description" .}}' ]

# Severity of the incident.
[ severity: <replaceable>TMPL_STRING</replaceable> | default = 'error' ]

# A set of arbitrary key/value pairs that provide further details.
[ details: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } | default = {
 firing:       '{{ template "pagerduty.default.instances" .Alerts.Firing }}'
 resolved:     '{{ template "pagerduty.default.instances" .Alerts.Resolved }}'
 num_firing:   '{{ .Alerts.Firing | len }}'
 num_resolved: '{{ .Alerts.Resolved | len }}'
} ]

# The HTTP client's configuration.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>PUSHOVER_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The recipient user key.
user_key: <replaceable>SECRET</replaceable>

# Registered application’s API token.
token: <replaceable>SECRET</replaceable>

# Notification title.
[ title: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.title" . }}' ]

# Notification message.
[ message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.message" . }}' ]

# A supplementary URL displayed together with the message.
[ url: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "pushover.default.url" . }}' ]

# Priority.
[ priority: <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}2{{ else }}0{{ end }}' ]

# How often the Pushover servers will send the same notification (at least 30 seconds).
[ retry: <replaceable>DURATION</replaceable> | default = 1m ]

# How long your notification will continue to be retried (unless the user
# acknowledges the notification).
[ expire: <replaceable>DURATION</replaceable> | default = 1h ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The Slack webhook URL.
[ api_url: <replaceable>SECRET</replaceable> | default = global.slack_api_url ]

# The channel or user to send notifications to.
channel: <replaceable>TMPL_STRING</replaceable>

# API request data as defined by the Slack webhook API.
[ icon_emoji: <replaceable>TMPL_STRING</replaceable> ]
[ icon_url: <replaceable>TMPL_STRING</replaceable> ]
[ link_names: <replaceable>BOOLEAN</replaceable> | default = false ]
[ username: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.username" . }}' ]
# The following parameters define the attachment.
actions:
[ <replaceable>ACTION_CONFIG</replaceable> ... ]
[ color: <replaceable>TMPL_STRING</replaceable> | default = '{{ if eq .Status "firing" }}danger{{ else }}good{{ end }}' ]
[ fallback: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.fallback" . }}' ]
fields:
[ <replaceable>FIELD_CONFIG</replaceable> ... ]
[ footer: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.footer" . }}' ]
[ pretext: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.pretext" . }}' ]
[ short_fields: <replaceable>BOOLEAN</replaceable> | default = false ]
[ text: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.text" . }}' ]
[ title: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.title" . }}' ]
[ title_link: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "slack.default.titlelink" . }}' ]
[ image_url: <replaceable>TMPL_STRING</replaceable> ]
[ thumb_url: <replaceable>TMPL_STRING</replaceable> ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>ACTION_CONFIG</replaceable> for <replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# Provide a button to tell Slack you want to render a button.
type: <replaceable>TMPL_STRING</replaceable>
# Label for the button.
text: <replaceable>TMPL_STRING</replaceable>
# http or https URL to deliver users to. If you specify invalid URLs, the message will be posted with no button.
url: <replaceable>TMPL_STRING</replaceable>
#  If set to 'primary', the button will be green, indicating the best forward action to take
#  'danger' turns the button red, indicating a destructive action.
[ style: <replaceable>TMPL_STRING</replaceable> [ default = '' ]
</screen>
   </example>
   <example>
    <title><replaceable>FIELD_CONFIG</replaceable> for <replaceable>SLACK_CONFIG</replaceable></title>
<screen>
# A bold heading without markup above the <option>value</option> text.
title: <replaceable>TMPL_STRING</replaceable>
# The text of the field. It can span across several lines.
value: <replaceable>TMPL_STRING</replaceable>
# A flag indicating if <option>value</option> is short enough to be displayed together with other values.
[ short: <replaceable>BOOLEAN</replaceable> | default = slack_config.short_fields ]
</screen>
   </example>
   <example>
    <title><replaceable>OPSGENIE_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The API key to use with the OpsGenie API.
[ api_key: <replaceable>SECRET</replaceable> | default = global.opsgenie_api_key ]

# The host to send OpsGenie API requests to.
[ api_url: <replaceable>STRING</replaceable> | default = global.opsgenie_api_url ]

# Alert text (maximum is 130 characters).
[ message: <replaceable>TMPL_STRING</replaceable> ]

# A description of the incident.
[ description: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "opsgenie.default.description" . }}' ]

# A backlink to the sender.
[ source: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "opsgenie.default.source" . }}' ]

# A set of arbitrary key/value pairs that provide further detail.
[ details: { <replaceable>STRING</replaceable>: <replaceable>TMPL_STRING</replaceable>, ... } ]

# Comma separated list of team responsible for notifications.
[ teams: <replaceable>TMPL_STRING</replaceable> ]

# Comma separated list of tags attached to the notifications.
[ tags: <replaceable>TMPL_STRING</replaceable> ]

# Additional alert note.
[ note: <replaceable>TMPL_STRING</replaceable> ]

# Priority level of alert, one of P1, P2, P3, P4, and P5.
[ priority: <replaceable>TMPL_STRING</replaceable> ]

# Configuration of the HTTP.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example>
    <title><replaceable>VICTOROPS_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The API key for talking to the VictorOps API.
[ api_key: <replaceable>SECRET</replaceable> | default = global.victorops_api_key ]

# The VictorOps API URL.
[ api_url: <replaceable>STRING</replaceable> | default = global.victorops_api_url ]

# A key used to map the alert to a team.
routing_key: <replaceable>TMPL_STRING</replaceable>

# Describes the behavior of the alert (one of 'CRITICAL', 'WARNING', 'INFO').
[ message_type: <replaceable>TMPL_STRING</replaceable> | default = 'CRITICAL' ]

# Summary of the alerted problem.
[ entity_display_name: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.entity_display_name" . }}' ]

# Long explanation of the alerted problem.
[ state_message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.state_message" . }}' ]

# The monitoring tool the state message is from.
[ monitoring_tool: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "victorops.default.monitoring_tool" . }}' ]

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
   </example>
   <example xml:id="alert-webhook">
    <title><replaceable>WEBHOOK_CONFIG</replaceable></title>
    <para>
     You can use the webhook receiver to configure a generic receiver.
    </para>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = true ]

# The endpoint for sending HTTP POST requests.
url: <replaceable>STRING</replaceable>

# Configuration of the HTTP client.
[ http_config: <replaceable>HTTP_CONFIG</replaceable> | default = global.http_config ]
</screen>
    <para>
     &alertmanager; sends HTTP POST requests in the following JSON format:
    </para>
<screen>
{
 "version": "4",
 "groupKey": <replaceable>STRING</replaceable>, // identifycation of the group of alerts (to deduplicate)
 "status": "&lt;resolved|firing>",
 "receiver": <replaceable>STRING</replaceable>,
 "groupLabels": <replaceable>OBJECT</replaceable>,
 "commonLabels": <replaceable>OBJECT</replaceable>,
 "commonAnnotations": <replaceable>OBJECT</replaceable>,
 "externalURL": <replaceable>STRING</replaceable>, // backlink to Alertmanager.
 "alerts": [
   {
     "status": "&lt;resolved|firing>",
     "labels": <replaceable>OBJECT</replaceable>,
     "annotations": <replaceable>OBJECT</replaceable>,
     "startsAt": "&lt;rfc3339>",
     "endsAt": "&lt;rfc3339>",
     "generatorURL": <replaceable>STRING</replaceable> // identifies the entity that caused the alert
   },
   ...
 ]
}
</screen>
    <para>
     The webhook receiver allows for integration with the following
     notification mechanisms:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       DingTalk (https://github.com/timonwong/prometheus-webhook-dingtalk)
      </para>
     </listitem>
     <listitem>
      <para>
       IRC Bot (https://github.com/multimfi/bot)
      </para>
     </listitem>
     <listitem>
      <para>
       JIRAlert (https://github.com/free/jiralert)
      </para>
     </listitem>
     <listitem>
      <para>
       Phabricator / Maniphest (https://github.com/knyar/phalerts)
      </para>
     </listitem>
     <listitem>
      <para>
       prom2teams: forwards notifications to Microsoft Teams
       (https://github.com/idealista/prom2teams)
      </para>
     </listitem>
     <listitem>
      <para>
       SMS: supports multiple providers
       (https://github.com/messagebird/sachet)
      </para>
     </listitem>
     <listitem>
      <para>
       Telegram bot (https://github.com/inCaller/prometheus_bot)
      </para>
     </listitem>
     <listitem>
      <para>
       SNMP trap (https://github.com/SUSE/prometheus-webhook-snmp)
      </para>
     </listitem>
    </itemizedlist>
   </example>
   <example>
    <title><replaceable>WECHAT_CONFIG</replaceable></title>
<screen>
# Whether or not to notify about resolved alerts.
[ send_resolved: <replaceable>BOOLEAN</replaceable> | default = false ]

# The API key to use for the WeChat API.
[ api_secret: <replaceable>SECRET</replaceable> | default = global.wechat_api_secret ]

# The WeChat API URL.
[ api_url: <replaceable>STRING</replaceable> | default = global.wechat_api_url ]

# The corp id used to authenticate.
[ corp_id: <replaceable>STRING</replaceable> | default = global.wechat_api_corp_id ]

# API request data as defined by the WeChat API.
[ message: <replaceable>TMPL_STRING</replaceable> | default = '{{ template "wechat.default.message" . }}' ]
[ agent_id: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.agent_id" . }}' ]
[ to_user: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_user" . }}' ]
[ to_party: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_party" . }}' ]
[ to_tag: <replaceable>STRING</replaceable> | default = '{{ template "wechat.default.to_tag" . }}' ]
</screen>
   </example>
  </sect2>
  <sect2>
   <title>Custom Alerts</title>
   <para>
    You can define your custom alert conditions to send notifications to an
    external service. &prometheus; uses its own expression language for
    defining custom alerts. Following is an example of a rule with an alert:
   </para>
<screen>
groups:
- name: example
 rules:
  # alert on high deviation from average PG count
  - alert: high pg count deviation
   expr: abs(((ceph_osd_pgs > 0) - on (job) group_left avg(ceph_osd_pgs > 0) by (job)) / on (job) group_left avg(ceph_osd_pgs > 0) by (job)) > 0.35
   for: 5m
   labels:
    severity: warning
    type: ses_default
   annotations:
   description: >
    OSD {{ $labels.osd }} deviates by more then 30% from average PG count
</screen>
   <para>
    The optional <literal>for</literal> clause specifies the time &prometheus;
    will wait between first encountering a new expression output vector
    element and counting an alert as firing. In this case, &prometheus; will
    check that the alert continues to be active for 5 minutes before firing
    the alert. Elements in a pending state are active, but not firing yet.
   </para>
   <para>
    The <literal>labels</literal> clause specifies a set of additional labels
    attached to the alert. Conflicting labels will be overwritten. Labels can
    be templated (see <xref linkend="alertmanager-templates"/> for more
    details on templating).
   </para>
   <para>
    The <literal>annotations</literal> clause specifies informational labels.
    You can use them to store additional information, for example alert
    descriptions or runbook links. Annotations can be templated (see
    <xref linkend="alertmanager-templates"/> for more details on templating).
   </para>
   <para>
    To add your custom alerts to &productname; &productnumber;, either
   </para>
   <itemizedlist>
    <listitem>
     <para>
      place your YAML files with custom alerts in the
      <filename>/etc/prometheus/alerts</filename> directory
     </para>
    </listitem>
   </itemizedlist>
   <para>
    or
   </para>
   <itemizedlist>
    <listitem>
     <para>
      provide a list of paths to your custom alert files in the Pillar under
      the <option>monitoring:custom_alerts</option> key. &deepsea; Stage 2 or
      the <command>salt <replaceable>SALT_MASTER</replaceable> state.apply
      ceph.monitoring.prometheus</command> command will add your alert files
      in the right place.
     </para>
     <example>
      <title>Adding Custom Alerts to &productname;</title>
      <para>
       A file with custom alerts is in
       <filename>/root/my_alerts/my_alerts.yml</filename> on the Salt master.
       If you add
      </para>
<screen>
monitoring:
 custom_alerts:
   - /root/my_alerts/my_alerts.yml
</screen>
      <para>
       to the
       <filename>/srv/pillar/ceph/cluster/<replaceable>YOUR_SALT_MASTER_MINION_ID</replaceable>.sls</filename>
       file, &deepsea; will create the
       <filename>/etc/prometheus/alerts/my_alerts.yml</filename> file and
       restart &prometheus;.
      </para>
     </example>
    </listitem>
   </itemizedlist>
   <sect3 xml:id="alertmanager-templates">
    <title>Templates</title>
    <para>
     You can use templates for label and annotation values. The
     <varname>$labels</varname> variable includes the label key/value pairs of
     an alert instance, while <varname>$value</varname> holds the evaluated
     value of an alert instance.
    </para>
    <para>
     The following example inserts a firing element label and value:
    </para>
<screen>
{{ $labels.<replaceable>LABELNAME</replaceable> }}
{{ $value }}
</screen>
   </sect3>
   <sect3>
    <title>Inspecting Alerts at Runtime</title>
    <para>
     If you need to verify which alerts are active, you have several options:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Navigate to the <guimenu>Alerts</guimenu> tab of &prometheus;. It will
       show you the exact label sets for which defined alerts are active.
       &prometheus; also stores synthetic time series for pending and firing
       alerts. They have the following form:
      </para>
<screen>
ALERTS{alertname="<replaceable>ALERT_NAME</replaceable>", alertstate="pending|firing", <replaceable>ADDITIONAL_ALERT_LABELS</replaceable>}
</screen>
      <para>
       The sample value is 1 if the alert is active (pending or firing). The
       series is marked 'stale' when the alert is inactive.
      </para>
     </listitem>
     <listitem>
      <para>
       In the &prometheus; Web interface at the URL address
       http://<replaceable>PROMETHEUS_HOST_IP</replaceable>:9090/alerts,
       inspect alerts and their state (INACTIVE, PENDING or FIRING).
      </para>
     </listitem>
     <listitem>
      <para>
       In the &alertmanager; Web interface at the URL address
       http://:<replaceable>PROMETHEUS_HOST_IP</replaceable>9093/#/alerts,
       inspect alerts and silence them if desired.
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
  </sect2>
  <sect2>
   <title>SNMP Trap Receiver</title>
   <para>
    If you want to get notified about &prometheus; alerts via SNMP traps, then
    you can install the &prometheus; &alertmanager; SNMP trap receiver via
    &deepsea;. To do so you need to enable it in the Pillar under the
    <option>monitoring:alertmanager_receiver_snmp:enabled</option> key. The
    configuration of the receiver must be set under the
    <option>monitoring:alertmanager_receiver_snmp:config</option> key.
    &deepsea; Stage 2 or the <command>salt
    <replaceable>SALT_MASTER</replaceable> state.apply
    ceph.monitoring.alertmanager</command> command will install and configure
    the receiver in the appropriate location.
   </para>
   <example>
    <title>SNMP Trap Configuration</title>
<screen>
monitoring:
 alertmanager:
   receiver:
      snmp:
        enabled: True
        config:
          host: localhost
          port: 9099
          snmp_host: snmp.foo-bar.com
          snmp_community: private
          metrics: True
</screen>
     <para>
      Refer to the receiver manual at
      <link xlink:href="https://github.com/SUSE/prometheus-webhook-snmp#global-configuration-file" />.
      for more details about the configuration options.
     </para>
    </example>
  </sect2>
</sect1>

</chapter>
