<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "entity-decl.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"  xml:id="monitoring-alerting">
 <title>Monitoring and Alerting</title>
 <para>
  In &productname; &productnumber;, &cephadm; deploys a monitoring and alerting stack. Users have
  to define the services - &prometheus;, &alertmanager;, and &grafana; - they
  want to deploy with &cephadm;. When multiple services of the same type are deployed,
  a highly available setup is deployed.
 </para>
 <itemizedlist>
  <listitem>
   <para>
    <emphasis role="bold">&prometheus;</emphasis> is the monitoring and alerting
    toolkit.
   </para>
 </listitem>
 <listitem>
  <para>
   <emphasis role="bold">&alertmanager;</emphasis> handles alerts sent by
   the &prometheus; server.
  </para>
 </listitem>
  <listitem>
   <para>
    <emphasis role="bold">&grafana;</emphasis> is the visualization and alerting
    software.
   </para>
  </listitem>
  <listitem>
   <para>
    The <systemitem class="daemon">prometheus-node_exporter</systemitem>
    is the service running on all &sminion;s.
   </para>
  </listitem>
 </itemizedlist>
 <para>
  The &prometheus; configuration and <emphasis>scrape</emphasis> targets
  (exporting daemons) are setup automatically by &cephadm;. &cephadm; also
  deploys a list of default alerts, for example <literal>health
  error</literal>, <literal>10% OSDs down</literal>, or <literal>pgs
  inactive</literal>.
 </para>

 <sect1 xml:id="monitoring-cephadm-config">
   <title>Configuring Monitoring and Alerting</title>
<screen>
  ---
  service_type: prometheus
  placement:
    hosts:
      - host1
  ---
  service_type: grafana
  placement:
    hosts:
      - host2
  ---
  service_type: alertmanager
  placement:
    hosts:
      - host1
  ---
  service_type: node-exporter
  placement:
    host_pattern: "*"
  ---
</screen>
 </sect1>

<sect1 xml:id="grafana">
  <title>&grafana;</title>
  <para>
    All traffic is encrypted through &grafana;. You can either supply your
    own SSL certs or create self-signed one.</para>
  <para>&grafana; uses the following variables:</para>
  <itemizedlist>
    <listitem>
      <para>
        <emphasis role="bold"><literal>ssl_cert</literal></emphasis>
      </para>
    </listitem>
    <listitem>
      <para>
        <emphasis role="bold"><literal>ssl_key</literal></emphasis>
      </para>
    </listitem>
  </itemizedlist>
  <para>For more information on supplying your own SSL certificates, see <xref linkend="cert-sign-CA"/>
    or for creating your own, see <xref linkend="self-sign-certificates"/>.
  </para>
</sect1>

 <sect1 xml:id="prometheus">
   <title>&prometheus;</title>
  <para>
    <!-- Add intro about prometheus
  https://docs.ceph.com/docs/master/mgr/prometheus/ (see below for variable list)-->
    The node exporter is present on all nodes. &ceph; data is exported by
    the &prometheus; &mgr; module.</para>
  <para>&prometheus; uses the following variables:</para>
    <itemizedlist>
    <listitem>
     <para>
      <emphasis role="bold"><literal>scrape_interval</literal></emphasis>:
       change the scrape interval, how often an exporter is to be scraped.
     </para>
   </listitem>
   </itemizedlist>
   <sect2 xml:id="prometheus-security-model">
     <title>Security Model</title>
     <para>
       &prometheus;' security model presumes that untrusted users have access to the
       &prometheus; HTTP endpoint and logs. Untrusted users have access to all the
       (meta)data &prometheus; collects that is contained in the database, plus a
       variety of operational and debugging information.
     </para>
     <para>
       However, &prometheus;' HTTP API is limited to read-only operations.
       Configurations can not be changed using the API and secrets are not
       exposed. Moreover, &prometheus; has some built-in measures to mitigate the
       impact of denial of service attacks.
     </para>
   </sect2>
 </sect1>

 <sect1 xml:id="alerting-alertmanager">
  <title>&alertmanager;</title>
  <para>
   The &alertmanager; handles alerts sent by the &prometheus; server. It takes
   care of deduplicating, grouping, and routing them to the correct receiver.
   It also takes care of silencing of alerts.
  </para>
  <sect2>
   <title>Custom Alerts</title>
   <para>
    You can define your custom alert conditions to send notifications to an
    external service. &prometheus; uses its own expression language for
    defining custom alerts. Following is an example of a rule with an alert:
   </para>
<screen>
groups:
- name: example
 rules:
  # alert on high deviation from average PG count
  - alert: high pg count deviation
   expr: abs(((ceph_osd_pgs > 0) - on (job) group_left avg(ceph_osd_pgs > 0) by (job)) / on (job) group_left avg(ceph_osd_pgs > 0) by (job)) > 0.35
   for: 5m
   labels:
    severity: warning
    type: ses_default
   annotations:
   description: >
    OSD {{ $labels.osd }} deviates by more then 30% from average PG count
</screen>
   <para>
    The optional <literal>for</literal> clause specifies the time &prometheus;
    will wait between first encountering a new expression output vector
    element and counting an alert as firing. In this case, &prometheus; will
    check that the alert continues to be active for 5 minutes before firing
    the alert. Elements in a pending state are active, but not firing yet.
   </para>
   <para>
    The <literal>labels</literal> clause specifies a set of additional labels
    attached to the alert. Conflicting labels will be overwritten. Labels can
    be templated (see <xref linkend="alertmanager-templates"/> for more
    details on templating).
   </para>
   <para>
    The <literal>annotations</literal> clause specifies informational labels.
    You can use them to store additional information, for example alert
    descriptions or runbook links. Annotations can be templated (see
    <xref linkend="alertmanager-templates"/> for more details on templating).
   </para>
   <para>
    To add your custom alerts to &productname; &productnumber;, either
   </para>
   <itemizedlist>
    <listitem>
     <para>
      place your YAML files with custom alerts in the
      <filename>/etc/prometheus/alerts</filename> directory
     </para>
    </listitem>
   </itemizedlist>
   <para>
    or
   </para>
   <itemizedlist>
    <listitem>
     <para>
      provide a list of paths to your custom alert files in the Pillar under
      the <option>monitoring:custom_alerts</option> key. &deepsea; Stage 2 or
      the <command>salt <replaceable>SALT_MASTER</replaceable> state.apply
      ceph.monitoring.prometheus</command> command will add your alert files
      in the right place.
     </para>
     <example>
      <title>Adding Custom Alerts to &productname;</title>
      <para>
       A file with custom alerts is in
       <filename>/root/my_alerts/my_alerts.yml</filename> on the Salt master.
       If you add
      </para>
<screen>
monitoring:
 custom_alerts:
   - /root/my_alerts/my_alerts.yml
</screen>
      <para>
       to the
       <filename>/srv/pillar/ceph/cluster/<replaceable>YOUR_SALT_MASTER_MINION_ID</replaceable>.sls</filename>
       file, &deepsea; will create the
       <filename>/etc/prometheus/alerts/my_alerts.yml</filename> file and
       restart &prometheus;.
      </para>
     </example>
    </listitem>
   </itemizedlist>
   <sect3 xml:id="alertmanager-templates">
    <title>Templates</title>
    <para>
     You can use templates for label and annotation values. The
     <varname>$labels</varname> variable includes the label key/value pairs of
     an alert instance, while <varname>$value</varname> holds the evaluated
     value of an alert instance.
    </para>
    <para>
     The following example inserts a firing element label and value:
    </para>
<screen>
{{ $labels.<replaceable>LABELNAME</replaceable> }}
{{ $value }}
</screen>
   </sect3>
   <sect3>
    <title>Inspecting Alerts at Runtime</title>
    <para>
     If you need to verify which alerts are active, you have several options:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Navigate to the <guimenu>Alerts</guimenu> tab of &prometheus;. It will
       show you the exact label sets for which defined alerts are active.
       &prometheus; also stores synthetic time series for pending and firing
       alerts. They have the following form:
      </para>
<screen>
ALERTS{alertname="<replaceable>ALERT_NAME</replaceable>", alertstate="pending|firing", <replaceable>ADDITIONAL_ALERT_LABELS</replaceable>}
</screen>
      <para>
       The sample value is 1 if the alert is active (pending or firing). The
       series is marked 'stale' when the alert is inactive.
      </para>
     </listitem>
     <listitem>
      <para>
       In the &prometheus; Web interface at the URL address
       http://<replaceable>PROMETHEUS_HOST_IP</replaceable>:9090/alerts,
       inspect alerts and their state (INACTIVE, PENDING or FIRING).
      </para>
     </listitem>
     <listitem>
      <para>
       In the &alertmanager; Web interface at the URL address
       http://:<replaceable>PROMETHEUS_HOST_IP</replaceable>:9093/#/alerts,
       inspect alerts and silence them if desired.
      </para>
     </listitem>
    </itemizedlist>
   </sect3>
  </sect2>
<!--  <sect2>
   <title>SNMP Trap Receiver</title>
   <para>
    If you want to get notified about &prometheus; alerts via SNMP traps, then
    you can install the &prometheus; &alertmanager; SNMP trap receiver via
    &deepsea;. To do so you need to enable it in the Pillar under the
    <option>monitoring:alertmanager_receiver_snmp:enabled</option> key. The
    configuration of the receiver must be set under the
    <option>monitoring:alertmanager_receiver_snmp:config</option> key.
    &deepsea; Stage 2 or the <command>salt
    <replaceable>SALT_MASTER</replaceable> state.apply
    ceph.monitoring.alertmanager</command> command will install and configure
    the receiver in the appropriate location.
   </para>
   <example>
    <title>SNMP Trap Configuration</title>
<screen>
monitoring:
 alertmanager:
   receiver:
      snmp:
        enabled: True
        config:
          host: localhost
          port: 9099
          snmp_host: snmp.foo-bar.com
          snmp_community: private
          metrics: True
</screen>
     <para>
      Refer to the receiver manual at
      <link xlink:href="https://github.com/SUSE/prometheus-webhook-snmp#global-configuration-file" />.
      for more details about the configuration options.
     </para>
    </example>
  </sect2>-->
</sect1>
</chapter>
