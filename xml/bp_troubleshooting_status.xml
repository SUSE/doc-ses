<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter
[
  <!ENTITY % entities SYSTEM "generic-entities.ent">
    %entities;
]>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="bp-troubleshooting-status">
 <title>Troubleshooting &ceph; health status</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:editurl>https://github.com/SUSE/doc-ses/edit/master/xml/</dm:editurl>
   <dm:translation>yes</dm:translation>
   <dm:release>SES 7</dm:release>
  </dm:docmanager>
 </info>
 <para>
  The following section details the statues that have been triggered and
  actions to take when the status is displayed.
 </para>
 <variablelist>
  <title>MONITOR</title>
  <varlistentry>
   <term><option>MON_DOWN</option></term>
   <listitem>
    <para>
     One or more monitor daemons are down. The cluster requires a majority of
     the monitors in order to function. When one or more monitors are down,
     clients will initially have difficulty connecting to the cluster.
    </para>
    <para>
     Restart the monitor daemon that is down as soon as possible to reduce the
     risk of a subsequent monitor failure.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>MON_CLOCK_SKEW</option></term>
   <listitem>
    <para>
     The clocks on the hosts running the
     <systemitem class="daemon">ceph-mon</systemitem> monitor daemons are not
     well synchronized. This health alert is raised if the cluster detects a
     clock skew greater than <option>mon_clock_drift_allowed</option>. Resolve
     this by synchronizing the clocks using either <literal>ntpd</literal> or
     <literal>chrony</literal>. If it is impractical to keep the clocks closely
     synchronized, the <option>mon_clock_drift_allowed</option> threshold can
     be increased, but this value must stay well below the
     <option>mon_lease</option> interval in order for monitor cluster to
     function properly.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>MON_MSGR2_NOT_ENABLED</option></term>
   <listitem>
    <para>
     The <option>ms_bind_msgr2</option> option is enabled but one or more
     monitors is not configured to bind to a v2 port in the cluster’s monmap.
     This means that features specific to the msgr2 protocol (for example,
     encryption) are not available on some or all connections. In most cases
     this can be corrected by issuing the following command:
    </para>
<screen>&prompt.cephuser;ceph mon enable-msgr2</screen>
    <para>
     This command changes any monitor configured for the old default port 6789
     to continue to listen for v1 connections on 6789 and also listen for v2
     connections on the new default 3300 port. If a monitor is configured to
     listen for v1 connections on a non-standard port (not 6789), then the
     monmap needs to be modified manually.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
 <variablelist>
  <title>MANAGER</title>
  <varlistentry>
   <term><option>MGR_MODULE_DEPENDENCY</option></term>
   <listitem>
    <para>
     An enabled manager module is failing its dependency check. This health
     check should come with a message from the module about the problem. For
     example, a module might report that a required package is not installed.
     In which case, the message will read: "Install the required package and
     restart your manager daemons." This health check only applies to enabled
     modules. If a module is not enabled, you can see whether it is reporting
     dependency issues in the output of <command>ceph module ls</command>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>MGR_MODULE_ERROR</option></term>
   <listitem>
    <para>
     A manager module has experienced an unexpected error. Typically, this
     means an unhandled exception was raised from the module’s serve function.
     The human readable description of the error may be obscurely worded if the
     exception did not provide a useful description of itself. This health
     check may indicate a bug. Open a bug report if you think you have
     encountered a bug. If you believe the error is transient, you may restart
     your manager daemon(s), or use <command>ceph mgr fail</command> on the
     active daemon to prompt a failover to another daemon.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
 <variablelist>
  <title>OSDS</title>
  <varlistentry>
   <term><option>OSD_DOWN</option></term>
   <listitem>
    <para>
     One or more OSDs are marked down. The
     <systemitem class="daemon">ceph-osd</systemitem> daemon may have been
     stopped, or peer OSDs may be unable to reach the OSD over the network.
     Common causes include a stopped or crashed daemon, a down host, or a
     network outage. Verify the host is healthy, the daemon is started, and
     network is functioning. If the daemon has crashed, the daemon log file
     (<filename>/var/log/ceph/ceph-osd.*</filename>) may contain debugging
     information.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OSD_<replaceable>CRUSH TYPE</replaceable>_DOWN</option></term>
   <listitem>
    <para>
     For example, <filename>OSD_HOST_DOWN</filename> or
     <filename>OSD_ROOT_DOWN</filename>. All the OSDs within a particular CRUSH
     subtree are marked down, for example all OSDs on a host.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OSD_ORPHAN</option></term>
   <listitem>
    <para>
     An OSD is referenced in the &crushmap; hierarchy but does not exist. The
     OSD can be removed from the CRUSH hierarchy with:
    </para>
<screen>&prompt.cephuser;ceph osd crush rm osd.<replaceable>ID</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OSD_OUT_OF_ORDER_FULL</option></term>
   <listitem>
    <para>
     The utilization thresholds for <literal>backfillfull</literal>,
     <literal>nearfull</literal>, <literal>full</literal>, and
     <option>failsafe_full</option> are not ascending. The thresholds can be
     adjusted with:
    </para>
<screen>&prompt.cephuser;ceph osd set-backfillfull-ratio <replaceable>RATIO</replaceable>
&prompt.cephuser;ceph osd set-nearfull-ratio <replaceable>RATIO</replaceable>
&prompt.cephuser;ceph osd set-full-ratio <replaceable>RATIO</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OSD_FULL</option></term>
   <listitem>
    <para>
     One or more OSDs have exceeded the <literal>full</literal> threshold and
     is preventing the cluster from servicing writes. Utilization by pool can
     be checked with:
    </para>
<screen>&prompt.cephuser;ceph df</screen>
    <para>
     The currently defined <literal>full</literal> ratio can be seen with:
    </para>
<screen>&prompt.cephuser;ceph osd dump | grep full_ratio</screen>
    <para>
     A short-term workaround to restore write availability is to raise the full
     threshold by a small amount:
    </para>
<screen>&prompt.cephuser;ceph osd set-full-ratio <replaceable>RATIO</replaceable></screen>
    <para>
     New storage should be added to the cluster by deploying more OSDs or
     existing data should be deleted in order to free up space.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OSD_BACKFILLFULL</option></term>
   <listitem>
    <para>
     One or more OSDs have exceeded the <literal>backfillfull</literal>
     threshold, preventing data from being allowed to rebalance to this device.
     This is an early warning that rebalancing may not be able to complete and
     that the cluster is approaching <literal>full</literal>. Utilization by
     pool can be checked with:
    </para>
<screen>&prompt.cephuser;ceph df</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OSD_NEARFULL</option></term>
   <listitem>
    <para>
     One or more OSDs have exceeded the <literal>nearfull</literal> threshold.
     This is an early warning that the cluster is approaching
     <literal>full</literal>. Utilization by pool can be checked with:
    </para>
<screen>&prompt.cephuser;ceph df</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OSDMAP_FLAGS</option></term>
   <listitem>
    <para>
     One or more cluster flags of interest has been set. These flags include:
    </para>
    <variablelist>
     <varlistentry>
      <term>full</term>
      <listitem>
       <para>
        The cluster is flagged as <literal>full</literal> and cannot serve
        writes
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>pauserd, pausewr</term>
      <listitem>
       <para>
        Paused reads or writes
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>noup</term>
      <listitem>
       <para>
        OSDs are not allowed to start
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>nodown</term>
      <listitem>
       <para>
        OSD failure reports are being ignored and the monitors are not marking
        OSDs down
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>noin</term>
      <listitem>
       <para>
        OSDs that were previously marked out are not being marked back in when
        they start
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>noout</term>
      <listitem>
       <para>
        Down OSDs are not automatically marked out after the configured
        interval
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>nobackfill, norecover, norebalance</term>
      <listitem>
       <para>
        Recovery or data rebalancing is suspended
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>noscrub, nodeep_scrub</term>
      <listitem>
       <para>
        Scrubbing is disabled
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>notieragent</term>
      <listitem>
       <para>
        Cache tiering activity is suspended
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     With the exception of <literal>full</literal>, these flags can be set or
     cleared with:
    </para>
<screen>&prompt.cephuser;ceph osd set <replaceable>FLAG</replaceable>
&prompt.cephuser;ceph osd unset <replaceable>FLAG</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OSD_FLAGS</option></term>
   <listitem>
    <para>
     One or more OSDs or CRUSH <literal>{nodes,device classes}</literal> has a
     flag of interest set. These flags include:
    </para>
    <variablelist>
     <varlistentry>
      <term>noup</term>
      <listitem>
       <para>
        These OSDs are not allowed to start
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>nodown</term>
      <listitem>
       <para>
        Failure reports for these OSDs are ignored
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>noin</term>
      <listitem>
       <para>
        If these OSDs were previously marked out automatically after a failure,
        they are not to be marked in when they start
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>noout</term>
      <listitem>
       <para>
        If these OSDs are down they are not automatically marked out after the
        configured interval
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     These flags can be set and cleared in batch with:
    </para>
<screen>&prompt.cephuser;ceph osd set-group <replaceable>FLAG</replaceable> <replaceable>WHO</replaceable>
&prompt.cephuser;ceph osd unset-group <replaceable>FLAG</replaceable> <replaceable>WHO</replaceable></screen>
    <para>
     For example:
    </para>
<screen>&prompt.cephuser;ceph osd set-group noup,noout osd.0 osd.1
&prompt.cephuser;ceph osd unset-group noup,noout osd.0 osd.1
&prompt.cephuser;ceph osd set-group noup,noout host-foo
&prompt.cephuser;ceph osd unset-group noup,noout host-foo
&prompt.cephuser;ceph osd set-group noup,noout class-hdd
&prompt.cephuser;ceph osd unset-group noup,noout class-hdd
</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OLD_CRUSH_TUNABLES</option></term>
   <listitem>
    <para>
     The &crushmap; is using old settings and should be updated. The oldest
     tunables that can be used (for example, the oldest client version that can
     connect to the cluster) without triggering this health warning are
     determined by the <option>mon_crush_min_required_version</option> config
     option.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OLD_CRUSH_STRAW_CALC_VERSION</option></term>
   <listitem>
    <para>
     The &crushmap; is using an older, sub-optimal method for calculating
     intermediate weight values for straw buckets. The &crushmap; requires an
     update to use the newer method (<literal>straw_calc_version=1</literal>).
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>CACHE_POOL_NO_HIT_SET</option></term>
   <listitem>
    <para>
     One or more cache pools are not configured with a hit set to track
     utilization. This prevents the tiering agent from identifying cold objects
     to flush and evict from the cache. Hit sets can be configured on the cache
     pool with the following:
    </para>
<screen>&prompt.cephuser;ceph osd pool set <replaceable>POOLNAME</replaceable> hit_set_type <replaceable>TYPE</replaceable>
&prompt.cephuser;ceph osd pool set <replaceable>POOLNAME</replaceable> hit_set_period <replaceable>PERIOD-IN-SECONDS</replaceable>
&prompt.cephuser;ceph osd pool set <replaceable>POOLNAME</replaceable> hit_set_count <replaceable>NUMBER-OF-HITSETS</replaceable>
&prompt.cephuser;ceph osd pool set <replaceable>POOLNAME</replaceable> hit_set_fpp <replaceable>TARGET-FALSE-POSITIVE-RATE</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OSD_NO_SORTBITWISE</option></term>
   <listitem>
    <para>
     No &productname; &prevproductnumber; v12.y.z OSDs are running but the
     <option>sortbitwise</option> flag has not been set. Set the
     <option>sortbitwise</option> flag before v12.y.z or newer OSDs can start.
     You can safely set the flag with:
    </para>
<screen>&prompt.cephuser;ceph osd set sortbitwise</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>POOL_FULL</option></term>
   <listitem>
    <para>
     One or more pools have reached the quota and are no longer allowing
     writes. Pool quotas and utilization can be seen with the following
     command:
    </para>
<screen>&prompt.cephuser;ceph df detail</screen>
    <para>
     You can either raise the pool quota with the following commands:
    </para>
<screen>&prompt.cephuser;ceph osd pool set-quota <replaceable>POOLNAME</replaceable> max_objects <replaceable>NUM-OBJECTS</replaceable>
&prompt.cephuser;ceph osd pool set-quota <replaceable>POOLNAME</replaceable> max_bytes <replaceable>NUM-BYTES</replaceable></screen>
    <para>
     Or, you can delete existing data to reduce utilization.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>BLUEFS_SPILLOVER</option></term>
   <listitem>
    <para>
     One or more OSDs that use the &bluestore; backend have been allocated db
     partitions (storage space for metadata, normally on a faster device) but
     that space has filled, such that metadata has overflowed onto the normal
     slow device. This is not necessarily an error condition or even
     unexpected, but if the administrator’s expectation was that all metadata
     would fit on the faster device, it indicates that not enough space was
     provided. This warning can be disabled on all OSDs with the following
     command:
    </para>
<screen>&prompt.cephuser;ceph config set osd bluestore_warn_on_bluefs_spillover false</screen>
    <para>
     Alternatively, it can be disabled on a specific OSD with the following
     command:
    </para>
<screen>&prompt.cephuser;ceph config set osd.123 bluestore_warn_on_bluefs_spillover false</screen>
    <para>
     To provide more metadata space, the OSD in question can be destroyed and
     reprovisioned. This involves data migration and recovery. It is possible
     to expand the LVM logical volume backing the db storage. If the underlying
     LV has been expanded, the OSD daemon needs to be stopped and BlueFS
     informed of the device size change with the following command:
    </para>
<screen>&prompt.cephuser;ceph-bluestore-tool bluefs-bdev-expand --path /var/lib/ceph/osd/ceph-$ID</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>BLUEFS_AVAILABLE_SPACE</option></term>
   <listitem>
    <para>
     To check how much space is free for BlueFS, execute:
    </para>
<screen>&prompt.cephuser;ceph daemon osd.123 bluestore bluefs available</screen>
    <para>
     This provides output for up to 3 values; <literal>BDEV_DB free</literal>,
     <literal>BDEV_SLOW free</literal> and
     <option>available_from_bluestore</option>. <literal>BDEV_DB</literal> and
     <literal>BDEV_SLOW</literal> report the amount of space that has been
     acquired by BlueFS and is considered free. Value
     <option>available_from_bluestore</option> denotes ability of &bluestore;
     to leave more space to BlueFS. It is normal that this value is different
     from amount of &bluestore; free space, as BlueFS allocation unit is
     typically larger than &bluestore; allocation unit. This means that only
     part of &bluestore; free space is acceptable for BlueFS.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>BLUEFS_LOW_SPACE</option></term>
   <listitem>
    <para>
     If BlueFS is running low on available free space and there is little
     <option>available_from_bluestore</option>, consider reducing BlueFS'
     allocation unit size. To simulate available space when the allocation unit
     is different, execute:
    </para>
<screen>&prompt.cephuser;ceph daemon osd.123 bluestore bluefs available <replaceable>ALLOC-UNIT-SIZE</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>BLUESTORE_FRAGMENTATION</option></term>
   <listitem>
    <para>
     As &bluestore; works, free space on underlying storage becomes fragmented.
     This is normal and unavoidable, but excessive fragmentation can cause
     slowdown. To inspect &bluestore; fragmentation, execute:
    </para>
<screen>&prompt.cephuser;ceph daemon osd.123 bluestore allocator score block</screen>
    <para>
     Score is given in [0-1] range. [0.0 .. 0.4] tiny fragmentation [0.4 ..
     0.7] small, acceptable fragmentation [0.7 .. 0.9] considerable, but safe
     fragmentation [0.9 .. 1.0] severe fragmentation, can impact BlueFS'
     ability to get space from &bluestore;. If detailed report of free
     fragments is required, execute:
    </para>
<screen>&prompt.cephuser;ceph daemon osd.123 bluestore allocator dump block</screen>
    <para>
     If the OSD process does not perform fragmentation, inspect with
     <command>ceph-bluestore-tool</command>. Get the fragmentation score:
    </para>
<screen>&prompt.cephuser;ceph-bluestore-tool --path /var/lib/ceph/osd/ceph-123 --allocator block free-score</screen>
    <para>
     Dump detailed free chunks:
    </para>
<screen>&prompt.cephuser;ceph-bluestore-tool --path /var/lib/ceph/osd/ceph-123 --allocator block free-dump</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>BLUESTORE_LEGACY_STATFS</option></term>
   <listitem>
    <para>
     As of &productname; 6, &bluestore; tracks its internal usage statistics on
     a per-pool granular basis and one or more OSDs have &bluestore; volumes
     that were created prior to &productname; &productnumber;. If all OSDs are
     older than &productname; &productnumber;, the per-pool metrics are not
     available. However, if there is a mix of pre-&productname; &productnumber;
     and post-&productname; &productnumber; OSDs, the cluster usage statistics
     reported by <command>ceph df</command> will not be accurate. The old OSDs
     can be updated to use the new usage tracking scheme by stopping each OSD,
     running a repair operation, and the restarting it. For example, if
     <literal>osd.123</literal> requires an update, run the following command.
     To identify the unique FSID of the cluster, run <command>ceph
     fsid</command>. To identify the &ogw; daemon name, run <command>ceph orch
     ps ---hostname <replaceable>HOSTNAME</replaceable></command>.
    </para>
<screen>&prompt.root;systemctl stop ceph-<replaceable>FSID</replaceable>@<replaceable>osd.123</replaceable>
&prompt.cephuser;ceph-bluestore-tool repair --path /var/lib/ceph/osd/ceph-123
&prompt.root;systemctl start ceph-osd@123</screen>
    <para>
     This warning can be disabled with:
    </para>
<screen>&prompt.cephuser;ceph config set global bluestore_warn_on_legacy_statfs false</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>BLUESTORE_DISK_SIZE_MISMATCH</option></term>
   <listitem>
    <para>
     One or more OSDs using &bluestore; has an internal inconsistency between
     the size of the physical device and the metadata tracking its size. This
     can lead to the OSD crashing in the future. The OSDs in question should be
     destroyed and re-deployed. To avoid putting any data at risk, re-deploy
     only one OSD at a time. For example, if <replaceable>OSD_ID</replaceable>
     has the error:
    </para>
<screen>
&prompt.cephuser;ceph osd out osd.<replaceable>OSD_ID</replaceable>
&prompt.cephuser;while ! ceph osd safe-to-destroy osd.<replaceable>OSD_ID</replaceable> ; do sleep 1m ; done
&prompt.cephuser;ceph osd destroy osd.<replaceable>OSD_ID</replaceable>
&prompt.cephuser;cephadm ceph-volume lvm zap /path/to/device
&prompt.cephuser;cephadm ceph-volume lvm create --osd-id  <replaceable>OSD_ID</replaceable>--data /path/to/device
</screen>
   </listitem>
  </varlistentry>
 </variablelist>
 <variablelist>
  <title>DEVICE HEALTH</title>
  <varlistentry>
   <term><option>DEVICE_HEALTH</option></term>
   <listitem>
    <para>
     One or more devices are expected to fail. The warning threshold is
     controlled by the <literal>mgr/devicehealth/warn_threshold</literal>
     configuration option. This warning only applies to OSDs that are currently
     marked <option>in</option>. The expected response to this failure is to
     mark the device <option>out</option>. The data is then migrated off of the
     device and the hardware is removed from the system. Marking out is
     normally done automatically if
     <literal>mgr/devicehealth/self_heal</literal> is enabled based on the
     <literal>mgr/devicehealth/mark_out_threshold</literal>. Device health can
     be checked with:
    </para>
<screen>&prompt.cephuser;ceph device info <replaceable>DEVICE-ID</replaceable></screen>
    <para>
     Device life expectancy is set by a prediction model run by the &mgr; or by
     an external tool via the command:
    </para>
<screen>&prompt.cephuser;ceph device set-life-expectancy <replaceable>DEVICE-ID</replaceable> <replaceable>FROM</replaceable> <replaceable>TO</replaceable></screen>
    <para>
     You can change the stored life expectancy manually, but that usually does
     not persist&mdash;the tool that originally set it reset and changing the
     stored value does not affect the actual health of the hardware device.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>DEVICE_HEALTH_IN_USE</option></term>
   <listitem>
    <para>
     One or more devices are expected to fail and has been marked
     <option>out</option> of the cluster based on
     <literal>mgr/devicehealth/mark_out_threshold</literal>, but the devices
     are still participating in one more PGs. This may be because it was only
     recently marked as <option>out</option> and the data is still migrating,
     or because the data cannot be migrated off for some reason (for example,
     the cluster is nearly full, or the CRUSH hierarchy is such that there is
     not another suitable OSD to migrate the data to). This message can be
     silenced by disabling the self heal behavior (setting
     <literal>mgr/devicehealth/self_heal</literal> to false), by adjusting the
     <literal>mgr/devicehealth/mark_out_threshold</literal>, or by addressing
     what is preventing data from being migrated off of the ailing device.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>DEVICE_HEALTH_TOOMANY</option></term>
   <listitem>
    <para>
     Too many devices are expected to fail and the
     <literal>mgr/devicehealth/self_heal</literal> behavior is enabled, such
     that marking <option>out</option> all of the ailing devices would exceed
     the clusters <option>mon_osd_min_in_ratio</option> ratio that prevents too
     many OSDs from being automatically marked <option>out</option>. This can
     indicates that too many devices in the cluster are expected to fail and
     action is required to add newer (healthier) devices before too many
     devices fail and data is lost. The health message can also be silenced by
     adjusting parameters like <option>mon_osd_min_in_ratio</option> or
     <literal>mgr/devicehealth/mark_out_threshold</literal>, but be warned that
     this increases the likelihood of unrecoverable data loss in the cluster.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
 <variablelist>
  <title>DATA HEALTH (POOLS AND PLACEMENT GROUPS)</title>
  <varlistentry>
   <term><option>PG_AVAILABILITY</option></term>
   <listitem>
    <para>
     Data availability is reduced and the cluster is unable to service
     potential read or write requests for some data in the cluster.
     Specifically, if one or more PGs are in a state that does not allow IO
     requests to be serviced. Problematic PG states include peering, stale,
     incomplete, and in-active (if those conditions do not clear quickly).
     Detailed information about which PGs are affected is available from:
    </para>
<screen>&prompt.cephuser;ceph health detail</screen>
    <para>
     In most cases the root cause is that one or more OSDs are currently down;
     see the discussion for <option>OSD_DOWN</option> above. The state of
     specific problematic PGs can be queried with:
    </para>
<screen>&prompt.cephuser;ceph tell <replaceable>PG_ID</replaceable> query</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>PG_DEGRADED</option></term>
   <listitem>
    <para>
     Data redundancy is reduced for some data, meaning the cluster does not
     have the desired number of replicas for all data (for replicated pools) or
     erasure code fragments (for erasure coded pools). Specifically, if one or
     more PGs:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       have a degraded or undersized flag set, meaning there are not enough
       instances of that placement group in the cluster;
      </para>
     </listitem>
     <listitem>
      <para>
       have not had the clean flag set for some time.
      </para>
     </listitem>
    </itemizedlist>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>PG_RECOVERY_FULL</option></term>
   <listitem>
    <para>
     Data redundancy can be reduced or at risk for some data due to a lack of
     free space in the cluster. Specifically, one or more PGs have the
     <option>recovery_toofull</option> flag set, meaning that the cluster is
     unable to migrate or recover data because one or more OSDs are above the
     full threshold. See the discussion for <option>OSD_FULL</option> above for
     steps to resolve this condition.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>PG_BACKFILL_FULL</option></term>
   <listitem>
    <para>
     Data redundancy can be reduced or at risk for some data due to a lack of
     free space in the cluster. Specifically, one or more PGs have the
     <option>backfill_toofull</option> flag set, meaning that the cluster is
     unable to migrate or recover data because one or more OSDs are above the
     backfillfull threshold. See the discussion for
     <option>OSD_BACKFILLFULL</option> above for steps to resolve this
     condition.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>PG_DAMAGED</option></term>
   <listitem>
    <para>
     Data scrubbing has discovered some problems with data consistency in the
     cluster. Specifically, one or more PGs have the inconsistent or
     <option>snaptrim_error</option> flag is set, indicating an earlier scrub
     operation found a problem, or that the repair flag is set and a repair for
     such an inconsistency is currently in progress.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OSD_SCRUB_ERRORS</option></term>
   <listitem>
    <para>
     Recent OSD scrubs have uncovered inconsistencies. This error is generally
     paired with <option>PG_DAMAGED</option>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>LARGE_OMAP_OBJECTS</option></term>
   <listitem>
    <para>
     One or more pools contain large omap objects as determined by
     <option>osd_deep_scrub_large_omap_object_key_threshold</option> (threshold
     for number of keys to determine a large omap object) or
     <option>osd_deep_scrub_large_omap_object_value_sum_threshold</option> (the
     threshold for summed size (bytes) of all key values to determine a large
     omap object) or both. More information on the object name, key count, and
     size in bytes can be found by searching the cluster log for ‘Large omap
     object found’. Large omap objects can be caused by RGW bucket index
     objects that do not have automatic resharding enabled. The thresholds can
     be adjusted with:
    </para>
<screen>&prompt.cephuser;ceph config set osd osd_deep_scrub_large_omap_object_key_threshold <replaceable>KEYS</replaceable>
&prompt.cephuser;ceph config set osd osd_deep_scrub_large_omap_object_value_sum_threshold <replaceable>BYTES</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>CACHE_POOL_NEAR_FULL</option></term>
   <listitem>
    <para>
     A cache tier pool is nearly full. Full is determined by the
     <option>target_max_bytes</option> and <option>target_max_objects</option>
     properties on the cache pool. Once the pool reaches the target threshold,
     write requests to the pool may block while data is flushed and evicted
     from the cache, a state that normally leads to very high latencies and
     poor performance. The cache pool target size can be adjusted with:
    </para>
<screen>&prompt.cephuser;ceph osd pool set <replaceable>CACHE-POOL-NAME</replaceable> target_max_bytes <replaceable>BYTES</replaceable>
&prompt.cephuser;ceph osd pool set <replaceable>CACHE-POOL-NAME</replaceable> target_max_objects <replaceable>OBJECTS</replaceable></screen>
    <para>
     Normal cache flush and eviction activity can also be throttled due to
     reduced availability, performance of the base tier, or overall cluster
     load.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>POOL_TOO_FEW_PGS</option></term>
   <listitem>
    <para>
     One or more pools should probably have more PGs, based on the amount of
     data that is currently stored in the pool. This can lead to sub-optimal
     distribution and balance of data across the OSDs in the cluster, and
     similarly reduce overall performance. This warning is generated if the
     <option>pg_autoscale_mode</option> property on the pool is set to warn. To
     disable the warning, you can disable auto-scaling of PGs for the pool
     entirely with:
    </para>
<screen>&prompt.cephuser;ceph osd pool set <replaceable>POOL-NAME</replaceable> pg_autoscale_mode off</screen>
    <para>
     To allow the cluster to automatically adjust the number of PGs:
    </para>
<screen>&prompt.cephuser;ceph osd pool set <replaceable>POOL-NAME</replaceable> pg_autoscale_mode on</screen>
    <para>
     You can also manually set the number of PGs for the pool to the
     recommended amount with:
    </para>
<screen>&prompt.cephuser;ceph osd pool set <replaceable>POOL_NAME</replaceable> pg_num <replaceable>NEW_PG_NUM</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>TOO_MANY_PGS</option></term>
   <listitem>
    <para>
     The number of PGs in use in the cluster is above the configurable
     threshold of <option>mon_max_pg_per_osd</option> PGs per OSD. If this
     threshold is exceeded, the cluster does not allow new pools to be created,
     pool <option>pg_num</option> to be increased, or pool replication to be
     increased (any of which would lead to more PGs in the cluster). A large
     number of PGs can lead to higher memory utilization for OSD daemons,
     slower peering after cluster state changes (like OSD restarts, additions,
     or removals), and higher load on the &mgr; and &mon; daemons. The simplest
     way to mitigate the problem is to increase the number of OSDs in the
     cluster by adding more hardware. The OSD count used for the purposes of
     this health check is the number of <option>in</option> OSDs, marking
     <option>out</option> OSDs <option>in</option> (if there are any) can also
     help:
    </para>
<screen>&prompt.cephuser;ceph osd in <replaceable>OSD_IDs</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>POOL_TOO_MANY_PGS</option></term>
   <listitem>
    <para>
     One or more pools require more PGs based on the amount of data that is
     currently stored in the pool. This can lead to higher memory utilization
     for OSD daemons, slower peering after cluster state changes (like OSD
     restarts, additions, or removals), and higher load on the manager and
     monitor daemons. This warning is generated if the
     <option>pg_autoscale_mode</option> property on the pool is set to warn. To
     disable the warning, you can disable auto-scaling of PGs for the pool
     entirely with:
    </para>
<screen>&prompt.cephuser;ceph osd pool set <replaceable>POOL_NAME</replaceable> pg_autoscale_mode off</screen>
    <para>
     To allow the cluster to automatically adjust the number of PGs:
    </para>
<screen>&prompt.cephuser;ceph osd pool set <replaceable>POOL_NAME</replaceable> pg_autoscale_mode on</screen>
    <para>
     You can also manually set the number of PGs for the pool to the
     recommended amount with:
    </para>
<screen>&prompt.cephuser;ceph osd pool set <replaceable>POOL_NAME</replaceable> pg_num <replaceable>NEW_PG_-NUM</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>POOL_TARGET_SIZE_RATIO_OVERCOMMITTED</option></term>
   <listitem>
    <para>
     One or more pools have a <option>target_size_ratio</option> property set
     to estimate the expected size of the pool as a fraction of total storage,
     but the value(s) exceed the total available storage (either by themselves
     or in combination with other pools’ actual usage). This can indicate that
     the <option>target_size_ratio</option> value for the pool is too large and
     should be reduced or set to zero with:
    </para>
<screen>&prompt.cephuser;ceph osd pool set <replaceable>POOL-NAME</replaceable> target_size_ratio 0</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>POOL_TARGET_SIZE_BYTES_OVERCOMMITTED</option></term>
   <listitem>
    <para>
     One or more pools have a <option>target_size_bytes</option> property set
     to estimate the expected size of the pool, but the value(s) exceed the
     total available storage (either by themselves or in combination with other
     pools’ actual usage). This indicates that the
     <option>target_size_bytes</option> value for the pool is too large and
     should be reduced or set to zero with:
    </para>
<screen>&prompt.cephuser;ceph osd pool set <replaceable>POOL-NAME</replaceable> target_size_bytes 0</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>TOO_FEW_OSDS</option></term>
   <listitem>
    <para>
     The number of OSDs in the cluster is below the configurable threshold of
     <option>osd_pool_default_size</option>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>SMALLER_PGP_NUM</option></term>
   <listitem>
    <para>
     One or more pools have a <option>pgp_num</option> value less than
     <option>pg_num</option>, indicating that the PG count was increased
     without also increasing the placement behavior. To adjust the placement
     group number, adjust <option>pgp_num</option> and <option>pg_num</option>.
     Ensure that changing <option>pgp_num</option> is performed first and does
     not trigger the rebalance. To resolve, set <option>pgp_num</option> to
     match <option>pg_num</option> and trigger the data migration with:
    </para>
<screen>&prompt.cephuser;ceph osd pool set <replaceable>POOL</replaceable> pgp_num <replaceable>PG-NUM-VALUE</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>MANY_OBJECTS_PER_PG</option></term>
   <listitem>
    <para>
     One or more pools has an average number of objects per PG that is
     significantly higher than the overall cluster average. The specific
     threshold is controlled by the
     <option>mon_pg_warn_max_object_skew</option> configuration value. This
     indicates that the pool(s) containing most of the data in the cluster have
     too few PGs, or that other pools that do not contain as much data have too
     many PGs. The threshold can be raised to silence the health warning by
     adjusting the <option>mon_pg_warn_max_object_skew</option> configuration
     option on the monitors.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>POOL_APP_NOT_ENABLED</option></term>
   <listitem>
    <para>
     A pool exists that contains one or more objects but has not been tagged
     for use by a particular application. Resolve this warning by labeling the
     pool for use by an application. For example, if the pool is used by RBD:
    </para>
<screen>&prompt.cephuser;rbd pool init <replaceable>POOLNAME</replaceable></screen>
    <para>
     If the pool is being used by a custom application
     <replaceable>FOO</replaceable>, you can also label via the low-level
     command:
    </para>
<screen>&prompt.cephuser;ceph osd pool application enable <replaceable>FOO</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>POOL_FULL</option></term>
   <listitem>
    <para>
     One or more pools has reached (or is very close to reaching) its quota.
     The threshold to trigger this error condition is controlled by the
     <option>mon_pool_quota_crit_threshold</option> configuration option. Pool
     quotas can be adjusted up or down (or removed) with:
    </para>
<screen>&prompt.cephuser;ceph osd pool set-quota <replaceable>POOL</replaceable> max_bytes <replaceable>BYTES</replaceable>
&prompt.cephuser;ceph osd pool set-quota <replaceable>POOL</replaceable> max_objects <replaceable>OBJECTS</replaceable>
</screen>
    <para>
     Setting the quota value to 0 disables the quota.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>POOL_NEAR_FULL</option></term>
   <listitem>
    <para>
     One or more pools are approaching its quota. The threshold to trigger this
     warning condition is controlled by the
     <option>mon_pool_quota_warn_threshold</option> configuration option. Pool
     quotas can be adjusted up or down (or removed) with:
    </para>
<screen>&prompt.cephuser;ceph osd pool set-quota <replaceable>POOL</replaceable> max_bytes <replaceable>BYTES</replaceable>
&prompt.cephuser;ceph osd pool set-quota <replaceable>POOL</replaceable> max_objects <replaceable>OBJECTS</replaceable>
</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OBJECT_MISPLACED</option></term>
   <listitem>
    <para>
     One or more objects in the cluster is not stored on the node the cluster
     would like it to be stored on. This is an indication that data migration
     due to some recent cluster change has not yet completed. Misplaced data is
     not a dangerous condition in and of itself. Data consistency is not at
     risk and old copies of objects are not removed until the desired number of
     new copies (in the desired locations) are present.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>OBJECT_UNFOUND</option></term>
   <listitem>
    <para>
     One or more objects in the cluster cannot be found. Specifically, the OSDs
     know that a new or updated copy of an object should exist, but a copy of
     that version of the object has not been found on OSDs that are currently
     online. Read or write requests to unfound objects will block. Ideally, a
     down OSD can be brought back online that has the more recent copy of the
     unfound object. Candidate OSDs can be identified from the peering state
     for the PG(s) responsible for the unfound object:
    </para>
<screen>&prompt.cephuser;ceph tell <replaceable>PG_ID</replaceable> query</screen>
    <para>
     If the latest copy of the object is not available, the cluster can be told
     to roll back to a previous version of the object.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>SLOW_OPS</option></term>
   <listitem>
    <para>
     One or more OSD requests is taking a long time to process. This can be an
     indication of extreme load, a slow storage device, or a software bug. The
     request queue on the OSD(s) in question can be queried with the following
     command, executed from the OSD host:
    </para>
<screen>&prompt.cephuser;ceph daemon osd.<replaceable>ID</replaceable> ops</screen>
    <para>
     A summary of the slowest recent requests can be seen with:
    </para>
<screen>&prompt.cephuser;ceph daemon osd.<replaceable>ID</replaceable> dump_historic_ops</screen>
    <para>
     The location of an OSD can be found with:
    </para>
<screen>&prompt.cephuser;ceph osd find osd.<replaceable>ID</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>PG_NOT_SCRUBBED</option></term>
   <listitem>
    <para>
     One or more PGs have not been scrubbed recently. PGs are normally scrubbed
     every <option>mon_scrub_interval</option> seconds and this warning
     triggers when <option>mon_warn_pg_not_deep_scrubbed_ratio</option>
     percentage of interval has elapsed without a scrub since it was due. PGs
     do not scrub if they are not flagged as clean. This can happen if they are
     misplaced or degraded (see <option>PG_AVAILABILITY</option> and
     <option>PG_DEGRADED</option> above). You can manually initiate a scrub of
     a clean PG with:
    </para>
<screen>&prompt.cephuser;ceph pg scrub <replaceable>PG_ID</replaceable></screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>PG_NOT_DEEP_SCRUBBED</option></term>
   <listitem>
    <para>
     One or more PGs have not been deep scrubbed recently. PGs are normally
     scrubbed every <option>osd_deep_scrub_interval</option> seconds and this
     warning triggers when <option>mon_warn_pg_not_deep_scrubbed_ratio</option>
     percentage of interval has elapsed without a scrub since it was due. PGs
     do not (deep) scrub if they are not flagged as clean. This can happen if
     they are misplaced or degraded (see <option>PG_AVAILABILITY</option> and
     <option>PG_DEGRADED</option> above). You can manually initiate a scrub of
     a clean PG with:
    </para>
<screen>&prompt.cephuser;ceph pg deep-scrub <replaceable>PG_ID</replaceable></screen>
   </listitem>
  </varlistentry>
 </variablelist>
 <variablelist>
  <title>HEALTH CHECKS</title>
  <varlistentry>
   <term><option>CEPHADM_PAUSED</option></term>
   <listitem>
    <para>
     &cephadm; background work has been paused with <command>ceph orch
     pause</command>. &cephadm; continues to perform passive monitoring
     activities (for example, checking host and daemon status), but it will not
     make any changes (for example, deploying or removing daemons).
    </para>
    <para>
     Resume &cephadm; work with:
    </para>
<screen>&prompt.cephuser;ceph orch resume</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>CEPHADM_STRAY_HOST</option></term>
   <listitem>
    <para>
     One or more hosts have running &ceph; daemons but are not registered as
     hosts managed by &cephadm;. This means that those services cannot
     currently be managed by &cephadm;. For example, restarted, upgraded,
     included in <command>ceph orch ps</command>.
    </para>
    <para>
     You can manage the host(s) with:
    </para>
<screen>&prompt.cephuser;ceph orch host add <replaceable>hostname</replaceable></screen>
    <note>
     <para>
      You may need to configure SSH access to the remote host before this will
      work.
     </para>
    </note>
    <para>
     Alternatively, you can manually connect to the host and ensure that
     services on that host are removed or migrated to a host that is managed by
     &cephadm;.
    </para>
    <para>
     You can also disable this warning entirely with:
    </para>
<screen>&prompt.cephuser;ceph config set mgr mgr/cephadm/warn_on_stray_hosts false</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>CEPHADM_STRAY_DAEMON</option></term>
   <listitem>
    <para>
     One or more &ceph; daemons are running but not are not managed by
     &cephadm;. This may be because they were deployed using a different tool,
     or because they were started manually. Those services cannot currently be
     managed by &cephadm;. For example, restarted, upgraded, or included in
     <command>ceph orch ps</command>..
    </para>
    <para>
     If the daemon is a stateful one (MON or OSD), it should be adopted by
     &cephadm;. For stateless daemons, it is usually easiest to provision a new
     daemon with the <command>ceph orch apply</command> command and then stop
     the unmanaged daemon.
    </para>
    <para>
     This warning can be disabled entirely with:
    </para>
<screen>&prompt.cephuser;ceph config set mgr mgr/cephadm/warn_on_stray_daemons false</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>CEPHADM_HOST_CHECK_FAILED</option></term>
   <listitem>
    <para>
     One or more hosts have failed the basic &cephadm; host check, which
     verifies that the host is reachable and <command>cephadm</command> can be
     executed there, and that the host satisfies basic prerequisites, like a
     working container runtime (podman or docker) and working time
     synchronization. If this test fails, &cephadm; will not be able to manage
     services on that host.
    </para>
    <para>
     You can manually run this check with:
    </para>
<screen>&prompt.cephuser;ceph cephadm check-host <replaceable>hostname</replaceable></screen>
    <para>
     You can remove a broken host from management with:
    </para>
<screen>&prompt.cephuser;ceph orch host rm <replaceable>hostname</replaceable></screen>
    <para>
     You can disable this health warning with:
    </para>
<screen>&prompt.cephuser;ceph config set mgr mgr/cephadm/warn_on_failed_host_check false</screen>
   </listitem>
  </varlistentry>
 </variablelist>
 <variablelist>
  <title>MISCELLANEOUS</title>
  <varlistentry>
   <term><option>RECENT_CRASH</option></term>
   <listitem>
    <para>
     One or more &ceph; daemons have crashed recently, and the crash has not
     yet been archived or acknowledged by the administrator. This may indicate
     a software bug, a hardware problem (for example, a failing disk), or some
     other problem. New crashes can be listed with:
    </para>
<screen>&prompt.cephuser;ceph crash ls-new</screen>
    <para>
     Information about a specific crash can be examined with:
    </para>
<screen>&prompt.cephuser;ceph crash info <replaceable>CRASH-ID</replaceable></screen>
    <para>
     This warning can be silenced by archiving the crash (perhaps after being
     examined by an administrator) so that it does not generate this warning:
    </para>
<screen>&prompt.cephuser;ceph crash archive <replaceable>CRASH-ID</replaceable></screen>
    <para>
     Similarly, all new crashes can be archived with:
    </para>
<screen>&prompt.cephuser;ceph crash archive-all</screen>
    <para>
     Archived crashes are still visible via <command>ceph crash ls</command>
     but not <command>ceph crash ls-new</command>. The time period for what
     recent means is controlled by the option
     <literal>mgr/crash/warn_recent_interval</literal> (default: two weeks).
     These warnings can be disabled entirely with:
    </para>
<screen>&prompt.cephuser;ceph config set mgr/crash/warn_recent_interval 0</screen>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><option>TELEMETRY_CHANGED</option></term>
   <listitem>
    <para>
     Telemetry has been enabled but the contents of the telemetry report have
     changed since that time, so telemetry reports are not sent. The &ceph;
     developers periodically revise the telemetry feature to include new and
     useful information, or to remove information found to be useless or
     sensitive. If any new information is included in the report, &ceph;
     requires the administrator to re-enable telemetry to ensure they have an
     opportunity to (re)review what information is shared. To review the
     contents of the telemetry report:
    </para>
<screen>&prompt.cephuser;ceph telemetry show</screen>
    <para>
     The telemetry report consists of several optional channels that are
     independently enabled or disabled. To re-enable telemetry (and make this
     warning go away):
    </para>
<screen>&prompt.cephuser;ceph telemetry on</screen>
    <para>
     To disable telemetry (and make this warning go away):
    </para>
<screen>&prompt.cephuser;ceph telemetry soff</screen>
   </listitem>
  </varlistentry>
 </variablelist>
<screen>
 groups:
  - name: cluster health
   rules:
    - alert: health error
     expr: ceph_health_status == 2
     for: 5m
     labels:
      severity: critical
      type: ses_default
     annotations:
      description: Ceph in error for > 5m
    - alert: unhealthy
     expr: ceph_health_status != 0
     for: 15m
     labels:
      severity: warning
      type: ses_default
     annotations:
      description: Ceph not healthy for > 5m
  - name: mon
   rules:
    - alert: low monitor quorum count
     expr: ceph_monitor_quorum_count &lt; 3
     labels:
      severity: critical
      type: ses_default
     annotations:
      description: Monitor count in quorum is low
  - name: osd
   rules:
    - alert: 10% OSDs down
     expr: sum(ceph_osd_down) / count(ceph_osd_in) >= 0.1
     labels:
      severity: critical
      type: ses_default
     annotations:
      description: More then 10% of OSDS are down
    - alert: OSD down
     expr: sum(ceph_osd_down) > 1
     for: 15m
     labels:
      severity: warning
      type: ses_default
     annotations:
      description: One or more OSDS down for more then 15 minutes
    - alert: OSDs near full
     expr: (ceph_osd_utilization unless on(osd) ceph_osd_down) > 80
     labels:
      severity: critical
      type: ses_default
     annotations:
      description: OSD {{ $labels.osd }} is dangerously full, over 80%
    # alert on single OSDs flapping
    - alert: flap osd
     expr: rate(ceph_osd_up[5m])*60 > 1
     labels:
      severity: warning
      type: ses_default
     annotations:
      description: >
        OSD {{ $label.osd }} was marked down at back up at least once a
        minute for 5 minutes.
    # alert on high deviation from average PG count
    - alert: high pg count deviation
     expr: abs(((ceph_osd_pgs > 0) - on (job) group_left avg(ceph_osd_pgs > 0) by (job)) / on (job) group_left avg(ceph_osd_pgs > 0) by (job)) > 0.35
     for: 5m
     labels:
      severity: warning
      type: ses_default
     annotations:
      description: >
        OSD {{ $labels.osd }} deviates by more then 30% from
        average PG count
    # alert on high commit latency...but how high is too high
  - name: mds
   rules:
   # no mds metrics are exported yet
  - name: mgr
   rules:
   # no mgr metrics are exported yet
  - name: pgs
   rules:
    - alert: pgs inactive
     expr: ceph_total_pgs - ceph_active_pgs > 0
     for: 5m
     labels:
      severity: critical
      type: ses_default
     annotations:
      description: One or more PGs are inactive for more then 5 minutes.
    - alert: pgs unclean
     expr: ceph_total_pgs - ceph_clean_pgs > 0
     for: 15m
     labels:
      severity: warning
      type: ses_default
     annotations:
      description: One or more PGs are not clean for more then 15 minutes.
  - name: nodes
   rules:
    - alert: root volume full
     expr: node_filesystem_avail{mountpoint="/"} / node_filesystem_size{mountpoint="/"} &lt; 0.1
     labels:
      severity: critical
      type: ses_default
     annotations:
      description: Root volume (OSD and MON store) is dangerously full (&lt; 10% free)
    # alert on nic packet errors and drops rates > 1 packet/s
    - alert: network packets dropped
     expr: irate(node_network_receive_drop{device!="lo"}[5m]) + irate(node_network_transmit_drop{device!="lo"}[5m]) > 1
     labels:
      severity: warning
      type: ses_default
     annotations:
      description: >
       Node {{ $labels.instance }} experiences packet drop > 1
       packet/s on interface {{ $lables.device }}
    - alert: network packet errors
     expr: irate(node_network_receive_errs{device!="lo"}[5m]) + irate(node_network_transmit_errs{device!="lo"}[5m]) > 1
     labels:
      severity: warning
      type: ses_default
     annotations:
      description: >
       Node {{ $labels.instance }} experiences packet errors > 1
       packet/s on interface {{ $lables.device }}
    # predict fs fillup times
    - alert: storage filling
     expr: ((node_filesystem_free - node_filesystem_size) / deriv(node_filesystem_free[2d]) &lt;= 5) > 0
     labels:
      severity: warning
      type: ses_default
     annotations:
      description: >
       Mountpoint {{ $lables.mountpoint }} will be full in less then 5 days
       assuming the average fillup rate of the past 48 hours.
  - name: pools
   rules:
    - alert: pool full
     expr: ceph_pool_used_bytes / ceph_pool_available_bytes > 0.9
     labels:
      severity: critical
      type: ses_default
     annotations:
      description: Pool {{ $labels.pool }} at 90% capacity or over
    - alert: pool filling up
     expr: (-ceph_pool_used_bytes / deriv(ceph_pool_available_bytes[2d]) &lt;= 5 ) > 0
     labels:
      severity: warning
      type: ses_default
     annotations:
      description: >
       Pool {{ $labels.pool }} will be full in less then 5 days
       assuming the average fillup rate of the past 48 hours.
 </screen>
</chapter>
