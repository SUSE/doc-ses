<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="deployment_ganesha.xml" version="5.0" xml:id="cha.as.ganesha">

 <title>Instalação do NFS Ganesha</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:maintainer>tbazant@suse.com</dm:maintainer>
        <dm:status>editando</dm:status>
        <dm:deadline/>
        <dm:priority/>
        <dm:translation>yes (sim)</dm:translation>
        <dm:languages/>
        <dm:release>SES 5</dm:release>
      </dm:docmanager>
    </info>
    <para>
  O NFS Ganesha concede acesso de NFS ao Object Gateway ou CephFS. No SUSE Enterprise Storage 5, as versões 3 e 4 do NFS são suportadas. O NFS Ganesha é executado no espaço do usuário, em vez do kernel, e interage diretamente com o Object Gateway ou o CephFS.
 </para>
 <sect1 xml:id="sec.as.ganesha.preparation">
  <title>Preparação</title>

  <sect2 xml:id="sec.as.ganesha.preparation.general">
   <title>Informações Gerais</title>
   <para>
    Para implantar o NFS Ganesha com êxito, você precisa adicionar uma função <literal>role-ganesha</literal> ao <filename>/srv/pillar/ceph/proposals/policy.cfg</filename>. Para obter os detalhes, consulte a <xref linkend="policy.configuration"/>. O NFS Ganesha também precisa da <literal>role-rgw</literal> ou da <literal>role-mds</literal> no <filename>policy.cfg</filename>.
   </para>
   <para>
    Embora seja possível instalar e executar o servidor NFS Ganesha em um nó do Ceph existente, é recomendável executá-lo em um host dedicado com acesso ao cluster do Ceph. Normalmente, os hosts de clientes não fazem parte do cluster, mas eles precisam ter acesso via rede ao servidor NFS Ganesha.
   </para>
   <para>
    Para habilitar o servidor NFS Ganesha a qualquer momento após a instalação inicial, adicione a <literal>role-ganesha</literal> ao <filename>policy.cfg</filename> e reexecute pelo menos as fases 2 e 4 do DeepSea. Para obter os detalhes, consulte a <xref linkend="ceph.install.stack"/>.
   </para>
   <para>
    O NFS Ganesha é configurado por meio do arquivo <filename>/etc/ganesha/ganesha.conf</filename> que existe no nó do NFS Ganesha. No entanto, esse arquivo é sobregravado toda vez que a fase 4 do DeepSea é executada. Portanto, recomendamos editar o gabarito usado pelo Salt, que é o arquivo <filename>/srv/salt/ceph/ganesha/files/ganesha.conf.j2</filename> no master Salt. Para obter detalhes sobre o arquivo de configuração, consulte o <xref linkend="ceph.nfsganesha.config"/>.
   </para>
  </sect2>

  <sect2 xml:id="sec.as.ganesha.preparation.requirements">
   <title>Resumo dos requisitos</title>
   <para>
    Os seguintes requisitos devem ser atendidos antes da execução das fases 2 e 4 do DeepSea para instalar o NFS Ganesha:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      No mínimo, um nó precisa receber a função <literal>role-ganesha</literal>.
     </para>
    </listitem>
    <listitem>
     <para>
      Você pode definir apenas uma <literal>role-ganesha</literal> por minion.
     </para>
    </listitem>
    <listitem>
     <para>
      O NFS Ganesha precisa de um Object Gateway ou CephFS para funcionar.
     </para>
    </listitem>
    <listitem>
     <para>
      Se o NFS Ganesha tiver que usar o Object Gateway para estabelecer interface com o cluster, o <filename>/srv/pillar/ceph/rgw.sls</filename> no master Salt deverá ser preenchido.
     </para>
    </listitem>
   </itemizedlist>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.as.ganesha.basic_example">
  <title>Exemplo de instalação</title>

  <para>
   Este procedimento fornece um exemplo de instalação que usa as FSAL (File System Abstraction Layers – Camadas de Abstração do Sistema de Arquivos) do Object Gateway e do CephFS do NFS Ganesha.
  </para>

  <procedure>
   <step>
    <para>
     Se você não fez isto, execute as fases 0 e 1 do DeepSea antes de continuar esse procedimento.
    </para>
<screen><prompt>root # </prompt><command>salt-run</command> state.orch ceph.stage.0
<prompt>root # </prompt><command>salt-run</command> state.orch ceph.stage.1</screen>
   </step>
   <step>
    <para>
     Após executar a fase 1 do DeepSea, edite o <filename>/srv/pillar/ceph/proposals/policy.cfg</filename> e adicione a linha
    </para>
<screen>role-ganesha/cluster/<replaceable>NODENAME</replaceable></screen>
    <para>
     Substitua <replaceable>NODENAME</replaceable> pelo nome de um nó no cluster.
    </para>
    <para>
     Verifique também se uma <literal>role-mds</literal> e uma <literal>role-rgw</literal> foram atribuídas.
    </para>
   </step>
   <step>
    <para>
     Crie o arquivo <filename>/srv/pillar/ceph/rgw.sls</filename> e insira o seguinte conteúdo:
    </para>
<screen>rgw_configurations:
  rgw:
    users:
      - { uid: "demo", name: "Demo", email: "demo@demo.nil" }
      - { uid: "demo1", name: "Demo1", email: "demo1@demo.nil" }</screen>
    <para>
     Posteriormente, esses usuários serão criados como usuários do Object Gateway, e as chaves de API serão geradas. No nó do Object Gateway, você pode depois executar <command>radosgw-admin user list</command> para listar todos os usuários criados, e <command>radosgw-admin user info --uid=demo</command> para obter detalhes sobre usuários únicos.
    </para>
    <para>
     O DeepSea garante que tanto o Object Gateway quanto o NFS Ganesha recebam as credenciais de todos os usuários listados na seção <literal>rgw</literal> do <filename>rgw.sls</filename>.
    </para>
    <para>
     O NFS exportado usa esses nomes de usuário no primeiro nível do sistema de arquivos. Neste exemplo, os caminhos <filename>/demo</filename> e <filename>/demo1</filename> serão exportados.
    </para>
   </step>
   <step>
    <para>
     Execute pelo menos as fases 2 e 4 do DeepSea. É recomendável executar a fase 3 entre elas.
    </para>
<screen><prompt>root # </prompt><command>salt-run</command> state.orch ceph.stage.2
<prompt>root # </prompt><command>salt-run</command> state.orch ceph.stage.3 # optional but recommended
<prompt>root # </prompt><command>salt-run</command> state.orch ceph.stage.4</screen>
   </step>
   <step>
    <para>
     Monte o compartilhamento NFS de um nó de cliente para verificar se o NFS Ganesha está funcionando:
    </para>
<screen><prompt>root # </prompt><command>mount</command> -o sync -t nfs <replaceable>GANESHA_NODE</replaceable>:/ /mnt
<prompt>root # </prompt><command>ls</command> /mnt
cephfs  demo  demo1</screen>
    <para>
     O <filename>/mnt</filename> deve conter todos os caminhos exportados. Os diretórios para o CephFS e ambos os usuários do Object Gateway devem existir. Para cada compartimento de memória que um usuário possui, um caminho <filename>/mnt/<replaceable>USERNAME</replaceable>/<replaceable>BUCKETNAME</replaceable></filename> é exportado.
    </para>
   </step>
  </procedure>
 </sect1>
 <sect1 xml:id="sec.as.ganesha.ha-ap">
  <title>Configuração ativa-passiva de alta disponibilidade</title>

  <para>
   Esta seção apresenta um exemplo de como definir uma configuração ativa-passiva de dois nós dos servidores NFS Ganesha. A configuração requer a SUSE Linux Enterprise High Availability Extension. Os dois nós são denominados <systemitem class="domainname">earth</systemitem> e <systemitem class="domainname">mars</systemitem>.
  </para>

  <para>
   Para obter detalhes sobre a SUSE Linux Enterprise High Availability Extension, consulte <link xlink:href="https://www.suse.com/documentation/sle-ha-12/"/>.
  </para>

  <sect2 xml:id="sec.as.ganesha.ha-ap.basic">
   <title>Instalação básica</title>
   <para>
    Nessa configuração, <systemitem class="domainname">earth</systemitem> tem o endereço IP <systemitem class="ipaddress">192.168.1.1</systemitem>, e <systemitem class="domainname">mars</systemitem> tem o endereço <systemitem class="ipaddress">192.168.1.2</systemitem>.
   </para>
   <para>
    Além disso, dois endereços IP virtuais flutuantes são usados, permitindo aos clientes se conectarem ao serviço independentemente do nó físico no qual está sendo executado. <systemitem class="ipaddress">192.168.1.10</systemitem> é usado para administração do cluster com Hawk2, e <systemitem class="ipaddress">192.168.2.1</systemitem> é usado exclusivamente para exportações NFS. Isso facilita aplicar as restrições de segurança mais tarde.
   </para>
   <para>
    O procedimento a seguir descreve a instalação de exemplo. Mais detalhes podem ser encontrados em <link xlink:href="https://www.suse.com/documentation/sle-ha-12/install-quick/data/install-quick.html"/>.
   </para>
   <procedure xml:id="proc.as.ganesha.ha-ap">
    <step>
     <para>
      Prepare os nós do NFS Ganesha no master Salt:
     </para>
     <substeps>
      <step>
       <para>
        Execute as fases 0 e 1 do DeepSea no master Salt.
       </para>
<screen>
<prompt>root@master # </prompt><command>salt-run</command> state.orch ceph.stage.0
<prompt>root@master # </prompt><command>salt-run</command> state.orch ceph.stage.1
</screen>
      </step>
      <step>
       <para>
        Atribua aos nós <systemitem class="domainname">earth</systemitem> e <systemitem class="domainname">mars</systemitem> a função <literal>role-ganesha</literal> em <filename>/srv/pillar/ceph/proposals/policy.cfg</filename>:
       </para>
<screen>role-ganesha/cluster/earth*.sls
role-ganesha/cluster/mars*.sls</screen>
      </step>
      <step>
       <para>
        Execute as fases 3 e 4 do DeepSea no master Salt.
       </para>
<screen><prompt>root@master # </prompt><command>salt-run</command> state.orch ceph.stage.3
<prompt>root@master # </prompt><command>salt-run</command> state.orch ceph.stage.4</screen>
      </step>
     </substeps>
    </step>
    <step>
     <para>
      Registre a SUSE Linux Enterprise High Availability Extension no <systemitem class="domainname">earth</systemitem> e no <systemitem class="domainname">mars</systemitem>.
     </para>
<screen>
<prompt>root # </prompt><command>SUSEConnect</command> -r <replaceable>ACTIVATION_CODE</replaceable> -e <replaceable>E_MAIL</replaceable>
</screen>
    </step>
    <step>
     <para>
      Instale o <package>ha-cluster-bootstrap</package> em ambos os nós:
     </para>
<screen><prompt>root # </prompt><command>zypper</command> in ha-cluster-bootstrap</screen>
    </step>
    <step>
     <substeps>
      <step>
       <para>
        Inicialize o cluster no <systemitem class="domainname">earth</systemitem>:
       </para>
<screen><prompt>root@earth # </prompt><command>ha-cluster-init</command></screen>
      </step>
      <step>
       <para>
        Permita que o <systemitem class="domainname">mars</systemitem> ingresse no cluster:
       </para>
<screen><prompt>root@mars # </prompt><command>ha-cluster-join</command> -c earth</screen>
      </step>
     </substeps>
    </step>
    <step>
     <para>
      Verifique o status do cluster. Você deve ver dois nós adicionados ao cluster:
     </para>
<screen><prompt>root@earth # </prompt><command>crm</command> status</screen>
    </step>
    <step>
     <para>
      Em ambos os nós, desabilite o início automático do serviço NFS Ganesha no momento da inicialização:
     </para>
<screen><prompt>root # </prompt><command>systemctl</command> disable nfs-ganesha</screen>
    </step>
    <step>
     <para>
      Inicie o shell do <command>crm</command> no <systemitem class="domainname">earth</systemitem>:
     </para>
<screen><prompt>root@earth # </prompt><command>crm</command> configure</screen>
     <para>
      Os próximos comandos são executados no shell do crm.
     </para>
    </step>
    <step>
     <para>
      No <systemitem class="domainname">earth</systemitem>, execute o shell do crm para executar os comandos a seguir a fim de configurar o recurso nos daemons do NFS Ganesha como clone do tipo de recurso systemd:
     </para>
<screen>
<prompt>crm(live)configure# </prompt>primitive nfs-ganesha-server systemd:nfs-ganesha \
op monitor interval=30s
<prompt>crm(live)configure# </prompt>clone nfs-ganesha-clone nfs-ganesha-server meta interleave=true
<prompt>crm(live)configure# </prompt>commit
<prompt>crm(live)configure# </prompt>status
    2 nodes configured
    2 resources configured

    Online: [ earth mars ]

    Full list of resources:
         Clone Set: nfs-ganesha-clone [nfs-ganesha-server]
         Started:  [ earth mars ]</screen>
    </step>
    <step>
     <para>
      Crie um IPAddr2 primitivo com o shell do crm:
     </para>
<screen>
<prompt>crm(live)configure# </prompt>primitive ganesha-ip IPaddr2 \
params ip=192.168.2.1 cidr_netmask=24 nic=eth0 \
op monitor interval=10 timeout=20

<prompt>crm(live)# </prompt>status
Online: [ earth mars  ]
Full list of resources:
 Clone Set: nfs-ganesha-clone [nfs-ganesha-server]
     Started: [ earth mars ]
 ganesha-ip    (ocf::heartbeat:IPaddr2):    Started earth</screen>
    </step>
    <step>
     <para>
      Para configurar um relacionamento entre o servidor NFS Ganesha e o IP Virtual flutuante, usamos colocalização e ordenação.
     </para>
<screen>
<prompt>crm(live)configure# </prompt>colocation ganesha-ip-with-nfs-ganesha-server inf: ganesha-ip nfs-ganesha-clone
<prompt>crm(live)configure# </prompt>order ganesha-ip-after-nfs-ganesha-server Mandatory: nfs-ganesha-clone ganesha-ip
</screen>
    </step>
    <step>
     <para>
      Use o comando <command>mount</command> do cliente para garantir que a configuração do cluster foi concluída:
     </para>
<screen><prompt>root # </prompt><command>mount</command> -t nfs -v -o sync,nfsvers=4 192.168.2.1:/ /mnt</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="sec.as.ganesha.ha-ap.cleanup">
   <title>Limpar recursos</title>
   <para>
    Em caso de falha em um dos nós do NFS Ganesha (por exemplo, <systemitem class="domainname">earth</systemitem>), corrija o problema e limpe o recurso. Apenas depois que o recurso estiver limpo, será possível fazer failback dele para o <systemitem class="domainname">earth</systemitem>, caso haja falha no <systemitem class="domainname">mars</systemitem> do NFS Ganesha.
   </para>
   <para>
    Para limpar o recurso:
   </para>
<screen><prompt>root@earth # </prompt><command>crm</command> resource cleanup nfs-ganesha-clone earth
<prompt>root@earth # </prompt><command>crm</command> resource cleanup ganesha-ip earth</screen>
  </sect2>

  <sect2 xml:id="sec.as.ganesha.ha-ap.ping-resource">
   <title>Configurando o recurso de ping</title>
   <para>
    Pode acontecer de um servidor não conseguir acessar o cliente por causa de um problema de rede. Um recurso de ping pode detectar e minimizar esse problema. A configuração desse recurso é opcional.
   </para>
   <procedure>
    <step>
     <para>
      Defina o recurso de ping:
     </para>
<screen><prompt>crm(live)configure# </prompt>primitive ganesha-ping ocf:pacemaker:ping \
        params name=ping dampen=3s multiplier=100 host_list="<replaceable>CLIENT1</replaceable> <replaceable>CLIENT2</replaceable>" \
        op monitor interval=60 timeout=60 \
        op start interval=0 timeout=60 \
        op stop interval=0 timeout=60</screen>
     <para>
      <literal>host_list</literal> é uma lista de endereços IP separados por caracteres de espaço. Será feito ping regular dos endereços IP para verificar se há interrupções de rede. Se um cliente sempre precisar de acesso ao servidor NFS, adicione-o à <literal>host_list</literal>.
     </para>
    </step>
    <step>
     <para>
      Crie um clone:
     </para>
<screen><prompt>crm(live)configure# </prompt>clone ganesha-ping-clone ganesha-ping \
        meta interleave=true</screen>
    </step>
    <step>
     <para>
      O comando a seguir cria uma restrição para o serviço NFS Ganesha. Ele força o serviço a se mover para outro nó quando a <literal>host_list</literal> está inacessível.
     </para>
<screen><prompt>crm(live)configure# </prompt>location nfs-ganesha-server-with-ganesha-ping
        nfs-ganesha-clone \
        rule -inf: not_defined ping or ping lte 0</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="ganesha_ha_deepsea">
   <title>HA do NFS Ganesha e DeepSea</title>
   <para>
    O DeepSea não oferece suporte à configuração de HA do NFS Ganesha. Para evitar falha no DeepSea após a configuração de HA do NFS Ganesha, exclua a inicialização e interrupção do serviço NFS Ganesha da Fase 4 do DeepSea:
   </para>
   <procedure>
    <step>
     <para>
      Copie <filename>/srv/salt/ceph/ganesha/default.sls</filename> para <filename>/srv/salt/ceph/ganesha/ha.sls</filename>.
     </para>
    </step>
    <step>
     <para>
      Remova a entrada <literal>.service</literal> do <filename>/srv/salt/ceph/ganesha/ha.sls</filename> de modo que fique com esta aparência:
     </para>
<screen>include:
- .keyring
- .install
- .configure</screen>
    </step>
    <step>
     <para>
      Adicione a seguinte linha a <filename>/srv/pillar/ceph/stack/global.yml</filename>:
     </para>
<screen>ganesha_init: ha</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="sec.as.ganesha.info">
  <title>Mais informações</title>

  <para>
   Mais informações podem ser encontradas no <xref linkend="cha.ceph.nfsganesha"/>.
  </para>
 </sect1>
</chapter>
