<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="admin_ceph_gateway.xml" version="5.0" xml:id="cha-ceph-gw">

 <title>Ceph Object Gateway</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:maintainer>tbazant@suse.com</dm:maintainer>
   <dm:status>editando</dm:status>
   <dm:deadline/>
   <dm:priority/>
   <dm:translation>yes (sim)</dm:translation>
   <dm:languages/>
   <dm:release>SES 6</dm:release>
  </dm:docmanager>
 </info>
 <para>
  Este capítulo apresenta detalhes sobre as tarefas de administração relacionadas ao Object Gateway, como verificação de status do serviço, gerenciamento de contas, gateways multissite ou autenticação LDAP.
 </para>
 <sect1 xml:id="sec-ceph-rgw-limits">
  <title>Restrições e limitações de nomeação do Object Gateway</title>

  <para>
   Veja a seguir uma lista dos limites importantes do Object Gateway:
  </para>

  <sect2 xml:id="ogw-limits-bucket">
   <title>Limitações de compartimento de memória</title>
   <para>
    Ao usar o Object Gateway por meio da API do S3, há um limite para os nomes de compartimento de memória que devem ser compatíveis com DNS e podem ter um traço “-”. Ao usar o Object Gateway por meio da API do Swift, você pode aplicar qualquer combinação de caracteres UTF-8 permitidos, exceto a barra “/”. O tamanho máximo do nome de um compartimento de memória é de 255 caracteres. Os nomes de compartimento de memória devem ser exclusivos.
   </para>
   <tip>
    <title>Usar nomes de compartimento de memória compatíveis com DNS</title>
    <para>
     Embora seja possível usar qualquer nome de compartimento de memória baseado em UTF-8 por meio da API do Swift, é recomendável nomear os compartimentos de memória de acordo com as limitações de nomeação do S3 para evitar problemas ao acessar o mesmo compartimento de memória pela API do S3.
    </para>
   </tip>
  </sect2>

  <sect2 xml:id="ogw-limits-object">
   <title>Limitações de objetos armazenados</title>
   <variablelist>
    <varlistentry>
     <term>Número máximo de objetos por usuário</term>
     <listitem>
      <para>
       Por padrão, nenhuma restrição (limitado por ~ 2^63).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Número máximo de objetos por compartimento de memória</term>
     <listitem>
      <para>
       Por padrão, nenhuma restrição (limitado por ~ 2^63).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Tamanho máximo de um objeto para upload/armazenamento</term>
     <listitem>
      <para>
       Cada upload está restrito a 5 GB. Use várias partes para tamanhos de objetos maiores. O número máximo de pacotes de várias partes é 10.000.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="ogw-limits-http">
   <title>Limitações de cabeçalho HTTP</title>
   <para>
    A limitação de cabeçalho HTTP e de solicitação depende do front end da Web usado. O Beast padrão restringe o tamanho do cabeçalho HTTP a 16 kB.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-deploy">
  <title>Implantando o Object Gateway</title>

  <para>
   O método recomendado de implantação do Ceph Object Gateway é pela infraestrutura do DeepSea, adicionando a(s) linha(s) <literal>role-rgw [...]</literal> relevante(s) ao arquivo <filename>policy.cfg</filename> no master Salt e executando as fases necessárias do DeepSea.
  </para>

  <itemizedlist>
   <listitem>
    <para>
     Para incluir o Object Gateway durante o processo de implantação do cluster do Ceph, consulte o <xref linkend="ceph-install-stack"/> e o <xref linkend="policy-configuration"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     Para adicionar a função Object Gateway a um cluster já implantado, consulte a <xref linkend="salt-adding-services"/>.
    </para>
   </listitem>
  </itemizedlist>
 </sect1>
 <sect1 xml:id="ceph-rgw-operating">
  <title>Operando o serviço Object Gateway</title>

  <para>
   O serviço do Object Gateway é operado com o comando <command>systemctl</command>. Você precisa ter privilégios de <systemitem class="username">root</systemitem> para operar o serviço Object Gateway. Observe que <replaceable>GATEWAY_HOST</replaceable> é o nome de host do servidor cuja instância do Object Gateway você precisa operar.
  </para>

  <para>
   Os subcomandos a seguir são suportados para o serviço Object Gateway:
  </para>

  <variablelist>
   <varlistentry>
    <term>systemctl status ceph-radosgw@rgw.<replaceable>GATEWAY_HOST</replaceable></term>
    <listitem>
     <para>
      Imprime as informações de status do serviço
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>systemctl start ceph-radosgw@rgw.<replaceable>GATEWAY_HOST</replaceable></term>
    <listitem>
     <para>
      Inicia o serviço caso ainda não esteja em execução.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>systemctl restart ceph-radosgw@rgw.<replaceable>GATEWAY_HOST</replaceable></term>
    <listitem>
     <para>
      Reinicia o serviço.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>systemctl stop ceph-radosgw@rgw.<replaceable>GATEWAY_HOST</replaceable></term>
    <listitem>
     <para>
      Para o serviço em execução.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>systemctl enable ceph-radosgw@rgw.<replaceable>GATEWAY_HOST</replaceable></term>
    <listitem>
     <para>
      Habilita o serviço para que ele seja iniciado automaticamente na inicialização do sistema.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>systemctl disable ceph-radosgw@rgw.<replaceable>GATEWAY_HOST</replaceable></term>
    <listitem>
     <para>
      Desabilita o serviço para que ele não seja iniciado automaticamente na inicialização do sistema.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="ogw-config-parameters">
  <title>Opções de configuração</title>

  <para>
   Consulte a <xref linkend="config-ogw"/> para ver uma lista de opções de configuração do Object Gateway.
  </para>
 </sect1>
 <sect1 xml:id="ceph-rgw-access">
  <title>Gerenciando o acesso ao Object Gateway</title>

  <para>
   Você pode se comunicar com o Object Gateway usando qualquer interface compatível com S3 ou Swift. A interface do S3 é compatível com um grande subconjunto da API RESTful do Amazon S3. A interface do Swift é compatível com um grande subconjunto da API do OpenStack Swift.
  </para>

  <para>
   As duas interfaces exigem que você crie um usuário específico e instale o software cliente relevante para comunicação com o gateway usando a chave secreta do usuário.
  </para>

  <sect2 xml:id="accessing-ragos-gateway">
   <title>Acessando o Object Gateway</title>
   <sect3>
    <title>Acesso à interface do S3</title>
    <para>
     Para acessar a interface do S3, você precisa de um cliente REST. <command>S3cmd</command> é um cliente S3 de linha de comando. Você pode encontrá-lo em <link xlink:href="https://build.opensuse.org/package/show/Cloud:Tools/s3cmd">OpenSUSE Build Service</link>. O repositório contém as versões para ambas as distribuições baseadas no SUSE Linux Enterprise e no openSUSE.
    </para>
    <para>
     Para testar o acesso à interface do S3, você também pode gravar um pequeno script do Python. O script se conectará ao Object Gateway, criará um novo compartimento de memória e listará todos os compartimentos de memória. Os valores para <option>aws_access_key_id</option> e <option>aws_secret_access_key</option> são extraídos dos valores de <option>access_key</option> e <option>secret_key</option> retornados pelo comando <command>radosgw_admin</command> da <xref linkend="adding-s3-swift-users"/>.
    </para>
    <procedure>
     <step>
      <para>
       Instale o pacote <systemitem>python-boto</systemitem>:
      </para>
<screen><prompt>root # </prompt>zypper in python-boto</screen>
     </step>
     <step>
      <para>
       Crie um novo script do Python denominado <filename>s3test.py</filename> com o seguinte conteúdo: <remark role="fixme">Provide script in RPM? Is it really necessary to create pool? This script is not necessary at all, remove it from documentation?</remark>
      </para>
<screen>import boto
import boto.s3.connection
access_key = '11BS02LGFB6AL6H1ADMW'
secret_key = 'vzCEkuryfn060dfee4fgQPqFrncKEIkh3ZcdOANY'
conn = boto.connect_s3(
aws_access_key_id = access_key,
aws_secret_access_key = secret_key,
host = '<replaceable>HOSTNAME</replaceable>',
is_secure=False,
calling_format = boto.s3.connection.OrdinaryCallingFormat(),
)
bucket = conn.create_bucket('my-new-bucket')
for bucket in conn.get_all_buckets():
  print "<replaceable>NAME</replaceable>\t<replaceable>CREATED</replaceable>".format(
  name = bucket.name,
  created = bucket.creation_date,
  )</screen>
      <para>
       Substitua <literal><replaceable>HOSTNAME</replaceable></literal> pelo nome de host no qual você configurou o serviço do Object Gateway. Por exemplo, <literal>gateway_host</literal>.
      </para>
     </step>
     <step>
      <para>
       Execute o script:
      </para>
<screen>python s3test.py</screen>
      <para>
       A saída do script é parecida com o seguinte:
      </para>
<screen>my-new-bucket 2015-07-22T15:37:42.000Z</screen>
     </step>
    </procedure>
   </sect3>
   <sect3>
    <title>Acesso à interface do Swift</title>
    <para>
     Para acessar o Object Gateway pela interface do Swift, você precisa do cliente de linha de comando <command>swift</command>. A página de manual dele <command>man 1 swift</command> apresenta mais detalhes sobre as opções de linha de comando.
    </para>
    <para>
     O pacote está incluído no módulo “Public Cloud” para o SUSE Linux Enterprise 12 a partir do SP3 e o SUSE Linux Enterprise 15. Antes de instalar o pacote, você precisa ativar o módulo e atualizar o repositório de software:
    </para>
<screen><prompt>root # </prompt>SUSEConnect -p sle-module-public-cloud/12/x86_64
sudo zypper refresh</screen>
    <para>
     Ou
    </para>
<screen><prompt>root # </prompt>SUSEConnect -p sle-module-public-cloud/15/x86_64
<prompt>root # </prompt>zypper refresh</screen>
    <para>
     Para instalar o comando <command>swift</command>, execute o seguinte:
    </para>
<screen><prompt>root # </prompt>zypper in python-swiftclient</screen>
    <para>
     O acesso ao swift usa a seguinte sintaxe:
    </para>
<screen><prompt>tux &gt; </prompt>swift -A http://<replaceable>IP_ADDRESS</replaceable>/auth/1.0 \
-U example_user:swift -K '<replaceable>SWIFT_SECRET_KEY</replaceable>' list</screen>
    <para>
     Substitua <replaceable>IP_ADDRESS</replaceable> pelo endereço IP do servidor gateway, e <replaceable>SWIFT_SECRET_KEY</replaceable> pelo respectivo valor da saída do comando <command>radosgw-admin key create</command> executado para o usuário <systemitem>swift</systemitem> na <xref linkend="adding-s3-swift-users"/>.
    </para>
    <para>
     Por exemplo:
    </para>
<screen><prompt>tux &gt; </prompt>swift -A http://gateway.example.com/auth/1.0 -U example_user:swift \
-K 'r5wWIxjOCeEO7DixD1FjTLmNYIViaC6JVhi3013h' list</screen>
    <para>
     A saída é:
    </para>
<screen>my-new-bucket</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="s3-swift-accounts-managment">
   <title>Gerenciando contas do S3 e do Swift</title>
   <sect3 xml:id="adding-s3-swift-users">
    <title>Adicionando usuários do S3 e do Swift</title>
    <para>
     É necessário criar um usuário, uma chave de acesso e um segredo para permitir que os usuários finais interajam com o gateway. Há dois tipos de usuário: <emphasis>usuário</emphasis> e <emphasis>subusuário</emphasis>. Os <emphasis>usuários</emphasis> são usados para interagir com a interface do S3, os <emphasis>subusuários</emphasis> são usuáros da interface do Swift. Cada subusuário está associado a um usuário.
    </para>
    <para>
     Os usuários também podem ser adicionados por meio do arquivo <filename>rgw.sls</filename> do DeepSea. Para obter um exemplo, consulte a <xref linkend="ceph-nfsganesha-customrole-rgw-multiusers"/>.
    </para>
    <para>
     Para criar um usuário do Swift, siga as etapas:
    </para>
    <procedure>
     <step>
      <para>
       Para criar um usuário do Swift, que é um <emphasis>subusuário</emphasis> em nossa terminologia, você precisa criar primeiro o <emphasis>usuário</emphasis> associado.
      </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin user create --uid=<replaceable>USERNAME</replaceable> \
 --display-name="<replaceable>DISPLAY-NAME</replaceable>" --email=<replaceable>EMAIL</replaceable></screen>
      <para>
       Por exemplo:
      </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin user create \
   --uid=example_user \
   --display-name="Example User" \
   --email=penguin@example.com</screen>
     </step>
     <step>
      <para>
       Para criar um subusuário (interface do Swift) para o usuário, você deve especificar o ID de usuário (--uid=<replaceable>USERNAME</replaceable>), um ID de subusuário e o nível de acesso para o subusuário.
      </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin subuser create --uid=<replaceable>UID</replaceable> \
 --subuser=<replaceable>UID</replaceable> \
 --access=[ <replaceable>read | write | readwrite | full</replaceable> ]</screen>
      <para>
       Por exemplo:
      </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin subuser create --uid=example_user \
 --subuser=example_user:swift --access=full</screen>
     </step>
     <step>
      <para>
       Gere uma chave secreta para o usuário.
      </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin key create \
   --gen-secret \
   --subuser=example_user:swift \
   --key-type=swift</screen>
     </step>
     <step>
      <para>
       Os dois comandos resultarão em dados formatados em JSON que mostram o estado do usuário. Observe as linhas a seguir e lembre-se do valor <literal>secret_key</literal>:
      </para>
<screen>"swift_keys": [
   { "user": "example_user:swift",
     "secret_key": "r5wWIxjOCeEO7DixD1FjTLmNYIViaC6JVhi3013h"}],</screen>
     </step>
    </procedure>
    <para/>
    <para>
     Ao acessar o Object Gateway por meio da interface do S3, você precisa criar um usuário do S3 executando:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin user create --uid=<replaceable>USERNAME</replaceable> \
 --display-name="<replaceable>DISPLAY-NAME</replaceable>" --email=<replaceable>EMAIL</replaceable></screen>
    <para>
     Por exemplo:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin user create \
   --uid=example_user \
   --display-name="Example User" \
   --email=penguin@example.com</screen>
    <para>
     O comando também cria o acesso do usuário e a chave secreta. Verifique a saída para as palavras-chave <literal>access_key</literal> e <literal>secret_key</literal> e seus valores:
    </para>
<screen>[...]
 "keys": [
       { "user": "example_user",
         "access_key": "11BS02LGFB6AL6H1ADMW",
         "secret_key": "vzCEkuryfn060dfee4fgQPqFrncKEIkh3ZcdOANY"}],
 [...]</screen>
   </sect3>
   <sect3 xml:id="removing-s3-swift-users">
    <title>Removendo usuários do S3 e do Swift</title>
    <para>
     O procedimento para apagar usuários é semelhante para os usuários do S3 e do Swift. No caso dos usuários do Swift, porém, você pode precisar apagar o usuário com os subusuários incluídos.
    </para>
    <para>
     Para remover um usuário do S3 ou do Swift (incluindo todos os subusuários), especifique <option>user rm</option> e o ID de usuário no seguinte comando:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin user rm --uid=example_user</screen>
    <para>
     Para remover um subusuário, especifique <option>subuser rm</option> e o ID de subusuário.
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin subuser rm --uid=example_user:swift</screen>
    <para>
     Você pode usar as seguintes opções:
    </para>
    <variablelist>
     <varlistentry>
      <term>--purge-data</term>
      <listitem>
       <para>
        Purga todos os dados associados ao ID de usuário.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--purge-keys</term>
      <listitem>
       <para>
        Purga todas as chaves associadas ao ID de usuário.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <tip>
     <title>Removendo um subusuário</title>
     <para>
      Ao remover um subusuário, você remove o acesso à interface do Swift. O usuário permanecerá no sistema.
     </para>
    </tip>
   </sect3>
   <sect3 xml:id="changing-s3-swift-users-password">
    <title>Mudando o acesso e as chaves secretas do usuário do S3 e do Swift</title>
    <para>
     Os parâmetros <literal>access_key</literal> e <literal>secret_key</literal> identificam o usuário do Object Gateway ao acessar o gateway. A mudança das chaves existentes de usuário é o mesmo que criar novas chaves, pois as chaves antigas são sobregravadas.
    </para>
    <para>
     Para usuários do S3, execute o seguinte:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin key create --uid=<replaceable>EXAMPLE_USER</replaceable> --key-type=s3 --gen-access-key --gen-secret</screen>
    <para>
     Para usuários do Swift, execute o seguinte:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin key create --subuser=<replaceable>EXAMPLE_USER</replaceable>:swift --key-type=swift --gen-secret</screen>
    <variablelist>
     <varlistentry>
      <term><option>--key-type=<replaceable>TYPE</replaceable></option></term>
      <listitem>
       <para>
        Especifica o tipo de chave. Pode ser <literal>swift</literal> ou <literal>s3</literal>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--gen-access-key</option></term>
      <listitem>
       <para>
        Gera uma chave de acesso aleatória (por padrão, para o usuário do S3).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--gen-secret</option></term>
      <listitem>
       <para>
        Gera uma chave secreta aleatória.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--secret=<replaceable>KEY</replaceable></option></term>
      <listitem>
       <para>
        Especifica uma chave secreta. Por exemplo, gerada manualmente.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="user-quota-managment">
    <title>Gerenciamento de cotas de usuário</title>
    <para>
     O Ceph Object Gateway permite definir cotas para usuários e compartimentos de memória pertencentes aos usuários. As cotas incluem o número máximo de objetos em um compartimento de memória e o tamanho máximo de armazenamento em megabytes.
    </para>
    <para>
     Antes de habilitar uma cota de usuário, você precisa definir os respectivos parâmetros:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin quota set --quota-scope=user --uid=<replaceable>EXAMPLE_USER</replaceable> \
 --max-objects=1024 --max-size=1024</screen>
    <variablelist>
     <varlistentry>
      <term><option>--max-objects</option></term>
      <listitem>
       <para>
        Especifica o número máximo de objetos. Um valor negativo desabilita a verificação.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--max-size</option></term>
      <listitem>
       <para>
        Especifica o número máximo de bytes. Um valor negativo desabilita a verificação.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--quota-scope</option></term>
      <listitem>
       <para>
        Define o escopo para a cota. As opções são <literal>bucket</literal> e <literal>user</literal>. As cotas de compartimento de memória aplicam-se aos compartimentos de memória que um usuário possui. As cotas de usuário aplicam-se a um usuário.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Após definir uma cota de usuário, você poderá habilitá-la:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin quota enable --quota-scope=user --uid=<replaceable>EXAMPLE_USER</replaceable></screen>
    <para>
     Para desabilitar uma cota:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin quota disable --quota-scope=user --uid=<replaceable>EXAMPLE_USER</replaceable></screen>
    <para>
     Para listar as configurações de cota:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin user info --uid=<replaceable>EXAMPLE_USER</replaceable></screen>
    <para>
     Para atualizar as estatísticas de cota:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin user stats --uid=<replaceable>EXAMPLE_USER</replaceable> --sync-stats</screen>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-http-frontends">
  <title>Front ends HTTP</title>

  <para>
   O Ceph Object Gateway suporta dois front ends HTTP incorporados: <emphasis>Beast</emphasis> e <emphasis>Civetweb</emphasis>.
  </para>

  <para>
   O front end Beast usa a biblioteca Boost.Beast para análise de HTTP e a biblioteca Boost.Asio para E/S de rede assíncrona.
  </para>

  <para>
   O front end Civetweb usa a biblioteca HTTP Civetweb, que é uma bifurcação do Mongoose.
  </para>

  <para>
   É possível configurá-los com a opção <option>rgw_frontends</option> no arquivo <filename>/etc/ceph/ceph.conf</filename>. Consulte a <xref linkend="config-ogw"/> para ver uma lista de opções de configuração.
  </para>
 </sect1>
 <sect1 xml:id="ceph-rgw-https">
  <title>Habilitando HTTPS/SSL para Object Gateways</title>

  <para>
   Para habilitar a função Object Gateway padrão para comunicação segura por meio de SSL, você precisa ter um certificado emitido por uma CA ou criar um autoassinado. Há duas maneiras de configurar o Object Gateway com HTTPS habilitado: uma maneira simples que usa as configurações padrão e uma maneira avançada que permite ajustar as configurações relacionadas a HTTPS.
  </para>

  <sect2 xml:id="ogw-selfcert">
   <title>Criar um certificado autoassinado</title>
   <tip>
    <para>
     Ignore esta seção se você já tem um certificado válido assinado por uma CA.
    </para>
   </tip>
   <para>
    Por padrão, o DeepSea espera o arquivo de certificado em <filename>/srv/salt/ceph/rgw/cert/rgw.pem</filename> no master Salt. Em seguida, ele distribuirá o certificado para <filename>/etc/ceph/rgw.pem</filename> no minion Salt com a função Object Gateway, onde o Ceph faz a leitura.
   </para>
   <para>
    O procedimento a seguir descreve como gerar um certificado SSL autoassinado no master Salt.
   </para>
   <procedure>
    <step>
     <para>
      Se você precisar que o Object Gateway seja reconhecido por outras identidades de assunto, adicione-as à opção <option>subjectAltName</option> na seção <literal>[v3_req]</literal> do arquivo <filename>/etc/ssl/openssl.cnf</filename>:
     </para>
<screen>
[...]
[ v3_req ]
subjectAltName = DNS:server1.example.com DNS:server2.example.com
[...]
</screen>
     <tip>
      <title>Endereços IP em <option>subjectAltName</option></title>
      <para>
       Para usar endereços IP no lugar de nomes de domínio na opção <option>subjectAltName</option>, substitua a linha de exemplo pelo seguinte:
      </para>
<screen>
subjectAltName = IP:10.0.0.10 IP:10.0.0.11
</screen>
     </tip>
    </step>
    <step>
     <para>
      Crie a chave e o certificado usando <command>openssl</command>. Insira todos os dados que você precisa incluir em seu certificado. É recomendável inserir o FQDN como nome comum. Antes de assinar o certificado, verifique se “X509v3 Subject Alternative Name:” está incluído nas extensões solicitadas e se o certificado resultante tem "X509v3 Subject Alternative Name:" definido.
     </para>
<screen>
<prompt>root@master # </prompt>openssl req -x509 -nodes -days 1095 \
 -newkey rsa:4096 -keyout rgw.key -out /srv/salt/ceph/rgw/cert/rgw.pem
</screen>
    </step>
    <step>
     <para>
      Anexe a chave ao arquivo de certificado:
     </para>
<screen>
<prompt>root@master # </prompt>cat rgw.key &gt;&gt; /srv/salt/ceph/rgw/cert/rgw.pem
</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="ogw-ssl-simple">
   <title>Configuração de HTTPS simples</title>
   <para>
    Por padrão, o Ceph no nó do Object Gateway lê o cerificado <filename>/etc/ceph/rgw.pem</filename> e usa a porta 443 para comunicação SSL segura. Se você não precisa mudar esses valores, siga estas etapas:
   </para>
   <procedure>
    <step>
     <para>
      Edite <filename>/srv/pillar/ceph/stack/global.yml</filename> e adicione a seguinte linha:
     </para>
<screen>
rgw_init: default-ssl
</screen>
    </step>
    <step>
     <para>
      Copie a configuração de SSL do Object Gateway padrão para o subdiretório <filename>ceph.conf.d</filename>:
     </para>
<screen>
<prompt>root@master # </prompt>cp /srv/salt/ceph/configuration/files/rgw-ssl.conf \
 /srv/salt/ceph/configuration/files/ceph.conf.d/rgw.conf
</screen>
    </step>
    <step>
     <para>
      Execute as fases 2, 3 e 4 do DeepSea para aplicar as mudanças:
     </para>
<screen>
<prompt>root@master # </prompt>salt-run state.orch ceph.stage.2
<prompt>root@master # </prompt>salt-run state.orch ceph.stage.3
<prompt>root@master # </prompt>salt-run state.orch ceph.stage.4
</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="ogw-ssl-advanced">
   <title>Configuração de HTTPS avançada</title>
   <para>
    Se você precisar mudar os valores padrão para as configurações de SSL do Object Gateway, siga estas etapas:
   </para>
   <procedure>
    <step>
     <para>
      Edite <filename>/srv/pillar/ceph/stack/global.yml</filename> e adicione a seguinte linha:
     </para>
<screen>
rgw_init: default-ssl
</screen>
    </step>
    <step>
     <para>
      Copie a configuração de SSL do Object Gateway padrão para o subdiretório <filename>ceph.conf.d</filename>:
     </para>
<screen>
<prompt>root@master # </prompt>cp /srv/salt/ceph/configuration/files/rgw-ssl.conf \
 /srv/salt/ceph/configuration/files/ceph.conf.d/rgw.conf
</screen>
    </step>
    <step>
     <para>
      Edite <filename>/srv/salt/ceph/configuration/files/ceph.conf.d/rgw.conf</filename> e mude as opções padrão, como número da porte ou caminho para o certificado SSL, para refletir sua configuração.
     </para>
    </step>
    <step>
     <para>
      Execute as fases 3 e 4 do DeepSea para aplicar as mudanças:
     </para>
<screen>
<prompt>root@master # </prompt>salt-run state.orch ceph.stage.3
<prompt>root@master # </prompt>salt-run state.orch ceph.stage.4
</screen>
    </step>
   </procedure>
   <tip xml:id="rgw-webserver-multiport">
    <title>Vinculando a várias portas</title>
    <para>
     O servidor Beast pode ser vinculado a várias portas. Isso será útil se você precisar acessar uma única instância do Object Gateway com ambas as conexões SSL e não SSL. Veja a seguir um exemplo de linha de configuração de duas portas:
    </para>
<screen>[client.{{ client }}]
rgw_frontends = beast port=80 ssl_port=443 ssl_certificate=/etc/ceph/rgw.pem</screen>
   </tip>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph-rgw-sync">
  <title>Módulos de sincronização</title>

  <para>
   A funcionalidade <emphasis>multissite</emphasis> do Object Gateway permite criar várias zonas e espelhar os dados e metadados entre elas. Os <emphasis>módulos de sincronização</emphasis> foram desenvolvidos com base na estrutura multissite, que permite encaminhar dados e metadados para uma camada externa diferente. Um módulo de sincronização permite a execução de um conjunto de ações sempre que há uma mudança nos dados (por exemplo, operações de metadados como criação de compartimento de memória ou de usuário). Como as mudanças de multissite do Object Gateway acabam sendo consistentes em sites remotos, elas são propagadas de forma assíncrona. Isso abrange casos de uso como backup de armazenamento de objetos em um cluster de nuvem externo, solução de backup personalizada que usa unidades de fita ou indexação de metadados no ElasticSearch.
  </para>

  <sect2 xml:id="ogw-sync-general-config">
   <title>Configuração geral</title>
   <para>
    Todos os módulos de sincronização são configurados de forma semelhante. Você precisa criar uma nova zona (consulte a <xref linkend="ceph-rgw-fed"/> para obter mais detalhes) e definir a opção <option>--tier_type</option> dela, por exemplo, <option>--tier-type=cloud</option> para o módulo de sincronização de nuvem:
   </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zone create --rgw-zonegroup=<replaceable>ZONE-GROUP-NAME</replaceable> \
 --rgw-zone=<replaceable>ZONE-NAME</replaceable> \
 --endpoints=http://endpoint1.example.com,http://endpoint2.example.com, [...] \
 --tier-type=cloud
</screen>
   <para>
    Você pode configurar a camada específica usando o seguinte comando:
   </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zone modify --rgw-zonegroup=<replaceable>ZONE-GROUP-NAME</replaceable> \
 --rgw-zone=<replaceable>ZONE-NAME</replaceable> \
 --tier-config=<replaceable>KEY1</replaceable>=<replaceable>VALUE1</replaceable>,<replaceable>KEY2</replaceable>=<replaceable>VALUE2</replaceable>
</screen>
   <para>
    A <replaceable>KEY</replaceable> (CHAVE) na configuração especifica a variável de configuração que você deseja atualizar, e o <replaceable>VALUE</replaceable> (VALOR) especifica o novo valor dela. É possível usar um ponto para acessar os valores aninhados. Por exemplo:
   </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zone modify --rgw-zonegroup=<replaceable>ZONE-GROUP-NAME</replaceable> \
 --rgw-zone=<replaceable>ZONE-NAME</replaceable> \
 --tier-config=connection.access_key=<replaceable>KEY</replaceable>,connection.secret=<replaceable>SECRET</replaceable>
</screen>
   <para>
    Você pode acessar entradas de matriz anexando colchetes “[]” com a entrada referenciada. Você pode adicionar uma nova entrada de matriz usando colchetes “[]”. O valor do índice de -1 faz referência à última entrada na matriz. Não é possível criar uma nova entrada e fazer referência a ela novamente no mesmo comando. Por exemplo, veja a seguir um comando para criar um novo perfil para compartimentos de memória que começam com <replaceable>PREFIX</replaceable>:
   </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zone modify --rgw-zonegroup=<replaceable>ZONE-GROUP-NAME</replaceable> \
 --rgw-zone=<replaceable>ZONE-NAME</replaceable> \
 --tier-config=profiles[].source_bucket=<replaceable>PREFIX</replaceable>'*'
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zone modify --rgw-zonegroup=<replaceable>ZONE-GROUP-NAME</replaceable> \
 --rgw-zone=<replaceable>ZONE-NAME</replaceable> \
 --tier-config=profiles[-1].connection_id=<replaceable>CONNECTION_ID</replaceable>,profiles[-1].acls_id=<replaceable>ACLS_ID</replaceable>
</screen>
   <tip>
    <title>Adicionar e Remover Entradas de Configuração</title>
    <para>
     Você pode adicionar uma nova entrada de configuração de camada usando o parâmetro <option>--tier-config-add=<replaceable>KEY</replaceable>=<replaceable>VALUE</replaceable></option>.
    </para>
    <para>
     Você pode remover uma entrada existente usando <option>--tier-config-rm=<replaceable>KEY</replaceable></option>.
    </para>
   </tip>
  </sect2>

  <sect2 xml:id="ceph-rgw-sync-zones">
   <title>Sincronizando zonas</title>
   <para>
    A configuração de um módulo de sincronização é local para uma zona. O módulo de sincronização determina se a zona exporta os dados ou apenas pode consumir os dados que foram modificados em outra zona. A partir do Luminous, os plug-ins de sincronização suportados são <literal>ElasticSearch</literal>, <literal>rgw</literal>, que é o plug-in padrão que sincroniza dados entre zonas, e <literal>log</literal>, que é o plug-in comum que registra a operação de metadados executada nas zonas remotas. As seções a seguir foram elaboradas com o exemplo de uma zona que usa o módulo de sincronização <literal>ElasticSearch</literal>. O mesmo processo pode ser aplicado para configurar qualquer outro plug-in de sincronização.
   </para>
   <note>
    <title>Plug-in de Sincronização Padrão</title>
    <para>
     <literal>rgw</literal> é o plug-in de sincronização padrão, e não há necessidade de configurá-lo explicitamente.
    </para>
   </note>
   <sect3 xml:id="ceph-rgw-sync-zones-req">
    <title>Requisitos e considerações</title>
    <para>
     Vamos considerar uma configuração multissite simples, conforme descrito na <xref linkend="ceph-rgw-fed"/>, com 2 zonas <literal>us-east</literal> e <literal>us-west</literal>. Agora, adicionamos uma terceira zona <literal>us-east-es</literal>, que processará apenas os metadados de outros sites. Essa zona pode estar no mesmo ou em um cluster do Ceph diferente do <literal>us-east</literal>. Essa zona consumirá apenas os metadados de outras zonas, e os Object Gateways nela não atenderão diretamente nenhuma solicitação de usuário final.
    </para>
   </sect3>
   <sect3 xml:id="ceph-rgw-sync-zones-configure">
    <title>Configurando módulos de sincronização</title>
    <procedure>
     <step>
      <para>
       Crie a terceira zona semelhante àquelas descritas na <xref linkend="ceph-rgw-fed"/>. Por exemplo,
      </para>
<screen>
<prompt>cephadm@adm &gt; </prompt><command>radosgw-admin</command> zone create --rgw-zonegroup=us --rgw-zone=us-east-es \
--access-key=<replaceable>SYSTEM-KEY</replaceable> --secret=<replaceable>SECRET</replaceable> --endpoints=http://rgw-es:80
      </screen>
     </step>
     <step>
      <para>
       É possível configurar um módulo de sincronização para essa zona por meio do seguinte comando
      </para>
<screen>
<prompt>cephadm@adm &gt; </prompt><command>radosgw-admin</command> zone modify --rgw-zone=<replaceable>ZONE-NAME</replaceable> --tier-type=<replaceable>TIER-TYPE</replaceable> \
--tier-config={set of key=value pairs}
      </screen>
     </step>
     <step>
      <para>
       Por exemplo, no módulo de sincronização <literal>ElasticSearch</literal>
      </para>
<screen>
<prompt>cephadm@adm &gt; </prompt><command>radosgw-admin</command> zone modify --rgw-zone=<replaceable>ZONE-NAME</replaceable> --tier-type=elasticsearch \
--tier-config=endpoint=http://localhost:9200,num_shards=10,num_replicas=1
      </screen>
      <para>
       Para as várias opções de configuração de camada suportadas, consulte a <xref linkend="ceph-rgw-sync-elastic"/>.
      </para>
     </step>
     <step>
      <para>
       Por fim, atualize o período
      </para>
<screen>
<prompt>cephadm@adm &gt; </prompt><command>radosgw-admin</command> period update --commit
      </screen>
     </step>
     <step>
      <para>
       Agora, inicie o radosgw na zona
      </para>
<screen>
<prompt>root # </prompt><command>systemctl</command> start ceph-radosgw@rgw.`hostname -s`
<prompt>root # </prompt><command>systemctl</command> enable ceph-radosgw@rgw.`hostname -s`
      </screen>
     </step>
    </procedure>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-sync-elastic">
   <title>Módulo de sincronização ElasticSearch</title>
   <para>
    Esse módulo de sincronização grava os metadados de outras zonas no ElasticSearch. A partir do Luminous, é o JSON dos campos de dados que armazenamos no ElasticSearch.
   </para>
<screen>
{
  "_index" : "rgw-gold-ee5863d6",
  "_type" : "object",
  "_id" : "34137443-8592-48d9-8ca7-160255d52ade.34137.1:object1:null",
  "_score" : 1.0,
  "_source" : {
    "bucket" : "testbucket123",
    "name" : "object1",
    "instance" : "null",
    "versioned_epoch" : 0,
    "owner" : {
      "id" : "user1",
      "display_name" : "user1"
    },
    "permissions" : [
      "user1"
    ],
    "meta" : {
      "size" : 712354,
      "mtime" : "2017-05-04T12:54:16.462Z",
      "etag" : "7ac66c0f148de9519b8bd264312c4d64"
    }
  }
}
   </screen>
   <sect3 xml:id="ceph-rgw-sync-elastic-config">
    <title>Parâmetros de configuração de tipo de camada do ElasticSearch</title>
    <variablelist>
     <varlistentry>
      <term>endpoint</term>
      <listitem>
       <para>
        Especifica o endpoint do servidor ElasticSearch a ser acessado.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>num_shards</term>
      <listitem>
       <para>
        <emphasis>(número inteiro)</emphasis> O número de fragmentos com os quais o ElasticSearch será configurado na inicialização da sincronização de dados. Observe que ele não pode ser mudado após a inicialização. Qualquer mudança aqui requer a reconstrução do índice do ElasticSearch e a reinicialização do processo de sincronização de dados.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>num_replicas</term>
      <listitem>
       <para>
        <emphasis>(número inteiro)</emphasis> O número de réplicas com as quais o ElasticSearch será configurado na inicialização da sincronização de dados.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>explicit_custom_meta</term>
      <listitem>
       <para>
        <emphasis>(true | false) </emphasis> Especifica se todos os metadados personalizados do usuário serão indexados ou se o usuário precisará configurar (no nível do compartimento de memória) quais entradas de metadados do cliente devem ser indexadas. Por padrão, isso é “false”
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>index_buckets_list</term>
      <listitem>
       <para>
        <emphasis>(lista de strings separadas por vírgulas) </emphasis> Se vazia, todos os compartimentos de memória serão indexados. Do contrário, apenas os compartimentos de memória especificados nela serão indexados. É possível inserir prefixos (por exemplo, “foo*”) ou sufixos (por exemplo, “*bar”) de compartimento de memória.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>approved_owners_list</term>
      <listitem>
       <para>
        <emphasis>(lista de strings separadas por vírgulas)</emphasis> Se vazia, os compartimentos de memória de todos os proprietários serão indexados (sujeito a outras restrições); do contrário, apenas os compartimentos de memória pertencentes a determinados proprietários serão indexados. É possível também inserir prefixos e sufixos.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>override_index_path</term>
      <listitem>
       <para>
        <emphasis>(string)</emphasis> Se não estiver vazia, essa string será usada como o caminho do índice do ElasticSearch. Do contrário, o caminho do índice será determinado e gerado na inicialização da sincronização.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>username</term>
      <listitem>
       <para>
        Especifica um nome de usuário para o ElasticSearch se a autenticação for necessária.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>password</term>
      <listitem>
       <para>
        Especifica uma senha para o ElasticSearch se a autenticação for necessária.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="ceph-rgw-sync-elastic-query">
    <title>Consultas de metadados</title>
    <para>
     Como o cluster do ElasticSearch agora armazena metadados de objetos, é importante não expor o endpoint do ElasticSearch ao público e mantê-lo acessível apenas aos administradores de cluster. A própria exposição das consultas de metadados ao usuário final representa um problema, já que desejamos que o usuário consulte apenas os metadados dele, e não de quaisquer outros usuários. Para isso, o cluster do ElasticSearch deve autenticar os usuários de modo similar ao RGW, o que representa um problema.
    </para>
    <para>
     A partir do Luminous, o RGW na zona master de metadados agora pode atender às solicitações de usuários finais. Isso evita a exposição do endpoint do ElasticSearch ao público e resolve também o problema de autenticação e autorização, pois o próprio RGW pode autenticar as solicitações de usuário final. Para essa finalidade, o RGW inclui uma nova consulta nas APIs de compartimento de memória que pode atender às solicitações de serviço do ElasticSearch. Todas essas solicitações devem ser enviadas para a zona master de metadados.
    </para>
    <variablelist>
     <varlistentry>
      <term>Obter uma consulta do ElasticSearch</term>
      <listitem>
<screen>
GET /<replaceable>BUCKET</replaceable>?query=<replaceable>QUERY-EXPR</replaceable>
       </screen>
       <para>
        parâmetros de solicitação:
       </para>
       <itemizedlist>
        <listitem>
         <para>
          max-keys: número máx. de entradas a retornar
         </para>
        </listitem>
        <listitem>
         <para>
          marker: marcador de paginação
         </para>
        </listitem>
       </itemizedlist>
<screen>
expression := [(]&lt;arg&gt; &lt;op&gt; &lt;value&gt; [)][&lt;and|or&gt; ...]
       </screen>
       <para>
        op é um dos seguintes: &lt;, &lt;=, ==, &gt;=, &gt;
       </para>
       <para>
        Por exemplo:
       </para>
<screen>
GET /?query=name==foo
       </screen>
       <para>
        Retornará todas as chaves indexadas para as quais o usuário tem permissão de leitura e que são denominadas “foo”. A saída será uma lista de chaves em XML, que é semelhante à resposta de compartimentos de memória da lista do S3.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Configurar campos personalizados de metadados</term>
      <listitem>
       <para>
        Defina quais entradas de metadados personalizados devem ser indexadas (no compartimento de memória especificado) e quais são os tipos das chaves. Se for configurada a indexação explícita de metadados personalizados, esse procedimento será necessário para o rgw indexar os valores de metadados personalizados especificados. Do contrário, ele será necessário nos casos em que as chaves dos metadados indexados são de um tipo diferente de string.
       </para>
<screen>
POST /<replaceable>BUCKET</replaceable>?mdsearch
x-amz-meta-search: &lt;key [; type]&gt; [, ...]
       </screen>
       <para>
        Vários campos de metadados devem ser separados por vírgula. É possível forçar um tipo para um campo com “;”. Os tipos permitidos atualmente são string (padrão), número inteiro e data. Por exemplo, para indexar metadados de um objeto personalizado x-amz-meta-year como número inteiro, x-amz-meta-date como o tipo data e x-amz-meta-title como string, faça o seguinte
       </para>
<screen>
POST /mybooks?mdsearch
x-amz-meta-search: x-amz-meta-year;int, x-amz-meta-release-date;date, x-amz-meta-title;string
       </screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Apague a configuração de metadados personalizados</term>
      <listitem>
       <para>
        Apague a configuração de compartimento de memória dos metadados personalizados.
       </para>
<screen>
DELETE /<replaceable>BUCKET</replaceable>?mdsearch
       </screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Obter a configuração dos metadados personalizados</term>
      <listitem>
       <para>
        Recupere a configuração de compartimento de memória dos metadados personalizados.
       </para>
<screen>
GET /<replaceable>BUCKET</replaceable>?mdsearch
       </screen>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 xml:id="ogw-cloud-sync">
   <title>Módulo de sincronização de nuvem</title>
   <para>
    Esta seção apresenta um módulo que sincroniza os dados da zona com um serviço de nuvem remoto. A sincronização é apenas unidirecional, os dados não são sincronizados de volta da zona remota. O principal objetivo deste módulo é habilitar a sincronização de dados com vários provedores de serviços de nuvem. Atualmente, ele suporta provedores de nuvem compatíveis com a AWS (S3).
   </para>
   <para>
    Para sincronizar os dados com um serviço de nuvem remoto, você precisa configurar as credenciais do usuário. Como muitos serviços de nuvem apresentam limites quanto ao número de compartimentos de memória que cada usuário pode criar, é possível configurar o mapeamento de objetos e compartimentos de memória de origem, destinos diferentes para compartimentos de memória distintos e prefixos de compartimento de memória. Observe que as listas de acesso de origem (ACLs) não serão preservadas. É possível mapear permissões de usuários de origem específicos para usuários de destino específicos.
   </para>
   <para>
    Devido às limitações da API, não existe um modo de preservar o horário de modificação do objeto original e a tag da entidade HTTP (ETag). O módulo de sincronização de nuvem armazena essas informações como atributos de metadados nos objetos de destino.
   </para>
   <sect3>
    <title>Configuração geral</title>
    <para>
     Veja a seguir exemplos de uma configuração comum e não comum para o módulo de sincronização de nuvem. Observe que a configuração comum pode ser diferente da não comum.
    </para>
    <example>
     <title>Configuração Comum</title>
<screen>
{
  "connection": {
    "access_key": <replaceable>ACCESS</replaceable>,
    "secret": <replaceable>SECRET</replaceable>,
    "endpoint": <replaceable>ENDPOINT</replaceable>,
    "host_style": <replaceable>path | virtual</replaceable>,
  },
  "acls": [ { "type": <replaceable>id | email | uri</replaceable>,
    "source_id": <replaceable>SOURCE_ID</replaceable>,
    "dest_id": <replaceable>DEST_ID</replaceable> } ... ],
  "target_path": <replaceable>TARGET_PATH</replaceable>,
}
</screen>
    </example>
    <example>
     <title>Configuração Não Comum</title>
<screen>
{
  "default": {
    "connection": {
      "access_key": <replaceable>ACCESS</replaceable>,
      "secret": <replaceable>SECRET</replaceable>,
      "endpoint": <replaceable>ENDPOINT</replaceable>,
      "host_style" <replaceable>path | virtual</replaceable>,
    },
    "acls": [
    {
      "type": <replaceable>id | email | uri</replaceable>,   #  optional, default is id
      "source_id": <replaceable>ID</replaceable>,
      "dest_id": <replaceable>ID</replaceable>
    } ... ]
    "target_path": <replaceable>PATH</replaceable> # optional
  },
  "connections": [
  {
    "connection_id": <replaceable>ID</replaceable>,
    "access_key": <replaceable>ACCESS</replaceable>,
    "secret": <replaceable>SECRET</replaceable>,
    "endpoint": <replaceable>ENDPOINT</replaceable>,
    "host_style": <replaceable>path | virtual</replaceable>,  # optional
  } ... ],
  "acl_profiles": [
  {
    "acls_id": <replaceable>ID</replaceable>, # acl mappings
    "acls": [ {
      "type": <replaceable>id | email | uri</replaceable>,
      "source_id": <replaceable>ID</replaceable>,
      "dest_id": <replaceable>ID</replaceable>
    } ... ]
  }
  ],
  "profiles": [
  {
   "source_bucket": <replaceable>SOURCE</replaceable>,
   "connection_id": <replaceable>CONNECTION_ID</replaceable>,
   "acls_id": <replaceable>MAPPINGS_ID</replaceable>,
   "target_path": <replaceable>DEST</replaceable>,          # optional
  } ... ],
}
</screen>
    </example>
    <para>
     Veja a seguir a explicação dos termos de configuração usados:
    </para>
    <variablelist>
     <varlistentry>
      <term>connection</term>
      <listitem>
       <para>
        Representa uma conexão com o serviço de nuvem remota. Contém "connection_id", "access_key", "secret", "endpoint" e "host_style".
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>access_key</term>
      <listitem>
       <para>
        A chave de acesso à nuvem remota que será usada para a conexão específica.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>secret</term>
      <listitem>
       <para>
        A chave secreta para o serviço de nuvem remota.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>endpoint</term>
      <listitem>
       <para>
        URL do endpoint do serviço de nuvem remota.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>host_style</term>
      <listitem>
       <para>
        Tipo de estilo do host ("path" ou "virtual") a ser usado quando acessar o endpoint da nuvem remota. O padrão é “path” (caminho).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>acls</term>
      <listitem>
       <para>
        Matriz de mapeamentos da lista de acesso.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>acl_mapping</term>
      <listitem>
       <para>
        Cada estrutura "acl_mapping" contém "type", "source_id" e "dest_id". Eles definirão a mutação da ACL para cada objeto. Uma mutação da ACL permite converter o ID de usuário de origem em um ID de destino.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>type</term>
      <listitem>
       <para>
        Tipo de ACL: “id” define o ID de usuário, “email” define o usuário por e-mail e “uri” define o usuário por URI (grupo).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>source_id</term>
      <listitem>
       <para>
        ID do usuário na zona de origem.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>dest_id</term>
      <listitem>
       <para>
        ID do usuário no destino.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>target_path</term>
      <listitem>
       <para>
        Uma string que define como o caminho de destino é criado. O caminho de destino especifica um prefixo ao qual o nome do objeto de origem é anexado. O caminho de destino configurável pode incluir qualquer uma das seguintes variáveis:
       </para>
       <variablelist>
        <varlistentry>
         <term>SID</term>
         <listitem>
          <para>
           Uma string exclusiva que representa o ID da instância de sincronização.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>ZONEGROUP</term>
         <listitem>
          <para>
           Nome do grupo de zonas.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>ZONEGROUP_ID</term>
         <listitem>
          <para>
           ID do grupo de zonas.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>ZONE</term>
         <listitem>
          <para>
           Nome da zona.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>ZONE_ID</term>
         <listitem>
          <para>
           ID da zona.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>BUCKET</term>
         <listitem>
          <para>
           Nome do compartimento de memória de origem.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>OWNER</term>
         <listitem>
          <para>
           ID do proprietário do compartimento de memória de origem.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
       <para>
        Por exemplo: target_path = rgwx-<replaceable>ZONE</replaceable>-<replaceable>SID</replaceable>/<replaceable>OWNER</replaceable>/<replaceable>BUCKET</replaceable>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>acl_profiles</term>
      <listitem>
       <para>
        Uma matriz de perfis da lista de acesso.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>acl_profile</term>
      <listitem>
       <para>
        Cada perfil contém: “acls_id”, que representa o perfil, e uma matriz de “acls”, que armazena uma lista de “acl_mappings”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>profiles</term>
      <listitem>
       <para>
        Uma lista de perfis. Cada perfil contém o seguinte:
       </para>
       <variablelist>
        <varlistentry>
         <term>source_bucket</term>
         <listitem>
          <para>
           Nome ou prefixo do compartimento de memória (se terminar com *), que define o(s) compartimento(s) de memória de origem para este perfil.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>target_path</term>
         <listitem>
          <para>
           Veja a explicação acima.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>connection_id</term>
         <listitem>
          <para>
           ID da conexão que será usada para este perfil.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>acls_id</term>
         <listitem>
          <para>
           ID do perfil da ACL que será usado para este perfil.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3>
    <title>Elementos de configuração específicos do S3</title>
    <para>
     O módulo de sincronização de nuvem apenas funcionará com back ends compatíveis com o AWS S3. Há alguns elementos de configuração que podem ser usados para ajustar o comportamento ao acessar serviços de nuvem do S3:
    </para>
<screen>
{
  "multipart_sync_threshold": <replaceable>OBJECT_SIZE</replaceable>,
  "multipart_min_part_size": <replaceable>PART_SIZE</replaceable>
}
</screen>
    <variablelist>
     <varlistentry>
      <term>multipart_sync_threshold</term>
      <listitem>
       <para>
        Os objetos cujo tamanho é igual ou maior do que esse valor serão sincronizados com o serviço de nuvem por meio do upload de várias partes.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>multipart_min_part_size</term>
      <listitem>
       <para>
        Tamanho mínimo das partes para usar na sincronização de objetos por meio do upload de várias partes.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 xml:id="archive-sync-module">
   <title>Módulo de sincronização de arquivo</title>
   <para>
    O <emphasis>módulo de sincronização de arquivo</emphasis> utiliza o recurso de controle de versão dos objetos do S3 no Object Gateway. Você pode configurar uma <emphasis>zona de arquivo</emphasis>, que captura as diferentes versões dos objetos do S3 à medida que surgem nas outras zonas ao longo do tempo. O histórico de versões que a zona de arquivo mantém apenas pode ser eliminado pelos gateways associados à zona de arquivo.
   </para>
   <para>
    Com essa arquitetura, várias zonas sem controle versão podem espelhar seus dados e metadados por meio de seus gateways de zona, oferecendo alta disponibilidade aos usuários finais, enquanto a zona de arquivo captura todas as atualizações de dados para consolidá-los como versões dos objetos do S3.
   </para>
   <para>
    Ao incluir a zona de arquivo em uma configuração de várias zonas, você ganha a flexibilidade de um histórico de objetos do S3 em uma zona, além de economizar o espaço que as réplicas dos objetos do S3 com controle de versão consomem nas zonas restantes.
   </para>
   <sect3 xml:id="archive-sync-module-configuration">
    <title>Configuração</title>
    <tip>
     <title>Mais informações</title>
     <para>
      Consulte a <xref linkend="ceph-rgw-fed"/> para obter detalhes sobre a configuração de gateways multissite.
     </para>
     <para>
      Consulte a <xref linkend="ceph-rgw-sync"/> para obter detalhes sobre a configuração de módulos de sincronização.
     </para>
    </tip>
    <para>
     Para usar o módulo de arquivo, você precisa criar uma nova zona cujo tipo de camada esteja definido como <literal>arquivo</literal>:
    </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zone create --rgw-zonegroup=<replaceable>ZONE_GROUP_NAME</replaceable> \
 --rgw-zone=<replaceable>OGW_ZONE_NAME</replaceable> \
 --endpoints=<replaceable>http://OGW_ENDPOINT1_URL[,http://OGW_ENDPOINT2_URL,...]</replaceable>
 --tier-type=archive
</screen>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph-rgw-ldap">
  <title>Autenticação LDAP</title>

  <para>
   Além da autenticação de usuário local padrão, o Object Gateway pode usar os serviços do servidor LDAP para autenticar também os usuários.
  </para>

  <sect2 xml:id="ceph-rgw-ldap-how-works">
   <title>Mecanismo de autenticação</title>
   <para>
    O Object Gateway extrai as credenciais de LDAP do usuário de um token. Um filtro de pesquisa é construído com base no nome de usuário. O Object Gateway usa a conta de serviço configurada para pesquisar uma entrada correspondente no diretório. Se uma entrada for encontrada, o Object Gateway tentará se vincular ao nome exclusivo encontrado com a senha do token. Se as credenciais forem válidas, o vínculo será bem-sucedido, e o Object Gateway concederá o acesso.
   </para>
   <para>
    Você pode limitar os usuários permitidos definindo a base para a pesquisa como uma unidade organizacional específica ou especificando um filtro de pesquisa personalizado. Por exemplo, exigir a participação em um grupo específico, classes de objetos ou atributos personalizados.
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-ldap-reqs">
   <title>Requisitos</title>
   <itemizedlist>
    <listitem>
     <para>
      <emphasis>LDAP ou Active Directory</emphasis>: Uma instância LDAP em execução acessível pelo Object Gateway.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis>Conta de serviço</emphasis>: Credenciais LDAP para uso do Object Gateway com permissões de pesquisa.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis>Conta de usuário</emphasis>: Pelo menos, uma conta do usuário no diretório LDAP.
     </para>
    </listitem>
   </itemizedlist>
   <important>
    <title>Não sobreponha usuários LDAP e locais</title>
    <para>
     Você não deve usar os mesmos nomes para usuários locais e usuários autenticados por LDAP. O Object Gateway não pode diferenciá-los e os trata como se fossem os mesmos usuários.
    </para>
   </important>
   <tip>
    <title>Verificações de integridade</title>
    <para>
     Use o utilitário <command>ldapsearch</command> para verificar a conta de serviço ou a conexão LDAP. Por exemplo:
    </para>
<screen><prompt>tux &gt; </prompt>ldapsearch -x -D "uid=ceph,ou=system,dc=example,dc=com" -W \
-H ldaps://example.com -b "ou=users,dc=example,dc=com" 'uid=*' dn</screen>
    <para>
     Use os mesmos parâmetros LDAP que o arquivo de configuração do Ceph para evitar possíveis problemas.
    </para>
   </tip>
  </sect2>

  <sect2 xml:id="ceph-rgw-ldap-config">
   <title>Configurar o Object Gateway para usar a autenticação LDAP</title>
   <para>
    Os seguintes parâmetros no arquivo de configuração <filename>/etc/ceph/ceph.conf</filename> estão relacionados à autenticação LDAP:
   </para>
   <variablelist>
    <varlistentry>
     <term><option>rgw_ldap_uri</option></term>
     <listitem>
      <para>
       Especifica o servidor LDAP a ser usado. Use o parâmetro <literal>ldaps://<replaceable>FQDN</replaceable>:<replaceable>PORT</replaceable></literal> para evitar a transmissão aberta de credenciais de texto simples.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>rgw_ldap_binddn</option></term>
     <listitem>
      <para>
       O DN (Distinguished Name – Nome Exclusivo) da conta de serviço usada pelo Object Gateway.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>rgw_ldap_secret</option></term>
     <listitem>
      <para>
       A senha para a conta de serviço.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>rgw_ldap_searchdn</term>
     <listitem>
      <para>
       Especifica a base na árvore de informações do diretório para pesquisar usuários. Ela pode ser a unidade organizacional de usuários ou alguma OU (Organizational Unit – Unidade Organizacional) mais específica.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>rgw_ldap_dnattr</option></term>
     <listitem>
      <para>
       O atributo que está sendo usado no filtro de pesquisa construído para corresponder um nome de usuário. Dependendo da DIT (Directory Information Tree – Árvore de Informações do Diretório), ele provavelmente será <literal>uid</literal> ou <literal>cn</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>rgw_search_filter</option></term>
     <listitem>
      <para>
       Se não for especificado, o Object Gateway construirá automaticamente o filtro de pesquisa com a configuração <option>rgw_ldap_dnattr</option>. Use esse parâmetro para restringir a lista de usuários permitidos com muita flexibilidade. Consulte a <xref linkend="ceph-rgw-ldap-filter"/> para obter detalhes.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="ceph-rgw-ldap-filter">
   <title>Usando um filtro de pesquisa personalizado para limitar o acesso do usuário</title>
   <para>
    Você pode usar o parâmetro <option>rgw_search_filter</option> de duas maneiras.
   </para>
   <sect3>
    <title>Filtro parcial para limitar ainda mais o filtro de pesquisa construído</title>
    <para>
     Veja a seguir um exemplo de filtro parcial:
    </para>
<screen>"objectclass=inetorgperson"</screen>
    <para>
     O Object Gateway gerará o filtro de pesquisa como de costume com o nome de usuário extraído do token e o valor de <option>rgw_ldap_dnattr</option>. Em seguida, o filtro construído será combinado ao filtro parcial com base no atributo <option>rgw_search_filter</option>. Dependendo do nome de usuário e das configurações, o filtro de pesquisa final poderá ser:
    </para>
<screen>"(&amp;(uid=hari)(objectclass=inetorgperson))"</screen>
    <para>
     Nesse caso, o usuário “hari” apenas receberá acesso se for encontrado no diretório LDAP, se tiver uma classe de objeto “inetorgperson” e se especificar uma senha válida.
    </para>
   </sect3>
   <sect3>
    <title>Filtro completo</title>
    <para>
     Um filtro completo deve conter um token <option>USERNAME</option> que será substituído pelo nome de usuário durante a tentativa de autenticação. O parâmetro <option>rgw_ldap_dnattr</option> não é mais usado neste caso. Por exemplo, para limitar os usuários válidos a um grupo específico, use o filtro a seguir:
    </para>
<screen>"(&amp;(uid=USERNAME)(memberOf=cn=ceph-users,ou=groups,dc=mycompany,dc=com))"</screen>
    <note>
     <title>Atributo <literal>memberOf</literal></title>
     <para>
      O uso do atributo <literal>memberOf</literal> nas pesquisas LDAP requer suporte da sua implementação de servidor LDAP específica.
     </para>
    </note>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-ldap-token">
   <title>Gerando um token de acesso para autenticação LDAP</title>
   <para>
    O utilitário <command>radosgw-token</command> gera o token de acesso com base no nome de usuário e na senha LDAP. Ele emite uma string codificada com base64, que é o token de acesso real. Use seu cliente S3 favorito (consulte a <xref linkend="accessing-ragos-gateway"/>), especifique o token como a chave de acesso e use uma chave secreta vazia.
   </para>
<screen><prompt>tux &gt; </prompt>export RGW_ACCESS_KEY_ID="<replaceable>USERNAME</replaceable>"
<prompt>tux &gt; </prompt>export RGW_SECRET_ACCESS_KEY="<replaceable>PASSWORD</replaceable>"
<prompt>cephadm@adm &gt; </prompt>radosgw-token --encode --ttype=ldap</screen>
   <important>
    <title>Credenciais de texto sem criptografia</title>
    <para>
     O token de acesso é uma estrutura JSON codificada com base64 que contém as credenciais LDAP como texto sem criptografia.
    </para>
   </important>
   <note>
    <title>Active Directory</title>
    <para>
     Para o Active Directory, use o parâmetro <option>--ttype=ad</option>.
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-bucket-sharding">
  <title>Fragmentação de índice do compartimento de memória</title>

  <para>
   O Object Gateway armazena os dados de índice do compartimento de memória em um pool de índice, que assume <literal>.rgw.buckets.index</literal> como padrão. Se você colocar um número excessivo (centenas de milhares) de objetos em um único compartimento de memória, e a cota para o número máximo de objetos por compartimento de memória (<option>rgw bucket default quota max objects</option>) não for definida, o desempenho do pool de índice poderá ser prejudicado. A <emphasis>fragmentação de índice do compartimento de memória</emphasis> impede essa redução no desempenho e permite um alto número de objetos por compartimento de memória.
  </para>

  <sect2 xml:id="ogw-bucket-reshard">
   <title>Refragmentação de índice do compartimento de memória</title>
   <para>
    Se um compartimento de memória ficar muito grande e sua configuração inicial não for mais suficiente, será necessário refragmentar o pool de índice dele. Você pode usar a refragmentação de índice do compartimento de memória automática online (consulte a <xref linkend="ogw-bucket-sharding-dyn"/>) ou refragmentar o índice do compartimento de memória offline manualmente (consulte a <xref linkend="ogw-bucket-sharding-re"/>).
   </para>
   <sect3 xml:id="ogw-bucket-sharding-dyn">
    <title>Refragmentação dinâmica</title>
    <para>
     A partir do SUSE Enterprise Storage 5, oferecemos suporte à refragmentação do compartimento de memória online. Ela detecta se o número de objetos por compartimento de memória atinge determinado limite e aumenta automaticamente o número de fragmentos usados pelo índice do compartimento de memória. Esse processo reduz o número de entradas em cada fragmento de índice do compartimento de memória.
    </para>
    <para>
     O processo de detecção é executado:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Quando novos objetos são adicionados ao compartimento de memória.
      </para>
     </listitem>
     <listitem>
      <para>
       Em um processo em segundo plano que explora periodicamente todos os compartimentos de memória. Isso é necessário para resolver a questão de compartimentos de memória existentes que não são atualizados.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     Um compartimento de memória que requer refragmentação é adicionado à fila <option>reshard_log</option> e será programado para ser refragmentado posteriormente. Os threads de refragmentação são executados em segundo plano e executam a refragmentação programada, uma de cada vez.
    </para>
    <variablelist>
     <title>Configurando a refragmentação dinâmica</title>
     <varlistentry>
      <term><option>rgw_dynamic_resharding</option></term>
      <listitem>
       <para>
        Habilita ou desabilita a refragmentação dinâmica de índice do compartimento de memória. Os valores possíveis são “true” (verdadeiro) ou “false” (falso). O padrão é “true”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw_reshard_num_logs</option></term>
      <listitem>
       <para>
        Número de fragmentos para o registro da refragmentação. O padrão é 16.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw_reshard_bucket_lock_duration</option></term>
      <listitem>
       <para>
        Duração do bloqueio do objeto do compartimento de memória durante a refragmentação. O padrão é 120 segundos.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw_max_objs_per_shard</option></term>
      <listitem>
       <para>
        Número máximo de objetos por fragmento de índice do compartimento de memória. O padrão é 100.000 objetos.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw_reshard_thread_interval</option></term>
      <listitem>
       <para>
        Tempo máxithread de refragmentaçãomo entre os ciclos de processamento do . O padrão é 600 segundos.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <important>
     <title>Configurações multissite</title>
     <para>
      A refragmentação dinâmica não é suportada em ambientes multissite. Por padrão, ela está desabilitada desde o Ceph 12.2.2, mas recomendamos conferir essa configuração.
     </para>
    </important>
    <variablelist>
     <title>Comandos para administrar o processo de refragmentação</title>
     <varlistentry>
      <term>Adicionar um compartimento de memória à fila de refragmentação:</term>
      <listitem>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin reshard add \
 --bucket <replaceable>BUCKET_NAME</replaceable> \
 --num-shards <replaceable>NEW_NUMBER_OF_SHARDS</replaceable>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Listar a fila de refragmentação:</term>
      <listitem>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin reshard list
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Processar/Programar a refragmentação de um compartimento de memória:</term>
      <listitem>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin reshard process
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Exibir o status da refragmentação do compartimento de memória:</term>
      <listitem>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin reshard status --bucket <replaceable>BUCKET_NAME</replaceable>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Cancelar uma refragmentação pendente do compartimento de memória:</term>
      <listitem>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin reshard cancel --bucket <replaceable>BUCKET_NAME</replaceable>
</screen>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="ogw-bucket-sharding-re">
    <title>Refragmentação manual</title>
    <para>
     A refragmentação dinâmica mencionada na <xref linkend="ogw-bucket-sharding-dyn"/> é suportada apenas nas configurações simples do Object Gateway. Para configurações multissite, use a refragmentação manual descrita nesta seção.
    </para>
    <para>
     Para refragmentar o índice do compartimento de memória manualmente offline, use o seguinte comando:
    </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin bucket reshard
</screen>
    <para>
     O comando <command>bucket reshard</command> executa o seguinte:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Cria um novo conjunto de objetos de índice do compartimento de memória para o objeto especificado.
      </para>
     </listitem>
     <listitem>
      <para>
       Distribui todas as entradas desses objetos de índice.
      </para>
     </listitem>
     <listitem>
      <para>
       Cria uma nova instância do compartimento de memória.
      </para>
     </listitem>
     <listitem>
      <para>
       Vincula a nova instância do compartimento de memória ao compartimento de memória para que todas as novas operações de índice passem pelos novos índices do compartimento de memória.
      </para>
     </listitem>
     <listitem>
      <para>
       Imprime o ID do compartimento de memória antigo e novo para a saída padrão.
      </para>
     </listitem>
    </itemizedlist>
    <procedure>
     <title>Refragmentando o pool de índice do compartimento de memória</title>
     <step>
      <para>
       Verifique se todas as operações no compartimento de memória foram interrompidas.
      </para>
     </step>
     <step>
      <para>
       Faça backup do índice original do compartimento de memória:
      </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin bi list \
 --bucket=<replaceable>BUCKET_NAME</replaceable> \
 &gt; <replaceable>BUCKET_NAME</replaceable>.list.backup
</screen>
     </step>
     <step>
      <para>
       Refragmente o índice do compartimento de memória:
      </para>
<screen>
 <prompt>cephadm@adm &gt; </prompt>radosgw-admin reshard \
 --bucket=<replaceable>BUCKET_NAME</replaceable> \
 --num-shards=<replaceable>NEW_SHARDS_NUMBER</replaceable>
</screen>
      <tip>
       <title>ID do compartimento de memória antigo</title>
       <para>
        Como parte da saída, esse comando também imprime o ID do compartimento de memória novo e antigo. Anote o ID do compartimento de memória antigo. Ele será necessário para purgar os objetos de índice do compartimento de memória antigo.
       </para>
      </tip>
     </step>
     <step>
      <para>
       Verifique se os objetos estão listados corretamente comparando a listagem de índice do compartimento de memória antigo com o novo. Em seguida, purgue os objetos de índice do compartimento de memória antigo:
      </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin bi purge
 --bucket=<replaceable>BUCKET_NAME</replaceable>
 --bucket-id=<replaceable>OLD_BUCKET_ID</replaceable>
</screen>
     </step>
    </procedure>
   </sect3>
  </sect2>

  <sect2 xml:id="ogw-bucket-sharding-new">
   <title>Fragmentação de índice para novos compartimentos de memória</title>
   <para>
    Há duas opções que afetam a fragmentação de índice do compartimento de memória:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Use a opção <option>rgw_override_bucket_index_max_shards</option> para configurações simples.
     </para>
    </listitem>
    <listitem>
     <para>
      Use a opção <option>bucket_index_max_shards</option> para configurações multissite.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    A definição das opções como <literal>0</literal> desabilita a fragmentação de índice do compartimento de memória. Um valor maior do que <literal>0</literal> habilita a fragmentação de índice do compartimento de memória e define o número máximo de fragmentos.
   </para>
   <para>
    A fórmula a seguir ajuda você a calcular o número recomendado de fragmentos:
   </para>
<screen>
number_of_objects_expected_in_a_bucket / 100000
</screen>
   <para>
    Esteja ciente de que o número máximo de fragmentos é 7877.
   </para>
   <sect3>
    <title>Configurações simples</title>
    <procedure>
     <step>
      <para>
       Abra o arquivo de configuração do Ceph e adicione ou modifique a seguinte opção:
      </para>
<screen>
rgw_override_bucket_index_max_shards = 12
</screen>
      <tip>
       <title>Uma ou todas as instâncias do Object Gateway</title>
       <para>
        Para configurar a fragmentação de índice do compartimento de memória para todas as instâncias do Object Gateway, inclua <option>rgw_override_bucket_index_max_shards</option> na seção <literal>[global]</literal>.
       </para>
       <para>
        Para configurar a fragmentação de índice do compartimento de memória apenas para uma instância específica do Object Gateway, inclua <option>rgw_override_bucket_index_max_shards</option> na seção relacionada da instância.
       </para>
      </tip>
     </step>
     <step>
      <para>
       Reinicie o Object Gateway. Consulte a <xref linkend="ceph-rgw-operating"/> para obter mais detalhes.
      </para>
     </step>
    </procedure>
   </sect3>
   <sect3>
    <title>Configurações multissite</title>
    <para>
     As configurações multissite podem ter um pool de índice diferente para gerenciar o failover. Para configurar um número consistente de fragmentos para as zonas em um grupo de zonas, defina a opção <option>bucket_index_max_shards</option> na configuração do grupo de zonas:
    </para>
    <procedure>
     <step>
      <para>
       Exporte a configuração do grupo de zonas para o arquivo <filename>zonegroup.json</filename>:
      </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zonegroup get &gt; zonegroup.json
</screen>
     </step>
     <step>
      <para>
       Edite o arquivo <filename>zonegroup.json</filename> e defina a opção <option>bucket_index_max_shards</option> para cada zona nomeada.
      </para>
     </step>
     <step>
      <para>
       Redefina o grupo de zonas:
      </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zonegroup set &lt; zonegroup.json
</screen>
     </step>
     <step>
      <para>
       Atualize o período:
      </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin period update --commit
</screen>
     </step>
    </procedure>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-keystone">
  <title>Integrando o OpenStack Keystone</title>

  <para>
   O OpenStack Keystone é um serviço de identidade que faz parte do produto OpenStack. Você pode integrar o Object Gateway ao Keystone para configurar um gateway que aceita o token de autenticação do Keystone. Um usuário autorizado pelo Keystone a acessar o gateway será verificado no Ceph Object Gateway e criado automaticamente, se necessário. O Object Gateway consulta o Keystone periodicamente para obter uma lista de tokens revogados.
  </para>

  <sect2 xml:id="ogw-keystone-ostack">
   <title>Configurando o OpenStack</title>
   <para>
    Antes de configurar o Ceph Object Gateway, você precisa configurar o OpenStack Keystone para habilitar o serviço Swift e apontá-lo para o Ceph Object Gateway:
   </para>
   <procedure>
    <step>
     <para>
      <emphasis>Defina o serviço Swift.</emphasis> Para usar o OpenStack para validar usuários do Swift, crie primeiro o serviço Swift:
     </para>
<screen>
<prompt>tux &gt; </prompt>openstack service create \
 --name=swift \
 --description="Swift Service" \
 object-store
</screen>
    </step>
    <step>
     <para>
      <emphasis>Defina os endpoints.</emphasis> Após criar o serviço Swift, aponte para o Ceph Object Gateway. Substitua <replaceable>REGION_NAME</replaceable> pelo nome do grupo de zonas ou da região do gateway.
     </para>
<screen>
<prompt>tux &gt; </prompt>openstack endpoint create --region <replaceable>REGION_NAME</replaceable> \
 --publicurl   "http://radosgw.example.com:8080/swift/v1" \
 --adminurl    "http://radosgw.example.com:8080/swift/v1" \
 --internalurl "http://radosgw.example.com:8080/swift/v1" \
 swift
</screen>
    </step>
    <step>
     <para>
      <emphasis>Verifique as configurações.</emphasis> Após criar o serviço Swift e definir os endpoints, mostre os endpoints para verificar se todas as configurações estão corretas.
     </para>
<screen>
<prompt>tux &gt; </prompt>openstack endpoint show object-store
</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="ogw-keystone-ogw">
   <title>Configurando o Ceph Object Gateway</title>
   <sect3>
    <title>Configurar certificados SSL</title>
    <para>
     O Ceph Object Gateway consulta o Keystone periodicamente para obter uma lista de tokens revogados. Essas solicitações são codificadas e assinadas. É possível também configurar o Keystone para fornecer tokens autoassinados, que também são codificados e assinados. Você precisa configurar o gateway para que possa decodificar e verificar essas mensagens assinadas. Portanto, os certificados OpenSSL que o Keystone usa para criar as solicitações precisam ser convertidos no formato “nss db”:
    </para>
<screen>
<prompt>root # </prompt>mkdir /var/ceph/nss
<prompt>root # </prompt>openssl x509 -in /etc/keystone/ssl/certs/ca.pem \
 -pubkey | certutil -d /var/ceph/nss -A -n ca -t "TCu,Cu,Tuw"
<systemitem class="username">root</systemitem>openssl x509 -in /etc/keystone/ssl/certs/signing_cert.pem \
 -pubkey | certutil -A -d /var/ceph/nss -n signing_cert -t "P,P,P"
</screen>
    <para>
     Para permitir que o Ceph Object Gateway interaja com o OpenStack Keystone, o OpenStack Keystone pode usar um certificado SSL autoassinado. Instale o certificado SSL do Keystone no nó que executa o Ceph Object Gateway ou, se preferir, defina o valor da opção <option>rgw keystone verify ssl</option> como “false”. A definição de <option>rgw keystone verify ssl</option> como “false” indica que o gateway não tentará verificar o certificado.
    </para>
   </sect3>
   <sect3>
    <title>Configurar as opções do Object Gateway</title>
    <para>
     Você pode configurar a integração com o Keystone usando as seguintes opções:
    </para>
    <variablelist>
     <varlistentry>
      <term><option>rgw keystone api version</option></term>
      <listitem>
       <para>
        Versão da API do Keystone. As opções válidas são 2 ou 3. O padrão é 2.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone url</option></term>
      <listitem>
       <para>
        O URL e o número da porta da API RESTful administrativa no servidor Keystone. Segue o padrão <replaceable>URL_SERVIDOR:NÚMERO_DA_PORTA</replaceable>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone admin token</option></term>
      <listitem>
       <para>
        O token ou segredo compartilhado configurado internamente no Keystone para solicitações administrativas.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone accepted roles</option></term>
      <listitem>
       <para>
        As funções necessárias para atender às solicitações. O padrão é “Member, admin”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone accepted admin roles</option></term>
      <listitem>
       <para>
        A lista de funções que permite a um usuário obter privilégios administrativos.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone token cache size</option></term>
      <listitem>
       <para>
        O número máximo de entradas no cache de token do Keystone.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone revocation interval</option></term>
      <listitem>
       <para>
        O número de segundos antes de verificar se há tokens revogados. O padrão é 15 * 60.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone implicit tenants</option></term>
      <listitem>
       <para>
        Criar novos usuários em seus próprios locatários de mesmo nome. O padrão é “false”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw s3 auth use keystone</option></term>
      <listitem>
       <para>
        Se definido como “true”, o Ceph Object Gateway autenticará os usuários com o Keystone. O padrão é “false”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>nss db path</option></term>
      <listitem>
       <para>
        O caminho para o banco de dados NSS.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Também é possível configurar o locatário de serviço, o usuário e a senha do Keystone (para a versão 2.0 da API do OpenStack Identity), do mesmo modo que os serviços do OpenStack costumam ser configurados. Dessa forma, você pode evitar a definição do segredo compartilhado <option>rgw keystone admin token</option> no arquivo de configuração, que deve ser desabilitado em ambientes de produção. As credenciais do locatário de serviço devem ter privilégios de admin. Para obter mais detalhes, consulte a <link xlink:href="https://docs.openstack.org/keystone/latest/#setting-up-projects-users-and-roles">documentação oficial do OpenStack Keystone</link>. Veja a seguir as opções de configuração relacionadas:
    </para>
    <variablelist>
     <varlistentry>
      <term><option>rgw keystone admin user</option></term>
      <listitem>
       <para>
        Nome do usuário administrador do Keystone.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone admin password</option></term>
      <listitem>
       <para>
        Senha do usuário administrador do Keystone.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone admin tenant</option></term>
      <listitem>
       <para>
        Locatário do usuário administrador do Keystone versão 2.0.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Um usuário do Ceph Object Gateway é mapeado para um locatário do Keystone. Um usuário do Keystone tem funções diferentes atribuídas, possivelmente em mais do que um locatário. Quando o Ceph Object Gateway recebe o ticket, ele examina o locatário e as funções do usuário atribuídas a esse ticket e aceita ou rejeita a solicitação de acordo com a configuração da opção <option>rgw keystone accepted roles</option>.
    </para>
    <tip>
     <title>Mapeando locatários do OpenStack</title>
     <para>
      Embora os locatários do Swift sejam mapeados para o usuário do Object Gateway por padrão, eles também podem ser mapeados para os locatários do OpenStack por meio da opção <option>rgw keystone implicit tenants</option>. Isso fará com que os containers usem o namespace do locatário em vez do namespace global do tipo do S3 que o Object Gateway usa como padrão. É recomendável decidir sobre o método de mapeamento na fase de planejamento para evitar confusão. O motivo dessa recomendação é que alternar a opção posteriormente afeta apenas as solicitações mais recentes que são mapeadas em um locatário, enquanto os compartimentos de memória mais antigos criados antes ainda continuam em um namespace global.
     </para>
    </tip>
    <para>
     Para obter a versão 3 da API do OpenStack Identity, você deve substituir a opção <option>rgw keystone admin tenant</option> por:
    </para>
    <variablelist>
     <varlistentry>
      <term><option>rgw keystone admin domain</option></term>
      <listitem>
       <para>
        Domínio do usuário administrador do Keystone.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone admin project</option></term>
      <listitem>
       <para>
        Projeto do usuário administrador do Keystone.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-storage-classes">


  <title>Posicionamento do pool e classes de armazenamento</title>

  <sect2 xml:id="ogw-storage-classes-placement-targets">
   <title>Destinos de posicionamento</title>
   <para>
    Os destinos de posicionamento controlam os pools que serão associados a um determinado compartimento de memória. O destino de posicionamento de um compartimento de memória é selecionado na criação e não pode ser modificado. Você pode exibir a "placement_rule" executando o seguinte comando:
   </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin bucket stats
</screen>
   <para>
    A configuração do grupo de zonas contém uma lista de destinos de posicionamento com um destino inicial chamado "default-placement". A configuração da zona mapeia cada nome de destino de posicionamento do grupo de zonas para o respectivo armazenamento local. Essas informações de posicionamento de zona incluem o nome "index_pool" para o índice de compartimento de memória, o nome "data_extra_pool" para os metadados sobre uploads de várias partes incompletos e um nome "data_pool" para cada classe de armazenamento.
   </para>
  </sect2>

  <sect2 xml:id="ogw-storage-classes-itself">
   <title>Classes de armazenamento</title>
   <para>
    As classes de armazenamento ajudam a personalizar o posicionamento dos dados de objetos. As regras de Ciclo de Vida de Compartimento de Memória do S3 podem automatizar a transição dos objetos entre as classes de armazenamento.
   </para>
   <para>
    As classes de armazenamento são definidas em termos de destinos de posicionamento. Cada destino de posicionamento do grupo de zonas lista suas classes de armazenamento disponíveis com uma classe inicial chamada “STANDARD”. A configuração da zona é responsável por conceder um nome de pool "data_pool" a cada uma das classes de armazenamento do grupo de zonas.
   </para>
  </sect2>

  <sect2 xml:id="ogw-storage-classes-zone-config">
   <title>Configuração do grupo de zonas/zona</title>
   <para>
    Use o comando <command>radosgw-admin</command> nos grupos de zonas e nas zonas para configurar o respectivo posicionamento. Você pode consultar a configuração de posicionamento do grupo de zonas usando o seguinte comando:
   </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zonegroup get
{
    "id": "ab01123f-e0df-4f29-9d71-b44888d67cd5",
    "name": "default",
    "api_name": "default",
    ...
    "placement_targets": [
        {
            "name": "default-placement",
            "tags": [],
            "storage_classes": [
                "STANDARD"
            ]
        }
    ],
    "default_placement": "default-placement",
    ...
}
</screen>
   <para>
    Para consultar a configuração de posicionamento da zona, execute:
   </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zone get
{
    "id": "557cdcee-3aae-4e9e-85c7-2f86f5eddb1f",
    "name": "default",
    "domain_root": "default.rgw.meta:root",
    ...
    "placement_pools": [
        {
            "key": "default-placement",
            "val": {
                "index_pool": "default.rgw.buckets.index",
                "storage_classes": {
                    "STANDARD": {
                        "data_pool": "default.rgw.buckets.data"
                    }
                },
                "data_extra_pool": "default.rgw.buckets.non-ec",
                "index_type": 0
            }
        }
    ],
    ...
}
</screen>
   <note>
    <title>Sem Configuração de Multissite Anterior</title>
    <para>
     Se você não fez nenhuma configuração de multissite anterior, uma zona e um grupo de zonas “padrão” são criados para você, e as mudanças feitas neles não entrarão em vigor até você reiniciar os Ceph Object Gateways. Se você criou um domínio Kerberos para multissite, as mudanças feitas na zona/grupo de zonas entrarão em vigor depois que você confirmá-las com o comando <command>radosgw-admin period update --commit</command>.
    </para>
   </note>
   <sect3>
    <title>Adicionando um destino de posicionamento</title>
    <para>
     Para criar um novo destino de posicionamento chamado "temporary", comece adicionando-o ao grupo de zonas:
    </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zonegroup placement add \
      --rgw-zonegroup default \
      --placement-id temporary
</screen>
    <para>
     Em seguida, insira as informações de posicionamento da zona para esse destino:
    </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zone placement add \
      --rgw-zone default \
      --placement-id temporary \
      --data-pool default.rgw.temporary.data \
      --index-pool default.rgw.temporary.index \
      --data-extra-pool default.rgw.temporary.non-ec
</screen>
   </sect3>
   <sect3>
    <title>Adicionando uma classe de armazenamento</title>
    <para>
     Para adicionar uma nova classe de armazenamento chamada “COLD” ao destino de posicionamento padrão, comece adicionando-a ao grupo de zonas:
    </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zonegroup placement add \
      --rgw-zonegroup default \
      --placement-id default-placement \
      --storage-class COLD
</screen>
    <para>
     Em seguida, insira as informações de posicionamento da zona para essa classe de armazenamento:
    </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zone placement add \
      --rgw-zone default \
      --placement-id default-placement \
      --storage-class COLD \
      --data-pool default.rgw.cold.data \
      --compression lz4
</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="ogw-storage-classes-customizing-placement">
   <title>Personalizando o posicionamento</title>
   <sect3>
    <title>Posicionamento padrão</title>
    <para>
     Por padrão, os novos compartimentos de memória usarão o destino “default_placement” do grupo de zonas. Você pode mudar essa configuração do grupo de zonas com:
    </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zonegroup placement default \
      --rgw-zonegroup default \
      --placement-id new-placement
</screen>
   </sect3>
   <sect3>
    <title>Posicionamento do usuário</title>
    <para>
     Um usuário do Ceph Object Gateway pode anular o destino de posicionamento padrão do grupo de zonas definindo um campo “default_placement” não vazio nas informações do usuário. Da mesma forma, a “default_storage_class” pode anular a classe de armazenamento “STANDARD” aplicada aos objetos por padrão.
    </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin user info --uid testid
{
    ...
    "default_placement": "",
    "default_storage_class": "",
    "placement_tags": [],
    ...
}
</screen>
    <para>
     Se o destino de posicionamento do grupo de zonas incluir tags, os usuários não poderão criar compartimentos de memória com esse destino de posicionamento, a menos que as informações de usuário deles contenham pelo menos uma tag correspondente no respectivo campo "placement_tags". Isso pode ser útil para restringir o acesso a determinados tipos de armazenamento.
    </para>
    <para>
     O comando <command>radosgw-admin</command> não pode modificar esses campos diretamente, portanto, você precisa editar o formato JSON manualmente:
    </para>
<screen>
<prompt>cephadm@adm &gt; </prompt>radosgw-admin metadata get user:<replaceable>USER-ID</replaceable> &gt; user.json
<prompt>tux &gt; </prompt>vi user.json     # edit the file as required
<prompt>cephadm@adm &gt; </prompt>radosgw-admin metadata put user:<replaceable>USER-ID</replaceable> &lt; user.json
</screen>
   </sect3>
   <sect3>
    <title>Posicionamento do compartimento de memória do S3</title>
    <para>
     Ao criar um compartimento de memória com o protocolo S3, é possível inserir um destino de posicionamento como parte de <option>LocationConstraint</option> para anular os destinos de posicionamento padrão do usuário e do grupo de zonas.
    </para>
    <para>
     Normalmente, o <option>LocationConstraint</option> precisa corresponder ao <option>api_name</option> do grupo de zonas:
    </para>
<screen>
&lt;LocationConstraint&gt;default&lt;/LocationConstraint&gt;
</screen>
    <para>
     É possível adicionar um destino de posicionamento personalizado ao <option>api_name</option> após dois-pontos:
    </para>
<screen>
&lt;LocationConstraint&gt;default:new-placement&lt;/LocationConstraint&gt;
</screen>
   </sect3>
   <sect3>
    <title>Posicionamento do compartimento de memória do Swift</title>
    <para>
     Ao criar um compartimento de memória com o protocolo Swift, você pode fornecer um destino de posicionamento em “X-Storage-Policy” do cabeçalho HTTP:
    </para>
<screen>
 X-Storage-Policy: <replaceable>NEW-PLACEMENT</replaceable>
</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="ogw-storage-classes-usage">
   <title>Usando classes de armazenamento</title>
   <para>
    Todos os destinos de posicionamento têm uma classe de armazenamento “STANDARD”, que é aplicada a novos objetos por padrão. Você pode anular esse padrão com “default_storage_class”.
   </para>
   <para>
    Para criar um objeto em uma classe de armazenamento não padrão, insira o nome dessa classe de armazenamento em um cabeçalho HTTP com a solicitação. O protocolo S3 usa o cabeçalho “X-Amz-Storage-Class”, enquanto o protocolo Swift usa o cabeçalho “X-Object-Storage-Class”.
   </para>
   <para>
    É possível usar o <emphasis>Gerenciamento de Ciclo de Vida de Objeto do S3</emphasis> para mover dados de objetos entre classes de armazenamento por meio das ações de “Transição”.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph-rgw-fed">


  <title>Object Gateways multissite</title>

  <variablelist>
   <varlistentry>
    <term>Zona</term>
    <listitem>
     <para>
      Um agrupamento lógico de uma ou mais instâncias do Object Gateway. Deve haver uma zona designada como <emphasis>master</emphasis> em um <emphasis>grupo de zonas</emphasis>, que processa toda a criação de compartimento de memória e usuário.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Grupo de zonas</term>
    <listitem>
     <para>
      Um grupo de zonas consiste em várias zonas. Deve haver um grupo de zonas master que processará as mudanças na configuração do sistema.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Mapa de grupo de zonas</term>
    <listitem>
     <para>
      Uma estrutura de configuração que contém o mapa de todo o sistema. Por exemplo, que grupo de zonas é master, os relacionamentos entre diferentes grupos de zonas e determinadas opções de configuração, como políticas de armazenamento.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Domínio</term>
    <listitem>
     <para>
      Um container para grupos de zonas. Ele permite a separação de grupos de zonas entre clusters. É possível criar vários domínios, facilitando a execução de configurações completamente diferentes no mesmo cluster.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Período</term>
    <listitem>
     <para>
      Um período contém a estrutura de configuração para o estado atual do domínio. Cada período contém um ID e uma época exclusivos. Cada domínio tem um período atual associado, que contém o estado atual da configuração dos grupos de zonas e das políticas de armazenamento. Qualquer mudança na configuração para uma zona não master incrementará a época do período. Modificar a zona master para uma zona diferente acionará as seguintes mudanças:
     </para>
     <itemizedlist>
      <listitem>
       <para>
        Um novo período será gerado com um novo ID e época do período de 1.
       </para>
      </listitem>
      <listitem>
       <para>
        O período atual do domínio será atualizado para apontar para o ID do período recém-gerado.
       </para>
      </listitem>
      <listitem>
       <para>
        A época do domínio será incrementada.
       </para>
      </listitem>
     </itemizedlist>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Você pode configurar cada Object Gateway para participar de uma arquitetura unificada, trabalhando em uma configuração de zona ativa e permitindo gravações em zonas não master.
  </para>

  <sect2 xml:id="ceph-rgw-fed-term">
   <title>Terminologia</title>
   <para>
    Veja a seguir uma descrição dos termos específicos de uma arquitetura unificada:
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-intro">
   <title>Configuração de cluster de exemplo</title>
   <para>
    Neste exemplo, o foco será na criação de um único grupo de zonas com três zonas separadas, que sincronizam seus dados ativamente. Duas zonas pertencem ao mesmo cluster, enquanto a terceira pertence a outro. Não há um agente de sincronização envolvido no espelhamento das mudanças de dados entre os Object Gateways. Isso possibilita um esquema de configuração muito mais simples e configurações ativas-ativas. Observe que as operações de metadados, como a criação de um novo usuário, ainda precisam passar pela zona master. No entanto, as operações de dados, como criação de objetos e compartimentos de memória, podem ser gerenciadas por qualquer uma das zonas.
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-keys">
   <title>Chaves do sistema</title>
   <para>
    Ao configurar as zonas, o Object Gateway espera a criação de um usuário do sistema compatível com S3 juntamente com as chaves secretas e de acesso. Isso permite que outra instância do Object Gateway extraia a configuração remotamente com as chaves secretas e de acesso. Para obter mais informações sobre como criar usuários do S3, consulte a <xref linkend="adding-s3-swift-users"/>.
   </para>
   <tip>
    <para>
     Isso é útil para gerar as chaves secretas e de acesso antes da criação da própria zona, pois facilita a criação de scripts e o uso das ferramentas de gerenciamento de configuração no futuro.
    </para>
   </tip>
   <para>
    Para efeitos deste exemplo, vamos supor que as chaves secretas e de acesso foram definidas nas variáveis de ambiente:
   </para>
<screen># SYSTEM_ACCESS_KEY=1555b35654ad1656d805
# SYSTEM_SECRET_KEY=h7GhxuBLTrlhVUyxSPUKUV8r/2EI4ngqJxD7iBdBYLhwluN30JaT3Q==</screen>
   <para>
    Normalmente, as chaves de acesso são compostas por 20 caracteres alfanuméricos, enquanto as chaves secretas são constituídas de 40 caracteres alfanuméricos (também podem conter os caracteres +/=). É possível gerar essas chaves na linha de comando:
   </para>
<screen># SYSTEM_ACCESS_KEY=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 20 | head -n 1)
# SYSTEM_SECRET_KEY=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 40 | head -n 1)</screen>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-naming">
   <title>Convenções de nomeação</title>
   <para>
    Este exemplo descreve o processo de configuração de uma zona master. Vamos considerar um grupo de zonas denominado <literal>us</literal> abrangendo os Estados Unidos, que será nosso grupo de zonas master. Ele incluirá duas zonas gravadas no formato <replaceable>ZONEGROUP</replaceable>-<replaceable>ZONE</replaceable>. Trata-se apenas da nossa convenção, e você pode escolher o formato de sua preferência. Em resumo:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Grupo de zonas master: Estados Unidos <literal>us</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Zona master: Estados Unidos, Região Leste 1: <literal>us-east-1</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Zona secundária: Estados Unidos, Região Leste 2: <literal>us-east-2</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      Zona secundária: Estados Unidos, Região Oeste: <literal>us-west</literal>
     </para>
    </listitem>
   </itemizedlist>
   <para>
    Isso fará parte de um domínio maior denominado <literal>gold</literal>. As zonas <literal>us-east-1</literal> e <literal>us-east-2</literal> fazem parte do mesmo cluster do Ceph, sendo <literal>us-east-1</literal> a primária. <literal>us-west</literal> está em um cluster diferente do Ceph.
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-pools">
   <title>Pools padrão</title>
   <para>
    Quando configurado com as permissões apropriadas, o próprio Object Gateway cria pools padrão. Os valores <literal>pg_num</literal> e <literal>pgp_num</literal> são obtidos do arquivo de configuração <filename>ceph.conf</filename>. Por padrão, os pools relacionados a uma zona seguem a convenção <replaceable>NOME-ZONA</replaceable>.<replaceable>NOME-POOL</replaceable>. Por exemplo, os seguintes pools estão relacionados à zona <literal>us-east-1</literal>:
   </para>
<screen>.rgw.root
us-east-1.rgw.control
us-east-1.rgw.data.root
us-east-1.rgw.gc
us-east-1.rgw.log
us-east-1.rgw.intent-log
us-east-1.rgw.usage
us-east-1.rgw.users.keys
us-east-1.rgw.users.email
us-east-1.rgw.users.swift
us-east-1.rgw.users.uid
us-east-1.rgw.buckets.index
us-east-1.rgw.buckets.data
us-east-1.rgw.meta</screen>
   <para>
    Esses pools também podem ser criados em outras zonas substituindo <literal>us-east-1</literal> pelo nome da zona apropriado.
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-realm">
   <title>Criando um domínio</title>
   <para>
    Configure um domínio chamado <literal>gold</literal> e torne-o o domínio padrão:
   </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin realm create --rgw-realm=gold --default
{
  "id": "4a367026-bd8f-40ee-b486-8212482ddcd7",
  "name": "gold",
  "current_period": "09559832-67a4-4101-8b3f-10dfcd6b2707",
  "epoch": 1
}</screen>
   <para>
    Observe que cada domínio tem um ID, que permite flexibilidade, como renomear um domínio no futuro, se necessário. <literal>current_period</literal> muda sempre que alguma coisa é modificada na zona master. <literal>epoch</literal> é incrementado quando há alguma mudança na configuração da zona master que resulta na mudança do período atual.
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-deldefzonegrp">
   <title>Apagando o grupo de zonas padrão</title>
   <para>
    A instalação padrão do Object Gateway cria o grupo de zonas padrão chamado <literal>default</literal>. Como não precisamos mais do grupo de zonas padrão, remova-o.
   </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin zonegroup delete --rgw-zonegroup=default</screen>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-createmasterzonegrp">
   <title>Criando um grupo de zonas master</title>
   <para>
    Crie um grupo de zonas master chamado <literal>us</literal>. O grupo de zonas gerenciará o mapa de grupo de zonas e propagará as mudanças para o restante do sistema. Ao marcar o grupo de zonas como padrão, você permite mencionar explicitamente o switch rgw-zonegroup para comandos futuros.
   </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin zonegroup create --rgw-zonegroup=us \
--endpoints=http://rgw1:80 --master --default
{
  "id": "d4018b8d-8c0d-4072-8919-608726fa369e",
  "name": "us",
  "api_name": "us",
  "is_master": "true",
  "endpoints": [
      "http:\/\/rgw1:80"
  ],
  "hostnames": [],
  "hostnames_s3website": [],
  "master_zone": "",
  "zones": [],
  "placement_targets": [],
  "default_placement": "",
  "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
}</screen>
   <para>
    Se preferir, você poderá marcar um grupo de zonas como padrão com o seguinte comando:
   </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin zonegroup default --rgw-zonegroup=us</screen>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-masterzone">
   <title>Criando uma zona master</title>
   <para>
    Agora, crie uma zona padrão e adicione-a ao grupo de zonas padrão. Observe que você usará essa zona para operações de metadados, como criação de usuário:
   </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin zone create --rgw-zonegroup=us --rgw-zone=us-east-1 \
--endpoints=http://rgw1:80 --access-key=<replaceable>$SYSTEM_ACCESS_KEY</replaceable> --secret=<replaceable>$SYSTEM_SECRET_KEY</replaceable>
{
  "id": "83859a9a-9901-4f00-aa6d-285c777e10f0",
  "name": "us-east-1",
  "domain_root": "us-east-1/gc.rgw.data.root",
  "control_pool": "us-east-1/gc.rgw.control",
  "gc_pool": "us-east-1/gc.rgw.gc",
  "log_pool": "us-east-1/gc.rgw.log",
  "intent_log_pool": "us-east-1/gc.rgw.intent-log",
  "usage_log_pool": "us-east-1/gc.rgw.usage",
  "user_keys_pool": "us-east-1/gc.rgw.users.keys",
  "user_email_pool": "us-east-1/gc.rgw.users.email",
  "user_swift_pool": "us-east-1/gc.rgw.users.swift",
  "user_uid_pool": "us-east-1/gc.rgw.users.uid",
  "system_key": {
      "access_key": "1555b35654ad1656d804",
      "secret_key": "h7GhxuBLTrlhVUyxSPUKUV8r\/2EI4ngqJxD7iBdBYLhwluN30JaT3Q=="
  },
  "placement_pools": [
      {
          "key": "default-placement",
          "val": {
              "index_pool": "us-east-1/gc.rgw.buckets.index",
              "data_pool": "us-east-1/gc.rgw.buckets.data",
              "data_extra_pool": "us-east-1/gc.rgw.buckets.non-ec",
              "index_type": 0
          }
      }
  ],
  "metadata_heap": "us-east-1/gc.rgw.meta",
  "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
}</screen>
   <para>
    Observe que os switches <option>--rgw-zonegroup</option> e <option>--default</option> adicionam a zona a um grupo de zonas e a tornam padrão. Se preferir, o mesmo também pode ser feito com os seguintes comandos:
   </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin zone default --rgw-zone=us-east-1
<prompt>cephadm@adm &gt; </prompt>radosgw-admin zonegroup add --rgw-zonegroup=us --rgw-zone=us-east-1</screen>
   <sect3 xml:id="ceph-rgw-fed-masterzone-createuser">
    <title>Criando usuários do sistema</title>
    <para>
     Para acessar os pools da zona, você precisa criar um usuário do sistema. Observe que você também precisará dessas chaves durante a configuração da zona secundária.
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin user create --uid=zone.user \
--display-name="Zone User" --access-key=<replaceable>$SYSTEM_ACCESS_KEY</replaceable> \
--secret=<replaceable>$SYSTEM_SECRET_KEY</replaceable> --system</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-masterzone-updateperiod">
    <title>Atualizar o período</title>
    <para>
     Como você mudou a configuração da zona master, precisa confirmar as modificações para que elas entrem em vigor na estrutura de configuração do domínio. Inicialmente, o período tem esta aparência:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin period get
{
  "id": "09559832-67a4-4101-8b3f-10dfcd6b2707", "epoch": 1, "predecessor_uuid": "", "sync_status": [], "period_map":
  {
    "id": "09559832-67a4-4101-8b3f-10dfcd6b2707", "zonegroups": [], "short_zone_ids": []
  }, "master_zonegroup": "", "master_zone": "", "period_config":
  {
     "bucket_quota": {
     "enabled": false, "max_size_kb": -1, "max_objects": -1
     }, "user_quota": {
       "enabled": false, "max_size_kb": -1, "max_objects": -1
     }
  }, "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7", "realm_name": "gold", "realm_epoch": 1
}</screen>
    <para>
     Atualize o período e confirme as mudanças:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin period update --commit
{
  "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
  "epoch": 1,
  "predecessor_uuid": "09559832-67a4-4101-8b3f-10dfcd6b2707",
  "sync_status": [ "[...]"
  ],
  "period_map": {
      "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
      "zonegroups": [
          {
              "id": "d4018b8d-8c0d-4072-8919-608726fa369e",
              "name": "us",
              "api_name": "us",
              "is_master": "true",
              "endpoints": [
                  "http:\/\/rgw1:80"
              ],
              "hostnames": [],
              "hostnames_s3website": [],
              "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "zones": [
                  {
                      "id": "83859a9a-9901-4f00-aa6d-285c777e10f0",
                      "name": "us-east-1",
                      "endpoints": [
                          "http:\/\/rgw1:80"
                      ],
                      "log_meta": "true",
                      "log_data": "false",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  }
              ],
              "placement_targets": [
                  {
                      "name": "default-placement",
                      "tags": []
                  }
              ],
              "default_placement": "default-placement",
              "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
          }
      ],
      "short_zone_ids": [
          {
              "key": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "val": 630926044
          }
      ]
  },
  "master_zonegroup": "d4018b8d-8c0d-4072-8919-608726fa369e",
  "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
  "period_config": {
      "bucket_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      },
      "user_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      }
  },
  "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7",
  "realm_name": "gold",
  "realm_epoch": 2
}</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-masterzone-startrgw">
    <title>Iniciar o Object Gateway</title>
    <para>
     É necessário mencionar as opções de zona e porta do Object Gateway no arquivo de configuração antes de iniciá-lo. Para obter mais informações sobre o Object Gateway e sua configuração, consulte o <xref linkend="cha-ceph-gw"/>. A seção de configuração do Object Gateway deve ser semelhante a esta:
    </para>
<screen>[client.rgw.us-east-1]
rgw_frontends="beast port=80"
rgw_zone=us-east-1</screen>
    <para>
     Inicie o Object Gateway:
    </para>
<screen><prompt>root # </prompt>systemctl start ceph-radosgw@rgw.us-east-1</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-secondaryzone">
   <title>Criando uma zona secundária</title>
   <para>
    As zonas dentro de um grupo de zonas replicam todos os dados para garantir que cada zona tenha os mesmos dados. Ao criar a zona secundária, execute todas as operações a seguir em um host identificado para processar a zona secundária.
   </para>
   <para>
    No cluster secundário, crie e configure a zona secundária chamada <literal>us-east-2</literal>. Você pode executar todos os comandos a seguir no nó que hospeda a própria zona master.
   </para>
   <para>
    Para criar a zona secundária, execute o mesmo comando de quando você criou a zona primária, mas descartando o flag de master:
   </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin zone create --rgw-zonegroup=us --endpoints=http://rgw2:80 \
--rgw-zone=us-east-2 --access-key=<replaceable>$SYSTEM_ACCESS_KEY</replaceable> --secret=<replaceable>$SYSTEM_SECRET_KEY</replaceable>
{
  "id": "950c1a43-6836-41a2-a161-64777e07e8b8",
  "name": "us-east-2",
  "domain_root": "us-east-2.rgw.data.root",
  "control_pool": "us-east-2.rgw.control",
  "gc_pool": "us-east-2.rgw.gc",
  "log_pool": "us-east-2.rgw.log",
  "intent_log_pool": "us-east-2.rgw.intent-log",
  "usage_log_pool": "us-east-2.rgw.usage",
  "user_keys_pool": "us-east-2.rgw.users.keys",
  "user_email_pool": "us-east-2.rgw.users.email",
  "user_swift_pool": "us-east-2.rgw.users.swift",
  "user_uid_pool": "us-east-2.rgw.users.uid",
  "system_key": {
      "access_key": "1555b35654ad1656d804",
      "secret_key": "h7GhxuBLTrlhVUyxSPUKUV8r\/2EI4ngqJxD7iBdBYLhwluN30JaT3Q=="
  },
  "placement_pools": [
      {
          "key": "default-placement",
          "val": {
              "index_pool": "us-east-2.rgw.buckets.index",
              "data_pool": "us-east-2.rgw.buckets.data",
              "data_extra_pool": "us-east-2.rgw.buckets.non-ec",
              "index_type": 0
          }
      }
  ],
  "metadata_heap": "us-east-2.rgw.meta",
  "realm_id": "815d74c2-80d6-4e63-8cfc-232037f7ff5c"
}</screen>
   <sect3 xml:id="ceph-rgw-fed-secondzone-updateperiod">
    <title>Atualizar o período</title>
    <para>
     Informe todos os gateways sobre a nova mudança no mapa do sistema fazendo uma atualização do período e confirmando as modificações:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin period update --commit
{
  "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
  "epoch": 2,
  "predecessor_uuid": "09559832-67a4-4101-8b3f-10dfcd6b2707",
  "sync_status": [ "[...]"
  ],
  "period_map": {
      "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
      "zonegroups": [
          {
              "id": "d4018b8d-8c0d-4072-8919-608726fa369e",
              "name": "us",
              "api_name": "us",
              "is_master": "true",
              "endpoints": [
                  "http:\/\/rgw1:80"
              ],
              "hostnames": [],
              "hostnames_s3website": [],
              "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "zones": [
                  {
                      "id": "83859a9a-9901-4f00-aa6d-285c777e10f0",
                      "name": "us-east-1",
                      "endpoints": [
                          "http:\/\/rgw1:80"
                      ],
                      "log_meta": "true",
                      "log_data": "false",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  },
                  {
                      "id": "950c1a43-6836-41a2-a161-64777e07e8b8",
                      "name": "us-east-2",
                      "endpoints": [
                          "http:\/\/rgw2:80"
                      ],
                      "log_meta": "false",
                      "log_data": "true",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  }

              ],
              "placement_targets": [
                  {
                      "name": "default-placement",
                      "tags": []
                  }
              ],
              "default_placement": "default-placement",
              "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
          }
      ],
      "short_zone_ids": [
          {
              "key": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "val": 630926044
          },
          {
              "key": "950c1a43-6836-41a2-a161-64777e07e8b8",
              "val": 4276257543
          }

      ]
  },
  "master_zonegroup": "d4018b8d-8c0d-4072-8919-608726fa369e",
  "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
  "period_config": {
      "bucket_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      },
      "user_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      }
  },
  "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7",
  "realm_name": "gold",
  "realm_epoch": 2
}</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-secondzone-startrgw">
    <title>Iniciar o Object Gateway</title>
    <para>
     Ajuste a configuração do Object Gateway para a zona secundária e inicie-o:
    </para>
<screen>[client.rgw.us-east-2]
rgw_frontends="beast port=80"
rgw_zone=us-east-2</screen>
<screen><prompt>cephadm@adm &gt; </prompt>sudo systemctl start ceph-radosgw@rgw.us-east-2</screen>
   </sect3>
   <sect3 xml:id="ceph-update-dashboard-config">
    <title>Atualizando a configuração do Ceph Dashboard</title>
    <procedure>
     <step>
      <para>
       Defina o seguinte para atualizar a configuração do painel de controle para multissite com base nas variáveis de chave secreta e de acesso:
      </para>
<screen><prompt>cephadm@adm &gt; </prompt>ceph dashboard set-rgw-api-access-key <replaceable>ACCESS-KEY</replaceable>
<prompt>cephadm@adm &gt; </prompt>ceph dashboard set-rgw-api-secret-key <replaceable>SECRET-KEY</replaceable>
</screen>
     </step>
     <step>
      <para>
       Defina o padrão do painel de controle como <literal>admin</literal>:
      </para>
<screen><prompt>cephadm@adm &gt; </prompt>ceph dashboard set-rgw-api-user-id admin</screen>
     </step>
     <step>
      <para>
       Desabilite e reabilite o painel de controle para aplicar as configurações.
      </para>
<screen><prompt>cephadm@adm &gt; </prompt>ceph mgr module disable dashboard
<prompt>cephadm@adm &gt; </prompt> ceph mgr module enable dashboard
</screen>
     </step>
     <step>
      <para>
       Se o nó do Object Gateway for modificado ou um balanceador de carga for usado no lugar dos Object Gateways, atualize o painel de controle:
      </para>
<screen><prompt>cephadm@adm &gt; </prompt>dashboard set-rgw-api-host <replaceable>HOST</replaceable>
<prompt>cephadm@adm &gt; </prompt>dashboard set-rgw-api-port <replaceable>PORT</replaceable>
</screen>
     </step>
    </procedure>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-seccluster">
   <title>Adicionando o Object Gateway ao segundo cluster</title>
   <para>
    O segundo cluster do Ceph pertence ao mesmo grupo de zonas que o inicial, mas pode estar geograficamente em qualquer outro lugar.
   </para>
   <sect3 xml:id="ceph-rgw-fed-seccluster-realm">
    <title>Domínio padrão e grupo de zonas</title>
    <para>
     Como você já criou o domínio para o primeiro gateway, insira-o aqui e torne-o padrão:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin realm pull --url=http://rgw1:80 \
--access-key=<replaceable>$SYSTEM_ACCESS_KEY</replaceable> --secret=<replaceable>$SYSTEM_SECRET_KEY</replaceable>
{
  "id": "4a367026-bd8f-40ee-b486-8212482ddcd7",
  "name": "gold",
  "current_period": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
  "epoch": 2
}
<prompt>cephadm@adm &gt; </prompt>radosgw-admin realm default --rgw-realm=gold</screen>
    <para>
     Obtenha a configuração da zona master extraindo o período:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin period pull --url=http://rgw1:80 \
--access-key=<replaceable>$SYSTEM_ACCESS_KEY</replaceable> --secret=<replaceable>$SYSTEM_SECRET_KEY</replaceable></screen>
    <para>
     Defina o grupo de zonas padrão como o grupo <literal>us</literal> já criado:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin zonegroup default --rgw-zonegroup=us</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-seccluster-seczone">
    <title>Configuração da zona secundária</title>
    <para>
     Crie uma nova zona chamada <literal>us-west</literal> com as mesmas chaves do sistema:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin zone create --rgw-zonegroup=us --rgw-zone=us-west \
--access-key=<replaceable>$SYSTEM_ACCESS_KEY</replaceable> --secret=<replaceable>$SYSTEM_SECRET_KEY</replaceable> \
--endpoints=http://rgw3:80 --default
{
  "id": "950c1a43-6836-41a2-a161-64777e07e8b8",
  "name": "us-west",
  "domain_root": "us-west.rgw.data.root",
  "control_pool": "us-west.rgw.control",
  "gc_pool": "us-west.rgw.gc",
  "log_pool": "us-west.rgw.log",
  "intent_log_pool": "us-west.rgw.intent-log",
  "usage_log_pool": "us-west.rgw.usage",
  "user_keys_pool": "us-west.rgw.users.keys",
  "user_email_pool": "us-west.rgw.users.email",
  "user_swift_pool": "us-west.rgw.users.swift",
  "user_uid_pool": "us-west.rgw.users.uid",
  "system_key": {
      "access_key": "1555b35654ad1656d804",
      "secret_key": "h7GhxuBLTrlhVUyxSPUKUV8r\/2EI4ngqJxD7iBdBYLhwluN30JaT3Q=="
  },
  "placement_pools": [
      {
          "key": "default-placement",
          "val": {
              "index_pool": "us-west.rgw.buckets.index",
              "data_pool": "us-west.rgw.buckets.data",
              "data_extra_pool": "us-west.rgw.buckets.non-ec",
              "index_type": 0
          }
      }
  ],
  "metadata_heap": "us-west.rgw.meta",
  "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
}</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-seccluster-period">
    <title>Atualizar o período</title>
    <para>
     Para propagar as mudanças do mapa de grupo de zonas, atualizamos e confirmamos o período:
    </para>
<screen><prompt>cephadm@adm &gt; </prompt>radosgw-admin period update --commit --rgw-zone=us-west
{
  "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
  "epoch": 3,
  "predecessor_uuid": "09559832-67a4-4101-8b3f-10dfcd6b2707",
  "sync_status": [
      "", # truncated
  ],
  "period_map": {
      "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
      "zonegroups": [
          {
              "id": "d4018b8d-8c0d-4072-8919-608726fa369e",
              "name": "us",
              "api_name": "us",
              "is_master": "true",
              "endpoints": [
                  "http:\/\/rgw1:80"
              ],
              "hostnames": [],
              "hostnames_s3website": [],
              "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "zones": [
                  {
                      "id": "83859a9a-9901-4f00-aa6d-285c777e10f0",
                      "name": "us-east-1",
                      "endpoints": [
                          "http:\/\/rgw1:80"
                      ],
                      "log_meta": "true",
                      "log_data": "true",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  },
                                  {
                      "id": "950c1a43-6836-41a2-a161-64777e07e8b8",
                      "name": "us-east-2",
                      "endpoints": [
                          "http:\/\/rgw2:80"
                      ],
                      "log_meta": "false",
                      "log_data": "true",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  },
                  {
                      "id": "d9522067-cb7b-4129-8751-591e45815b16",
                      "name": "us-west",
                      "endpoints": [
                          "http:\/\/rgw3:80"
                      ],
                      "log_meta": "false",
                      "log_data": "true",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  }
              ],
              "placement_targets": [
                  {
                      "name": "default-placement",
                      "tags": []
                  }
              ],
              "default_placement": "default-placement",
              "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
          }
      ],
      "short_zone_ids": [
          {
              "key": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "val": 630926044
          },
          {
              "key": "950c1a43-6836-41a2-a161-64777e07e8b8",
              "val": 4276257543
          },
          {
              "key": "d9522067-cb7b-4129-8751-591e45815b16",
              "val": 329470157
          }
      ]
  },
  "master_zonegroup": "d4018b8d-8c0d-4072-8919-608726fa369e",
  "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
  "period_config": {
      "bucket_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      },
      "user_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      }
  },
  "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7",
  "realm_name": "gold",
  "realm_epoch": 2
}</screen>
    <para>
     Observe que o número da época do período foi incrementado, o que indica uma mudança na configuração.
    </para>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-seccluster-rgwstart">
    <title>Iniciar o Object Gateway</title>
    <para>
     O procedimento é quase igual a iniciar o Object Gateway na primeira zona. A única diferença é que a configuração da zona do Object Gateway deve refletir o nome da zona <literal>us-west</literal>:
    </para>
<screen>[client.rgw.us-west]
rgw_frontends="beast port=80"
rgw_zone=us-west</screen>
    <para>
     Inicie o segundo Object Gateway:
    </para>
<screen><prompt>root # </prompt>systemctl start ceph-radosgw@rgw.us-west</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-fed-failover">
   <title>Failover e recuperação de desastre</title>
   <para>
    Se a zona master falhar, faça o failover para a zona secundária para recuperação de desastre.
   </para>
   <procedure>
    <step>
     <para>
      Converta a zona secundária na zona master e padrão. Por exemplo:
     </para>
<screen>
<prompt>cephadm@adm &gt; </prompt><command>radosgw-admin</command> zone modify --rgw-zone=<replaceable>ZONE-NAME</replaceable> --master --default
     </screen>
     <para>
      Por padrão, o Ceph Object Gateway será executado em uma configuração ativa-ativa. Se o cluster foi configurado para ser executado em uma configuração ativa-passiva, a zona secundária é uma zona apenas leitura. Remova o status --read-only para permitir que a zona receba as operações de gravação. Por exemplo:
     </para>
<screen>
<prompt>cephadm@adm &gt; </prompt><command>radosgw-admin</command> zone modify --rgw-zone=<replaceable>ZONE-NAME</replaceable> --master --default \
--read-only=False
     </screen>
    </step>
    <step>
     <para>
      Atualize o período para que as mudanças entrem em vigor.
     </para>
<screen>
<prompt>cephadm@adm &gt; </prompt><command>radosgw-admin</command> period update --commit
     </screen>
    </step>
    <step>
     <para>
      Por fim, reinicie o Ceph Object Gateway.
     </para>
<screen>
<prompt>root # </prompt><command>systemctl</command> restart ceph-radosgw@rgw.`hostname -s`
     </screen>
    </step>
   </procedure>
   <para>
    Se a zona master anterior for recuperada, reverta a operação.
   </para>
   <procedure>
    <step>
     <para>
      Da zona recuperada, extraia o período da zona master atual.
     </para>
<screen>
<prompt>cephadm@adm &gt; </prompt><command>radosgw-admin</command> period pull --url=<replaceable>URL-TO-MASTER-ZONE-GATEWAY</replaceable> \
--access-key=<replaceable>ACCESS-KEY</replaceable> --secret=<replaceable>SECRET</replaceable>
     </screen>
    </step>
    <step>
     <para>
      Converta a zona recuperada na zona master e padrão.
     </para>
<screen>
<prompt>cephadm@adm &gt; </prompt><command>radosgw-admin</command> zone modify --rgw-zone=<replaceable>ZONE-NAME</replaceable> --master --default
     </screen>
    </step>
    <step>
     <para>
      Atualize o período para que as mudanças entrem em vigor.
     </para>
<screen>
<prompt>cephadm@adm &gt; </prompt><command>radosgw-admin</command> period update --commit
     </screen>
    </step>
    <step>
     <para>
      Em seguida, reinicie o Ceph Object Gateway na zona recuperada.
     </para>
<screen>
<prompt>root # </prompt><command>systemctl</command> restart ceph-radosgw@rgw.`hostname -s`
     </screen>
    </step>
    <step>
     <para>
      Se a zona secundária precisar de uma configuração apenas leitura, atualize-a.
     </para>
<screen>
<prompt>cephadm@adm &gt; </prompt><command>radosgw-admin</command> zone modify --rgw-zone=<replaceable>ZONE-NAME</replaceable> --read-only
     </screen>
    </step>
    <step>
     <para>
      Atualize o período para que as mudanças entrem em vigor.
     </para>
<screen>
<prompt>cephadm@adm &gt; </prompt><command>radosgw-admin</command> period update --commit
     </screen>
    </step>
    <step>
     <para>
      Por fim, reinicie o Ceph Object Gateway na zona secundária.
     </para>
<screen>
<prompt>root # </prompt><command>systemctl</command> restart ceph-radosgw@rgw.`hostname -s`
     </screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-haproxy">
  <title>Equilibrando a carga dos servidores Object Gateway com HAProxy</title>

  <para>
   Você pode usar o balanceador de carga HAProxy para distribuir todas as solicitações entre os vários servidores Object Gateway de back end. Consulte <link xlink:href="https://www.suse.com/documentation/sle-ha-15/book_sleha_guide/data/sec_ha_lb_haproxy.html"/> para obter mais detalhes sobre como configurar o HAProxy.
  </para>

  <para>
   Veja a seguir uma configuração simples do HAProxy para equilibrar os nós do Object Gateway usando o rodízio como algoritmo de equilíbrio:
  </para>

<screen>
<prompt>tux &gt; </prompt>cat /etc/haproxy/haproxy.cfg
[...]
frontend <replaceable>HTTPS_FRONTEND</replaceable>
bind *:443 crt <replaceable>path-to-cert.pem</replaceable> [ciphers: ... ]
default_backend rgw

backend rgw
mode http
balance roundrobin
server rgw_server1 <replaceable>RGW-ENDPOINT1</replaceable> weight 1 maxconn 100 check
server rgw_server2 <replaceable>RGW-ENDPOINT2</replaceable> weight 1 maxconn 100 check
[...]
</screen>
 </sect1>
</chapter>
