<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="admin_ceph_cephfs.xml" version="5.0" xml:id="cha.ceph.cephfs">


 <title>集群文件系统</title>
 <info>
      <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
        <dm:maintainer>tbazant@suse.com</dm:maintainer>
        <dm:status>编辑</dm:status>
        <dm:deadline/>
        <dm:priority/>
        <dm:translation>yes</dm:translation>
        <dm:languages/>
        <dm:release>SES 5</dm:release>
      </dm:docmanager>
    </info>
    <para>
  本章介绍在设置集群并导出 CephFS 后通常应执行的管理任务。如需有关设置 CephFS 的详细信息，请参见<xref linkend="cha.ceph.as.cephfs"/>。
 </para>
 <sect1 xml:id="ceph.cephfs.cephfs.mount">
  <title>挂载 CephFS</title>

  <para>
   创建文件系统后，如果 MDS 可用，您便可以从客户端主机挂载文件系统。
  </para>

  <sect2 xml:id="cephfs.client_preparation">
   <title>客户端准备</title>
   <para>
    如果客户端主机运行的是 SUSE Linux Enterprise 12 SP2 或 SP3，您可以跳过本节，因为系统无需额外配置即可挂载 CephFS。
   </para>
   <para>
    如果客户端主机运行的是 SUSE Linux Enterprise 12 SP1，您需要应用所有最新的增补程序，之后才能挂载 CephFS。
   </para>
   <para>
    无论是哪一种情况，SUSE Linux Enterprise 中都包含了挂载 CephFS 需要的所有项目。不需要 SUSE Enterprise Storage 产品。
   </para>
   <para>
    为了支持完整的 <command>mount</command> 语法，在尝试挂载 CephFS 之前，应该先安装
    <package>ceph-common</package> 包（随附于 SUSE Linux Enterprise 中）。
   </para>
  </sect2>

  <sect2 xml:id="Creating_Secret_File">
   <title>创建机密文件</title>
   <para>
    Ceph 集群默认是在启用身份验证的情况下运行的。应该创建一个文件用于存储您的机密密钥（而不是密钥环本身）。要获取特定用户的机密密钥，然后创建该文件，请执行以下操作：
   </para>
   <procedure>
    <title>创建机密密钥</title>
    <step>
     <para>
      在密钥环文件中查看特定用户的密钥：
     </para>
<screen>cat /etc/ceph/ceph.client.admin.keyring</screen>
    </step>
    <step>
     <para>
      复制要使用所挂载 Ceph FS 文件系统的用户的密钥。密钥通常类似下方所示：
     </para>
<screen>AQCj2YpRiAe6CxAA7/ETt7Hcl9IyxyYciVs47w==</screen>
    </step>
    <step>
     <para>
      为用户 <emphasis>admin</emphasis> 创建一个文件名包含用户名的文件，例如 <filename>/etc/ceph/admin.secret</filename>。
     </para>
    </step>
    <step>
     <para>
      将密钥值粘贴到上一步中创建的文件。
     </para>
    </step>
    <step>
     <para>
      设置对该文件的适当访问权限。该用户应是唯一有权读取该文件的用户，其他人不能有任何访问权限。
     </para>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="ceph.cephfs.krnldrv">
   <title>挂载 CephFS</title>
   <para>
    可以使用 <command>mount</command> 命令挂载 CephFS。需要指定监视器的主机名或 IP 地址。由于 SUSE Enterprise Storage 中默认会启用 <systemitem>cephx</systemitem> 身份验证，因此，您还需要指定一个用户名及其相关的机密：
   </para>
<screen>sudo mount -t ceph ceph_mon1:6789:/ /mnt/cephfs \
 -o name=admin,secret=AQATSKdNGBnwLhAAnNDKnH65FmVKpXZJVasUeQ==</screen>
   <para>
    由于上一条命令会保留在外壳历史中，因此更安全的做法是从文件读取机密：
   </para>
<screen>sudo mount -t ceph ceph_mon1:6789:/ /mnt/cephfs \
 -o name=admin,secretfile=/etc/ceph/admin.secret</screen>
   <para>
    请注意，机密文件应该只包含实际的密钥环机密。因此，在本示例中，该文件只包含下行：
   </para>
<screen>AQATSKdNGBnwLhAAnNDKnH65FmVKpXZJVasUeQ==</screen>
   <tip>
    <title>指定多个监视器</title>
    <para>
     最好是在 <command>mount</command> 命令行中指定多个监视器并以逗号分隔，以防在挂载时某个监视器恰好停机。每个监视器的地址采用<literal>主机[:端口]</literal> 格式。如果未指定端口，默认会使用端口 6789。
    </para>
   </tip>
   <para>
    在本地主机上创建挂载点：
   </para>
<screen>sudo mkdir /mnt/cephfs</screen>
   <para>
    挂载 CephFS：
   </para>
<screen>sudo mount -t ceph ceph_mon1:6789:/ /mnt/cephfs \
 -o name=admin,secretfile=/etc/ceph/admin.secret</screen>
   <para>
    如果要挂载文件系统的某个子集，可以指定子目录 <filename>subdir</filename>：
   </para>
<screen>sudo mount -t ceph ceph_mon1:6789:/subdir /mnt/cephfs \
 -o name=admin,secretfile=/etc/ceph/admin.secret</screen>
   <para>
    可在 <command>mount</command> 命令中指定多个监视器主机：
   </para>
<screen>sudo mount -t ceph ceph_mon1,ceph_mon2,ceph_mon3:6789:/ /mnt/cephfs \
 -o name=admin,secretfile=/etc/ceph/admin.secret</screen>
   <important>
    <title>对根目录的读取访问权限</title>
    <para>
     如果使用了实施路径限制的客户端，则 MDS 功能需要包含对根目录的读取访问权限。例如，密钥环可能如下所示：
    </para>
<screen>client.bar
 key: supersecretkey
 caps: [mds] allow rw path=/barjail, allow r path=/
 caps: [mon] allow r
 caps: [osd] allow rwx</screen>
    <para>
     <literal>allow r path=/</literal> 部分表示路径受限的客户端能够查看根卷，但无法写入根卷。在要求完全隔离的用例中，这可能会造成问题。
    </para>
   </important>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph.cephfs.cephfs.unmount">
  <title>卸载 CephFS</title>

  <para>
   要卸载 CephFS，请使用 <command>umount</command> 命令：
  </para>

<screen>sudo umount /mnt/cephfs</screen>
 </sect1>
 <sect1 xml:id="ceph.cephfs.cephfs.fstab">
  <title><filename>/etc/fstab</filename> 中的 CephFS</title>

  <para>
   要在客户端启动时自动挂载 CephFS，请在其文件系统表 <filename>/etc/fstab</filename> 中插入相应的行：
  </para>

<screen>mon1:6790,mon2:/subdir /mnt/cephfs ceph name=admin,secretfile=/etc/ceph/secret.key,noatime,_netdev 0 2</screen>
 </sect1>
 <sect1 xml:id="ceph.cephfs.activeactive">
  <title>多个活动 MDS 守护进程（主动/主动 MDS）</title>

  <para>
   默认情况下，CephFS 是针对单个活动 MDS 守护进程配置的。要调整大规模系统的元数据性能，可以启用多个活动 MDS 守护进程，以便互相分担元数据工作负载。
  </para>

  <sect2>
   <title>何时使用主动/主动 MDS</title>
   <para>
    如果按默认设置使用单个 MDS 时元数据性能出现瓶颈，可考虑使用多个活动 MDS 守护进程。
   </para>
   <para>
    增加守护进程并不会提高所有工作负载类型的性能。例如，增加 MDS 守护进程的数量不会让单个客户端上运行的单个应用受益，除非该应用在同时执行大量元数据操作。
   </para>
   <para>
    通常能够因大量活动 MDS 守护进程受益的工作负载是使用许多客户端的工作负载，也许是在许多独立目录中工作的工作负载。
   </para>
  </sect2>

  <sect2 xml:id="cephfs.activeactive.increase">
   <title>增加 MDS 活动集群的大小</title>
   <para>
    每个 CephFS 文件系统都有一项 <option>max_mds</option> 设置，用于控制将要创建的级别数。仅当某个备用守护进程可供新的级别使用时，文件系统中的实际级别数才会增加。例如，如果只有一个 MDS 守护进程在运行，并且 <option>max_mds</option> 设置为 2，将不会创建另一个级别。
   </para>
   <para>
    在下面的示例中，我们将 <option>max_mds</option> 选项设置为 2，以便在保留默认级别的情况下再创建一个新级别。要查看更改，请在设置 <option>max_mds</option> 之前和之后运行 <command>ceph status</command>，然后观察包含 <literal>fsmap</literal> 的行：
   </para>
<screen><prompt>root@master # </prompt><command>ceph</command> status
  [...]
  services:
    [...]
    mds: cephfs-1/1/1 up  {0=node2=up:active}, 1 up:standby
    [...]
<prompt>root@master # </prompt><command>ceph</command> mds set max_mds 2
<prompt>root@master # </prompt><command>ceph</command> status
  [...]
  services:
    [...]
    mds: cephfs-2/2/2 up  {0=node2=up:active,1=node1=up:active}
    [...]</screen>
   <para>
    新建的级别 (1) 会经历“正在创建”状态，然后进入“活动”状态。
   </para>
   <important>
    <title>待机守护进程</title>
    <para>
     即使使用多个活动 MDS 守护进程，当任何在运行活动守护进程的服务器发生故障时，高可用性系统也仍会要求待机守护进程接管工作。
    </para>
    <para>
     因此，高可用性系统的 <option>max_mds</option> 合理最大值比系统中的 MDS 服务器总数小 1。要在发生多次服务器故障时保持可用性，可增加系统中待机守护进程的数量，使之与不会导致失去可用性的服务器故障数一致。
    </para>
   </important>
  </sect2>

  <sect2 xml:id="cephfs.activeactive.decrease">
   <title>减小级别数</title>
   <para>
    所有级别（包括要删除的级别）首先必须是活动的。这意味着，至少需要有 <option>max_mds</option> 个 MDS 守护进程可用。
   </para>
   <para>
    首先，将 <option>max_mds</option> 设为一个较小的数字。例如，我们重新使用单个活动 MDS：
   </para>
<screen><prompt>root@master # </prompt><command>ceph</command> status
  [...]
  services:
    [...]
    mds: cephfs-2/2/2 up  {0=node2=up:active,1=node1=up:active}
    [...]
<prompt>root@master # </prompt><command>ceph</command> mds set max_mds 1
<prompt>root@master # </prompt><command>ceph</command> status
  [...]
  services:
    [...]
    mds: cephfs-1/1/1 up  {0=node2=up:active}, 1 up:standby
    [...]</screen>
   <para>
    请注意，我们仍有两个活动 MDS。即使减小 <option>max_mds</option>，级别也仍会存在，因为 <option>max_mds</option> 只会限制新级别的创建。
   </para>
   <para>
    接下来，使用 <command>ceph mds deactivate <replaceable>级别</replaceable></command>命令删除不需要的级别：
   </para>
<screen><prompt>root@master # </prompt><command>ceph</command> status
  [...]
  services:
    [...]
    mds: cephfs-2/2/1 up  {0=node2=up:active,1=node1=up:active}
<prompt>root@master # </prompt><command>ceph</command> mds deactivate 1
telling mds.1:1 192.168.58.101:6805/2799214375 to deactivate

<prompt>root@master # </prompt><command>ceph</command> status
  [...]
  services:
    [...]
    mds: cephfs-2/2/1 up  {0=node2=up:active,1=node1=up:stopping}

<prompt>root@master # </prompt><command>ceph</command> status
  [...]
  services:
    [...]
    mds: cephfs-1/1/1 up  {0=node2=up:active}, 1 up:standby</screen>
   <para>
    已停用的级别首先会进入“正在停止”状态并保持一段时间，期间它会将所分担的元数据负载转移给其余活动守护进程。此阶段可能需要数秒到数分钟时间。如果 MDS 看上去停滞在“正在停止”状态，则应该调查原因，确定是否存在可能的错误。
   </para>
   <para>
    如果 MDS 守护进程在“正在停止”状态下崩溃或终止，待机守护进程会接管工作，级别将恢复为“活动”状态。当此守护进程重新运行后，您可以尝试再次将它停用。
   </para>
   <para>
    守护进程结束“正在停止”状态后，将再次启动，并重新变为待机守护进程。
   </para>
  </sect2>

  <sect2 xml:id="cephfs.activeactive.pinning">
   <title>手动将目录树关联到级别</title>
   <para>
    在多个活动元数据服务器配置中，将会运行一个平衡器，用于在集群中均衡分配元数据负载。这种模式通常足以满足大多数用户的需求，但有时，用户需要使用元数据到特定级别的显式映射来覆盖动态平衡器。这样，管理员或用户便可以在整个集群上均衡地分配应用负载，或限制用户的元数据请求对整个集群的影响。
   </para>
   <para>
    针对此目的提供的机制称为“导出关联”。它是目录的扩展属性。此扩展属性名为 <literal>ceph.dir.pin</literal>。用户可以使用标准命令设置此属性：
   </para>
<screen>setfattr -n ceph.dir.pin -v 2 <replaceable>/path/to/dir</replaceable></screen>
   <para>
    扩展属性的值 (<option>-v</option>) 是要将目录子树指定到的级别。默认值 -1 表示不关联该目录。
   </para>
   <para>
    目录导出关联继承自设置了导出关联的最近的父级。因此，对某个目录设置导出关联会影响该目录的所有子级。但是，可以通过设置子目录导出关联来覆盖父级的关联。例如：
   </para>
<screen>mkdir -p a/b                      # "a" and "a/b" start with no export pin set.
setfattr -n ceph.dir.pin -v 1 a/  # "a" and "b" are now pinned to rank 1.
setfattr -n ceph.dir.pin -v 0 a/b # "a/b" is now pinned to rank 0
                                  # and "a/" and the rest of its children
                                  # are still pinned to rank 1.</screen>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph.cephfs.failover">
  <title>管理故障转移</title>

  <para>
   如果 MDS 守护进程停止与监视器通讯，监视器会等待 <option>mds_beacon_grace</option> 秒（默认为 15 秒），然后将守护进程标记为 <emphasis>laggy</emphasis>。可以配置一个或多个“待机”守护进程，用于在 MDS 守护进程故障转移期间接管工作。
  </para>

  <sect2 xml:id="ceph.cephfs.failover.standby">
   <title>配置待机守护进程</title>
   <para>
    有多项配置设置可控制守护进程处于待机状态时的行为。可以在运行 MDS 守护进程的主机上的 <filename>ceph.conf</filename> 中指定这些设置。守护进程在启动时会加载这些设置，然后将其发送到监视器。
   </para>
   <para>
    默认情况下，如果不使用其中的任何设置，则不具备级别的所有 MDS 守护进程将用作任一级别的“待机”守护进程。
   </para>
   <para>
    将待机守护进程与特定名称或级别相关联的设置不保证该守护进程只用于该级别。具体而言，当有多个待机守护进程可用时，将使用关联的待机守护进程。如果某个级别发生故障，而此时有某个待机守护进程可用，则即使该守护进程与其他某个级别或指定守护进程相关联，也会使用该守护进程。
   </para>
   <variablelist>
    <varlistentry>
     <term>mds_standby_replay</term>
     <listitem>
      <para>
       如果设置为 true，则待机守护进程将持续读取某个已启动级别的元数据日记。这就为此级别提供了一个热元数据快速缓存，当为该级别提供服务的守护进程发生故障时，此日记可加快故障转移过程的速度。
      </para>
      <para>
       一个已启动的级别只能指定一个待机重放守护进程。如果将两个守护进程都设置为待机重放，则其中任意一个会赢得控制权，另一个将成为正常的非重放待机守护进程。
      </para>
      <para>
       当某个守护进程进入待机重放状态时，它只会用作所跟随级别的待机守护进程。如果另一个级别发生故障，此待机重放守护进程不会作为替代者，即使没有其他待机守护进程可用也是如此。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>mds_standby_for_name</term>
     <listitem>
      <para>
       如果指定此设置，则仅当最后一个包含故障级别的守护进程与此名称匹配时，待机守护进程才会接管该故障级别。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>mds_standby_for_rank</term>
     <listitem>
      <para>
       如果指定此设置，待机守护进程只会接管指定的级别。如果另外的级别发生故障，将不会使用此守护进程来替代此级别。
      </para>
      <para>
       与 <option>mds_standby_for_fscid</option> 结合使用时，可以指定在使用多个文件系统时，具体针对哪个文件系统的级别。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>mds_standby_for_fscid</term>
     <listitem>
      <para>
       如果设置了 <option>mds_standby_for_rank</option>，则 mds_standby_for_fscid 只是一个用于指出所指文件系统级别的限定符。
      </para>
      <para>
       如果未设置 <option>mds_standby_for_rank</option>，则设置 FSCID 会导致此守护进程以指定 FSCID 中的任何级别为目标。如果希望只在特定的文件系统中将某个守护进程用于任何级别，可使用此设置。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>mon_force_standby_active</term>
     <listitem>
      <para>
       在监视器主机上使用此设置。其默认值为 true。
      </para>
      <para>
       如果值为 false，则 <option>standby_replay 配置为 true</option> 的守护进程只有在其已配置要跟随的级别/名称发生故障时，才会变为活动守护进程。另一方面，如果此设置为 true，则可将其他某个级别指定给 <option>standby_replay 配置为 true</option> 的守护进程。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="ceph.cephfs.failover.examples">
   <title>示例</title>
   <para>
    下面显示了多个示例 <filename>ceph.conf</filename> 配置。可将包含所有守护进程的配置的 <filename>ceph.conf</filename> 复制到所有服务器，或者在每台服务器上创建一个不同的文件，并在其中包含该服务器的守护进程配置。
   </para>
   <sect3>
    <title>简单对</title>
    <para>
     “a”和“b”两个 MDS 守护进程充当一对。其中，当前未指定级别的守护进程将是另一个守护进程的待机重放跟随者。
    </para>
<screen>[mds.a]
mds standby replay = true
mds standby for rank = 0

[mds.b]
mds standby replay = true
mds standby for rank = 0</screen>
   </sect3>

  </sect2>
 </sect1>
</chapter>
