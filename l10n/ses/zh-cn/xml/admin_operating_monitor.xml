<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="admin_operating_monitor.xml" version="5.0" xml:id="ceph-monitor">
 <title>确定集群状态</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:translation>yes</dm:translation>
   <dm:release>SES 7</dm:release>
  </dm:docmanager>
 </info>
 <para>
  当集群正在运行时，您可以使用 <command>ceph</command> 工具来监视它。要确定集群状态，通常需要检查 Ceph OSD、Ceph Monitor、归置组和元数据服务器的状态。
 </para>
 <tip>
  <title>交互方式</title>
  <para>
   要以交互模式运行 <command>ceph</command> 工具，请不带任何参数在命令行中键入 <command>ceph</command>。如果要在一行中输入多条 <command>ceph</command> 命令，则使用交互模式较为方便。例如：
  </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph
ceph&gt; health
ceph&gt; status
ceph&gt; quorum_status
ceph&gt; mon stat</screen>
 </tip>
 <sect1 xml:id="monitor-status">
  <title>检查集群的状态</title>

  <para>
   您可以使用 <command>ceph status</command> 或 <command>ceph -s</command> 了解集群的即时状态：
  </para>

<screen>
<prompt>cephuser@adm &gt; </prompt>ceph -s
cluster:
    id:     b4b30c6e-9681-11ea-ac39-525400d7702d
    health: HEALTH_OK

  services:
    mon: 5 daemons, quorum ses-min1,ses-master,ses-min2,ses-min4,ses-min3 (age 2m)
    mgr: ses-min1.gpijpm(active, since 3d), standbys: ses-min2.oopvyh
    mds: my_cephfs:1 {0=my_cephfs.ses-min1.oterul=up:active}
    osd: 3 osds: 3 up (since 3d), 3 in (since 11d)
    rgw: 2 daemons active (myrealm.myzone.ses-min1.kwwazo, myrealm.myzone.ses-min2.jngabw)

  task status:
    scrub status:
        mds.my_cephfs.ses-min1.oterul: idle

  data:
    pools:   7 pools, 169 pgs
    objects: 250 objects, 10 KiB
    usage:   3.1 GiB used, 27 GiB / 30 GiB avail
    pgs:     169 active+clean
</screen>

  <para>
   输出内容提供了以下信息：
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     集群 ID
    </para>
   </listitem>
   <listitem>
    <para>
     集群健康状况状态
    </para>
   </listitem>
   <listitem>
    <para>
     Monitor 索引版本号和 Monitor 仲裁的状态
    </para>
   </listitem>
   <listitem>
    <para>
     OSD 索引版本号和 OSD 的状态
    </para>
   </listitem>
   <listitem>
    <para>
     Ceph Manager 的状态
    </para>
   </listitem>
   <listitem>
    <para>
     对象网关的状态
    </para>
   </listitem>
   <listitem>
    <para>
     归置组索引版本
    </para>
   </listitem>
   <listitem>
    <para>
     归置组和存储池数量
    </para>
   </listitem>
   <listitem>
    <para>
     <emphasis>理论上</emphasis>存储的数据量和存储的对象数量
    </para>
   </listitem>
   <listitem>
    <para>
     所存储数据的总量。
    </para>
   </listitem>
  </itemizedlist>

  <tip>
   <title>Ceph 计算数据使用率的方式</title>
   <para>
    <literal>used</literal> 值反映实际使用的原始存储量。<literal>xxx GB / xxx GB</literal> 值表示集群的可用容量（两者中较小的数字），以及集群的整体存储容量。理论数量反映在复制、克隆所存储数据或创建其快照前这些数据的大小。因此，实际存储的数据量通常会超出理论上的存储量，因为 Ceph 会创建数据的副本，可能还会将存储容量用于克隆和创建快照。
   </para>
  </tip>

  <para>
   显示即时状态信息的其他命令如下：
  </para>

  <itemizedlist>
   <listitem>
    <para>
     <command>ceph pg stat</command>
    </para>
   </listitem>
   <listitem>
    <para>
     <command>ceph osd pool stats</command>
    </para>
   </listitem>
   <listitem>
    <para>
     <command>ceph df</command>
    </para>
   </listitem>
   <listitem>
    <para>
     <command>ceph df detail</command>
    </para>
   </listitem>
  </itemizedlist>

  <para>
   要实时更新信息，请在 <command>watch</command> 命令中以参数的方式使用以上任意命令（包括 <command>ceph -s</command>）：
  </para>

<screen><prompt role="root"># </prompt>watch -n 10 'ceph -s'</screen>

  <para>
   如果您看累了，请按 <keycombo><keycap function="control"/><keycap>C</keycap></keycombo>。
  </para>
 </sect1>
 <sect1 xml:id="monitor-health">
  <title>检查集群健康状况</title>

  <para>
   在启动集群后到开始读取和/或写入数据期间，检查集群的健康状况：
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph health
HEALTH_WARN 10 pgs degraded; 100 pgs stuck unclean; 1 mons down, quorum 0,2 \
node-1,node-2,node-3</screen>

  <tip>
   <para>
    如果之前为您的配置或密钥环指定了非默认位置，则此时可以指定它们的位置：
   </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph -c <replaceable>/path/to/conf</replaceable> -k <replaceable>/path/to/keyring</replaceable> health</screen>
  </tip>

  <para>
   Ceph 集群会返回下列健康状况代码之一：
  </para>

  <variablelist>
   <varlistentry>
    <term>OSD_DOWN</term>
    <listitem>
     <para>
      一个或多个 OSD 标记为已停机。OSD 守护进程可能已停止，或同伴 OSD 可能无法通过网络连接 OSD。常见原因包括守护进程已停止或已崩溃、主机已停机或网络中断。
     </para>
     <para>
      校验主机是否运行良好，守护进程是否已启动，并且网络是否正常工作。如果守护进程已崩溃，守护进程日志文件 (<filename>/var/log/ceph/ceph-osd.*</filename>) 可能会包含调试信息。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OSD_<replaceable>crush type</replaceable>_DOWN，例如 OSD_HOST_DOWN</term>
    <listitem>
     <para>
      特定 CRUSH 子树中的所有 OSD 均标记为已停机，例如主机上的所有 OSD。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OSD_ORPHAN</term>
    <listitem>
     <para>
      在 CRUSH 索引层次结构中引用了 OSD，但它不存在。可使用以下命令从 CRUSH 层次结构中删除 OSD：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd crush rm osd.<replaceable>ID</replaceable></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OSD_OUT_OF_ORDER_FULL</term>
    <listitem>
     <para>
      以下项的使用率阈值未按升序排列：<emphasis>backfillfull</emphasis>（默认值为 0.90）、<emphasis>nearfull</emphasis>（默认值为 0.85）、<emphasis>full</emphasis>（默认值为 0.95）、<emphasis>failsafe_full</emphasis>。特别是，我们需要 <emphasis>backfillfull</emphasis> &lt; <emphasis>nearfull</emphasis>，<emphasis>nearfull</emphasis> &lt; <emphasis>full</emphasis> 且 <emphasis>full</emphasis> &lt; <emphasis>failsafe_full</emphasis>。
     </para>
     <para>
      要读取最新的值，请运行以下命令：
     </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph health detail
HEALTH_ERR 1 full osd(s); 1 backfillfull osd(s); 1 nearfull osd(s)
osd.3 is full at 97%
osd.4 is backfill full at 91%
osd.2 is near full at 87%
</screen>
     <para>
      可以使用以下命令调整阈值：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd set-backfillfull-ratio <replaceable>ratio</replaceable>
<prompt>cephuser@adm &gt; </prompt>ceph osd set-nearfull-ratio <replaceable>ratio</replaceable>
<prompt>cephuser@adm &gt; </prompt>ceph osd set-full-ratio <replaceable>ratio</replaceable></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OSD_FULL</term>
    <listitem>
     <para>
      一个或多个 OSD 超出了 <emphasis>full</emphasis> 阈值，阻止集群处理写入操作。可使用以下命令检查各存储池的用量：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph df</screen>
     <para>
      可使用以下命令查看当前定义的 <emphasis>full</emphasis> 比例：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd dump | grep full_ratio</screen>
     <para>
      恢复写入可用性的临时解决方法是稍稍提高 full 阈值：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd set-full-ratio <replaceable>ratio</replaceable></screen>
     <para>
      请通过部署更多 OSD 将新的存储添加到集群，或者删除现有数据来腾出空间。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OSD_BACKFILLFULL</term>
    <listitem>
     <para>
      一个或多个 OSD 超出了 <emphasis>backfillfull</emphasis> 阈值，因而不允许将数据重新平衡到此设备。这是一条预警，意味着重新平衡可能无法完成，并且集群将满。可使用以下命令检查各存储池的用量：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph df</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OSD_NEARFULL</term>
    <listitem>
     <para>
      一个或多个 OSD 超出了 <emphasis>nearfull</emphasis> 阈值。这是一条预警，意味着集群将满。可使用以下命令检查各存储池的用量：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph df</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OSDMAP_FLAGS</term>
    <listitem>
     <para>
      已设置一个或多个所需的集群标志。可使用以下命令设置或清除这些标志（<emphasis>full</emphasis> 除外）：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd set <replaceable>flag</replaceable>
<prompt>cephuser@adm &gt; </prompt>ceph osd unset <replaceable>flag</replaceable></screen>
     <para>
      这些标志包括：
     </para>
     <variablelist>
      <varlistentry>
       <term>full</term>
       <listitem>
        <para>
         集群标记为已满，无法处理写入操作。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>pauserd、pausewr</term>
       <listitem>
        <para>
         已暂停读取或写入。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>noup</term>
       <listitem>
        <para>
         不允许 OSD 启动。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>nodown</term>
       <listitem>
        <para>
         将会忽略 OSD 故障报告，如此 Monitor 便不会将 OSD 标记为 <emphasis>down</emphasis>。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>noin</term>
       <listitem>
        <para>
         先前标记为 <emphasis>out</emphasis> 的 OSD 在启动时将不会重新标记为 <emphasis>in</emphasis>。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>noout</term>
       <listitem>
        <para>
         <emphasis>停机</emphasis>的 OSD 在配置间隔过后将不会自动标记为 <emphasis>out</emphasis>。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>nobackfill、norecover、norebalance</term>
       <listitem>
        <para>
         恢复或数据重新平衡进程已暂停。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>noscrub、nodeep_scrub</term>
       <listitem>
        <para>
         洗刷进程已禁用（请参见<xref linkend="scrubbing-pgs"/>）。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>notieragent</term>
       <listitem>
        <para>
         缓存分层活动已暂停。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OSD_FLAGS</term>
    <listitem>
     <para>
      一个或多个 OSD 设置了所需的每 OSD 标志。这些标志包括：
     </para>
     <variablelist>
      <varlistentry>
       <term>noup</term>
       <listitem>
        <para>
         不允许 OSD 启动。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>nodown</term>
       <listitem>
        <para>
         将会忽略此 OSD 的故障报告。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>noin</term>
       <listitem>
        <para>
         如果此 OSD 先前在发生故障后自动标记为 <emphasis>out</emphasis>，当它启动时将不会标记为 <emphasis>in</emphasis>。
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>noout</term>
       <listitem>
        <para>
         如果此 OSD 已停机，则在配置的间隔过后，它将不会自动标记为 <emphasis>out</emphasis>。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <para>
      可使用以下命令来设置和清除每 OSD 标志：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd add-<replaceable>flag</replaceable> <replaceable>osd-ID</replaceable>
<prompt>cephuser@adm &gt; </prompt>ceph osd rm-<replaceable>flag</replaceable> <replaceable>osd-ID</replaceable></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OLD_CRUSH_TUNABLES</term>
    <listitem>
     <para>
      CRUSH 索引目前使用的设置很旧，应予以更新。<option>mon_crush_min_required_version</option> 配置选项可确定使用时不会触发此健康状况警告的最旧可调变量（即能够连接到集群的最旧客户端版本）。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OLD_CRUSH_STRAW_CALC_VERSION</term>
    <listitem>
     <para>
      CRUSH 索引目前使用较旧的非最佳方法来计算 straw 存储桶的中间权重值。应该更新 CRUSH 索引以使用较新的方法 (<option>straw_calc_version</option>=1)。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>CACHE_POOL_NO_HIT_SET</term>
    <listitem>
     <para>
      一个或多个缓存池未配置命中集来跟踪用量，这使分层代理无法识别要从缓存中刷新和赶出的冷对象。可使用以下命令对快速缓存池配置命中集：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool set <replaceable>poolname</replaceable> hit_set_type <replaceable>type</replaceable>
<prompt>cephuser@adm &gt; </prompt>ceph osd pool set <replaceable>poolname</replaceable> hit_set_period <replaceable>period-in-seconds</replaceable>
<prompt>cephuser@adm &gt; </prompt>ceph osd pool set <replaceable>poolname</replaceable> hit_set_count <replaceable>number-of-hitsets</replaceable>
<prompt>cephuser@adm &gt; </prompt>ceph osd pool set <replaceable>poolname</replaceable> hit_set_fpp <replaceable>target-false-positive-rate</replaceable></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OSD_NO_SORTBITWISE</term>
    <listitem>
     <para>
      未在运行早于 Luminous 12 版本的 OSD，但是尚未设置 <option>sortbitwise</option> 标志。您需要先设置 <option>sortbitwise</option> 标志，Luminous 12 或更新版本的 OSD 才能启动：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd set sortbitwise</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>POOL_FULL</term>
    <listitem>
     <para>
      一个或多个存储池已达到其配额，不再允许写入。可使用以下命令设置存储池配额和用量：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph df detail</screen>
     <para>
      您可以使用以下命令提高存储池配额
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool set-quota <replaceable>poolname</replaceable> max_objects <replaceable>num-objects</replaceable>
<prompt>cephuser@adm &gt; </prompt>ceph osd pool set-quota <replaceable>poolname</replaceable> max_bytes <replaceable>num-bytes</replaceable></screen>
     <para>
      或者删除一些现有数据以减少用量。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>PG_AVAILABILITY</term>
    <listitem>
     <para>
      数据可用性下降，这意味着集群无法处理针对集群中某些数据的潜在读取或写入请求。具体而言，一个或多个 PG 处于不允许处理 I/O 请求的状态。有问题的 PG 状态包括<emphasis>正在互联</emphasis>、<emphasis>过时</emphasis>、<emphasis>不完整</emphasis>和不<emphasis>工作</emphasis>（如果这些状况不迅速解决）。运行以下命令可获得有关哪些 PG 受影响的详细信息：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph health detail</screen>
     <para>
      大多数情况下，出现此情形的根本原因在于一个或多个 OSD 当前已停机。可使用以下命令查询特定的有问题 PG 的状态：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph tell <replaceable>pgid</replaceable> query</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>PG_DEGRADED</term>
    <listitem>
     <para>
      某些数据的数据冗余降低，这意味着集群没有所需数量的副本用于所有数据（对于副本存储池）或纠删码分段（对于纠删码存储池）。具体而言，一个或多个 PG 设置了 <emphasis>degraded</emphasis> 或 <emphasis>undersized</emphasis> 标志（集群中没有该归置组的足够实例），或者有一段时间未设置 <emphasis>clean</emphasis> 标志。运行以下命令可获得有关哪些 PG 受影响的详细信息：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph health detail</screen>
     <para>
      大多数情况下，出现此情形的根本原因在于一个或多个 OSD 当前已停机。可使用以下命令查询特定的有问题 PG 的状态：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph tell <replaceable>pgid</replaceable> query</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>PG_DEGRADED_FULL</term>
    <listitem>
     <para>
      由于集群中的可用空间不足，某些数据的数据冗余可能已降低或面临风险。具体而言，一个或多个 PG 设置了 <emphasis>backfill_toofull</emphasis> 或 <emphasis>recovery_tooful</emphasis> 标志，这意味着集群无法迁移或恢复数据，原因是一个或多个 OSD 高于 <emphasis>backfillfull</emphasis> 阈值。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>PG_DAMAGED</term>
    <listitem>
     <para>
      数据洗刷（请参见<xref linkend="scrubbing-pgs"/>）进程发现集群中存在某些数据一致性问题。具体而言，一个或多个 PG 设置了 <emphasis>inconsistent</emphasis> 或 <emphasis>snaptrim_error</emphasis> 标志（表示某个较早的洗刷操作发现问题），或者设置了 <emphasis>repair</emphasis> 标志（表示当前正在修复此类不一致问题）。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OSD_SCRUB_ERRORS</term>
    <listitem>
     <para>
      最近的 OSD 洗刷操作发现了不一致问题。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>CACHE_POOL_NEAR_FULL</term>
    <listitem>
     <para>
      缓存层池将满。在此环境中，“满”由缓存池的 <emphasis>target_max_bytes</emphasis> 和 <emphasis>target_max_objects</emphasis> 属性确定。池达到目标阈值时，如果正在从缓存刷新并赶出数据，写入池的请求可能会被阻止，出现常会导致延迟很高且性能变差的状态。可使用以下命令调整缓存池目标大小：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool set <replaceable>cache-pool-name</replaceable> target_max_bytes <replaceable>bytes</replaceable>
<prompt>cephuser@adm &gt; </prompt>ceph osd pool set <replaceable>cache-pool-name</replaceable> target_max_objects <replaceable>objects</replaceable></screen>
     <para>
      正常的快速缓存清理和逐出活动还可能因基础层可用性或性能下降或者集群的整体负载较高而受到限制。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>TOO_FEW_PGS</term>
    <listitem>
     <para>
      使用中的 PG 数量低于每个 OSD 的 PG 数的可配置阈值 <option>mon_pg_warn_min_per_osd</option>。这可能导致集群中各 OSD 间的数据分布和平衡未达到最佳，以致降低整体性能。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>TOO_MANY_PGS</term>
    <listitem>
     <para>
      使用中的 PG 数量高于每个 OSD 的 PG 数的可配置阈值 <option>mon_pg_warn_max_per_osd</option>。这可能导致 OSD 守护进程的内存用量较高，集群状态更改（例如 OSD 重启动、添加或删除）之后互联速度降低，并且 Ceph Manager 和 Ceph Monitor 上的负载较高。
     </para>
     <para>
      虽然不能减少现有存储池的 <option>pg_num</option> 值，但可以减少 <option>pgp_num</option> 值。这样可有效地在同组 OSD 上共置一些 PG，从而减轻上述的一些负面影响。可使用以下命令调整 <option>pgp_num</option> 值：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool set <replaceable>pool</replaceable> pgp_num <replaceable>value</replaceable></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>SMALLER_PGP_NUM</term>
    <listitem>
     <para>
      一个或多个存储池的 <option>pgp_num</option> 值小于 <option>pg_num</option>。这通常表示 PG 计数有所提高，但未同时提升归置行为。使用以下命令设置 <option>pgp_num</option>，使其与触发数据迁移的 <option>pg_num</option> 相匹配，通常便可解决此问题：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool set <replaceable>pool</replaceable> pgp_num <replaceable>pg_num_value</replaceable></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>MANY_OBJECTS_PER_PG</term>
    <listitem>
     <para>
      一个或多个存储池的每 PG 平均对象数大大高于集群的整体平均值。该特定阈值通过 <option>mon_pg_warn_max_object_skew</option> 配置值控制。这通常表示包含集群中大部分数据的存储池具有的 PG 太少，以及/或者不包含这么多数据的其他存储池具有的 PG 太多。可通过调整 Monitor 上的 <option>mon_pg_warn_max_object_skew</option> 配置选项提高阈值，来消除该健康状况警告。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>POOL_APP_NOT_ENABLED</term>
    <listitem>
     <para>
      存在包含一个或多个对象但尚未标记为供特定应用使用的存储池。将存储池标记为供某个应用使用即可消除此警告。例如，如果存储池由 RBD 使用：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>rbd pool init <replaceable>pool_name</replaceable></screen>
     <para>
      如果存储池正由自定义应用“foo”使用，您还可以使用低级别命令标记它：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool application enable foo</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>POOL_FULL</term>
    <listitem>
     <para>
      一个或多个存储池已达到（或几乎要达到）其配额。触发此错误状况的阈值通过 <option>mon_pool_quota_crit_threshold</option> 配置选项控制。可使用以下命令上调、下调（或删除）存储池配额：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool set-quota <replaceable>pool</replaceable> max_bytes <replaceable>bytes</replaceable>
<prompt>cephuser@adm &gt; </prompt>ceph osd pool set-quota <replaceable>pool</replaceable> max_objects <replaceable>objects</replaceable></screen>
     <para>
      将配额值设置为 0 将禁用配额。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>POOL_NEAR_FULL</term>
    <listitem>
     <para>
      一个或多个存储池接近其配额。触发此警告状况的阈值通过 <option>mon_pool_quota_warn_threshold</option> 配置选项控制。可使用以下命令上调、下调（或删除）存储池配额：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd osd pool set-quota <replaceable>pool</replaceable> max_bytes <replaceable>bytes</replaceable>
<prompt>cephuser@adm &gt; </prompt>ceph osd osd pool set-quota <replaceable>pool</replaceable> max_objects <replaceable>objects</replaceable></screen>
     <para>
      将配额值设置为 0 将禁用配额。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OBJECT_MISPLACED</term>
    <listitem>
     <para>
      集群中的一个或多个对象未存储在集群希望存储的节点上。这表示集群最近的某项更改导致的数据迁移尚未完成。误放的数据本质上不属于危险状况。数据一致性方面永远不会有风险，仅当所需位置放置了对象所需份数的新副本之后，系统才会删除对象的旧副本。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>OBJECT_UNFOUND</term>
    <listitem>
     <para>
      找不到集群中的一个或多个对象。具体而言，OSD 知道对象的新副本或更新副本应该存在，但在当前启用的 OSD 上却找不到该版对象的副本。系统将阻止对“未找到”对象的读取或写入请求。从理论上讲，可以将具有未找到对象最近副本的已停用 OSD 重新启用。可通过负责处理未找到对象的 PG 的互联状态识别候选 OSD：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph tell <replaceable>pgid</replaceable> query</screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>REQUEST_SLOW</term>
    <listitem>
     <para>
      正花费很长的时间处理一个或多个 OSD 请求。这可能表示负载极重、存储设备速度缓慢或有软件错误。可以从 OSD 主机执行以下命令来查询有问题的 OSD 上的请求队列：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>cephadm enter --name osd.<replaceable>ID</replaceable> -- ceph daemon osd.<replaceable>ID</replaceable> ops</screen>
     <para>
      可以查看近期最慢的请求摘要：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>cephadm enter --name osd.<replaceable>ID</replaceable> -- ceph daemon osd.<replaceable>ID</replaceable> dump_historic_ops</screen>
     <para>
      可使用以下命令查找 OSD 的位置：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd find osd.<replaceable>id</replaceable></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>REQUEST_STUCK</term>
    <listitem>
     <para>
      一个或多个 OSD 请求已被阻止一段相当长的时间，例如 4096 秒。这表示集群已有很长一段时间处于非健康状况（例如，没有足够的运行中 OSD 或非活跃 PG），或者 OSD 存在某种内部问题。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>PG_NOT_SCRUBBED</term>
    <listitem>
     <para>
      最近未洗刷（请参见<xref linkend="scrubbing-pgs"/>）一个或多个 PG。通常每 <option>mon_scrub_interval</option> 秒洗刷一次 PG，当 <option>mon_warn_not_scrubbed</option> 这类间隔已过但未进行洗刷时，就会触发此警告。如果 PG 未标记为清理，系统将不会洗刷它们。如果 PG 放置错误或已降级，就会出现这种情况（请参见上文中的 PG_AVAILABILITY 和 PG_DEGRADED）。您可以使用以下命令手动对标记为清理的 PG 启动洗刷：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph pg scrub <replaceable>pgid</replaceable></screen>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>PG_NOT_DEEP_SCRUBBED</term>
    <listitem>
     <para>
      最近未深层洗刷（请参见<xref linkend="scrubbing-pgs"/>）一个或多个 PG。通常每 <option>osd_deep_scrub_interval</option> 秒洗刷一次 PG，当 <option>mon_warn_not_deep_scrubbed</option> 秒已过但未进行洗刷时，就会触发此警告。如果 PG 未标记为清理，系统将不会（深层）洗刷它们。如果 PG 放置错误或已降级，就会出现这种情况（请参见上文中的 PG_AVAILABILITY 和 PG_DEGRADED）。您可以使用以下命令手动对标记为清理的 PG 启动洗刷：
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph pg deep-scrub <replaceable>pgid</replaceable></screen>
    </listitem>
   </varlistentry>
  </variablelist>

  <tip>
   <para>
    如果之前为您的配置或密钥环指定了非默认位置，则此时可以指定它们的位置：
   </para>
<screen><prompt role="root"># </prompt>ceph -c <replaceable>/path/to/conf</replaceable> -k <replaceable>/path/to/keyring</replaceable> health</screen>
  </tip>
 </sect1>
 <sect1 xml:id="monitor-stats">
  <title>检查集群的使用率统计数据</title>

  <para>
   要查看集群的数据使用率以及数据在多个存储池之间的分布，请使用 <command>ceph df</command> 命令。要获取更多详细信息，请使用 <command>ceph df detail</command>。
  </para>

<screen>
<prompt>cephuser@adm &gt; </prompt>ceph df
--- RAW STORAGE ---
CLASS  SIZE    AVAIL   USED     RAW USED  %RAW USED
hdd    30 GiB  27 GiB  121 MiB   3.1 GiB      10.40
TOTAL  30 GiB  27 GiB  121 MiB   3.1 GiB      10.40

--- POOLS ---
POOL                   ID  STORED   OBJECTS  USED     %USED  MAX AVAIL
device_health_metrics   1      0 B        0      0 B      0    8.5 GiB
cephfs.my_cephfs.meta   2  1.0 MiB       22  4.5 MiB   0.02    8.5 GiB
cephfs.my_cephfs.data   3      0 B        0      0 B      0    8.5 GiB
.rgw.root               4  1.9 KiB       13  2.2 MiB      0    8.5 GiB
myzone.rgw.log          5  3.4 KiB      207    6 MiB   0.02    8.5 GiB
myzone.rgw.control      6      0 B        8      0 B      0    8.5 GiB
myzone.rgw.meta         7      0 B        0      0 B      0    8.5 GiB
</screen>

  <para>
   输出中的 <literal>RAW STORAGE</literal> 段落提供集群用于数据的存储空间容量概览。
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <literal>CLASS</literal>：设备的存储类别。有关设备类型的更多详细信息，请参见<xref linkend="crush-devclasses"/>。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>SIZE</literal>：集群的整体存储容量。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>AVAIL</literal>：集群中可以使用的可用空间容量。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>USED</literal>：单纯为块设备中保存的数据对象分配的空间（所有 OSD 上的累计空间）。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>RAW USED</literal>：“USED”空间与块设备上为实现 Ceph 而分配/预留的空间（例如 BlueStore 的 BlueFS 部分）之和。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>% RAW USED</literal>：已用的原始存储量百分比。将此数字与 <literal>full ratio</literal> 和 <literal>near full ratio</literal> 搭配使用，可确保您不会用完集群的容量。有关其他详细信息，请参见<xref linkend="storage-capacity"/>。
    </para>
    <note>
     <title>集群填充程度</title>
     <para>
      当原始存储填满级别接近 100% 时，您需要向集群添加新存储空间。较高的用量可能导致单个 OSD 填满，集群健康状况出现问题。
     </para>
     <para>
      使用命令 <command>ceph osd df tree</command> 可列出所有 OSD 的填充程度。
     </para>
    </note>
   </listitem>
  </itemizedlist>

  <para>
   输出内容的 <literal>POOLS</literal> 段落提供了存储池列表和每个存储池的理论用量。此段落的输出<emphasis>不</emphasis>反映副本、克隆数据或快照。例如，如果您存储含 1MB 数据的对象，理论用量将是 1MB，但是根据副本、克隆数据或快照数量，实际用量可能是 2MB 或更多。
  </para>

  <itemizedlist mark="bullet" spacing="normal">
   <listitem>
    <para>
     <literal>POOL</literal>：存储池的名称。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>ID</literal>：存储池 ID。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>STORED</literal>：用户存储的数据量。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>OBJECTS</literal>：每个存储池的理论已存储对象数。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>USED</literal>：所有 OSD 节点单纯为数据分配的空间容量，以 kB 为单位。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>%USED</literal>：每个存储池的理论已用存储百分比。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>MAX AVAIL</literal>：给定存储池中的最大可用空间。
    </para>
   </listitem>
  </itemizedlist>

  <note>
   <para>
    POOLS 段落中的数字是理论上的。它们不包括副本、快照或克隆数量。因此，<literal>USED</literal> 与 %<literal>USED</literal> 数量之和不会加总到输出内容 <literal>RAW STORAGE</literal> 段落中的 <literal>RAW USED</literal> 和 <literal>%RAW USED</literal> 数量中。
   </para>
  </note>
 </sect1>
 <sect1 xml:id="monitor-osdstatus">
  <title>检查 OSD 状态</title>

  <para>
   可通过执行以下命令来检查 OSD，以确保它们已启动且正在运行：
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph osd stat</screen>

  <para>
   或
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph osd dump</screen>

  <para>
   还可以根据 OSD 在 CRUSH 索引中的位置查看 OSD。
  </para>

  <para>
   <command>ceph osd tree</command> 将列显 CRUSH 树及主机、它的 OSD、OSD 是否已启动及其权重：
  </para>

<screen>
   <prompt>cephuser@adm &gt; </prompt>ceph osd tree
ID  CLASS  WEIGHT   TYPE NAME              STATUS  REWEIGHT  PRI-AFF
-1      3  0.02939  root default
-3      3  0.00980    rack mainrack
-2      3  0.00980            host osd-host
0       1  0.00980                    osd.0   up   1.00000   1.00000
1       1  0.00980                    osd.1   up   1.00000   1.00000
2       1  0.00980                    osd.2   up   1.00000   1.00000
</screen>
 </sect1>
 <sect1 xml:id="storage-bp-monitoring-fullosd">
  <title>检查填满的 OSD</title>

  <para>
   Ceph 可阻止您向填满的 OSD 写入数据，以防丢失数据。在正常运行的集群中，当集群接近其填满比例时，您会收到警告。<command>mon osd full ratio</command> 默认设为容量的 0.95 (95%)，达到该比例后，集群会阻止客户端写入数据。<command>mon osd nearfull ratio</command> 默认设为容量的 0.85 (85%)，达到该比例时，集群会生成健康状况警告。
  </para>

  <para>
   可通过 <command>ceph health</command> 命令报告填满的 OSD 节点：
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph health
  HEALTH_WARN 1 nearfull osds
  osd.2 is near full at 85%</screen>

  <para>
   或
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph health
  HEALTH_ERR 1 nearfull osds, 1 full osds
  osd.2 is near full at 85%
  osd.3 is full at 97%</screen>

  <para>
   处理填满的集群的最佳方法是添加新的 OSD 主机/磁盘，以便让集群将数据重新分布到新的可用存储空间。
  </para>

  <tip>
   <title>防止 OSD 填满</title>
   <para>
    OSD 变满（即用完 100% 的磁盘空间）之后，往往会迅速崩溃而不发出警告。管理 OSD 节点时需记住下面几点提示。
   </para>
   <itemizedlist mark="bullet" spacing="normal">
    <listitem>
     <para>
      每个 OSD 的磁盘空间（通常挂载在 <filename>/var/lib/ceph/osd/osd-{1,2..}</filename> 下）需放置在专用的底层磁盘或分区上。
     </para>
    </listitem>
    <listitem>
     <para>
      检查 Ceph 配置文件，确保 Ceph 不会将其日志文件存储在专供 OSD 使用的磁盘/分区上。
     </para>
    </listitem>
    <listitem>
     <para>
      确保没有其他进程写入专供 OSD 使用的磁盘/分区。
     </para>
    </listitem>
   </itemizedlist>
  </tip>
 </sect1>
 <sect1 xml:id="monitor-monstatus">
  <title>检查 Monitor 状态</title>

  <para>
   启动集群后，请在第一次读取和/或写入数据之前检查 Ceph Monitor 的仲裁状态。如果集群已在处理请求，请定期检查 Ceph Monitor 的状态，确保其正在运行。
  </para>

  <para>
   要显示 Monitor 索引，请执行以下命令：
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph mon stat</screen>

  <para>
   或
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph mon dump</screen>

  <para>
   要检查 Monitor 集群的仲裁状态，请执行以下命令：
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph quorum_status</screen>

  <para>
   Ceph 将返回仲裁状态。例如，由三个 Monitor 组成的 Ceph 集群可能返回以下内容：
  </para>

<screen>{ "election_epoch": 10,
  "quorum": [
        0,
        1,
        2],
  "monmap": { "epoch": 1,
      "fsid": "444b489c-4f16-4b75-83f0-cb8097468898",
      "modified": "2011-12-12 13:28:27.505520",
      "created": "2011-12-12 13:28:27.505520",
      "mons": [
            { "rank": 0,
              "name": "a",
              "addr": "192.168.1.10:6789\/0"},
            { "rank": 1,
              "name": "b",
              "addr": "192.168.1.11:6789\/0"},
            { "rank": 2,
              "name": "c",
              "addr": "192.168.1.12:6789\/0"}
           ]
    }
}</screen>
 </sect1>
 <sect1 xml:id="monitor-pgroupstatus">
  <title>检查归置组状态</title>

  <para>
   归置组会将对象映射到 OSD。监视归置组时，您希望它们处于 <literal>active</literal> 和 <literal>clean</literal> 状态。有关详细内容，请参见<xref linkend="op-mon-osd-pg"/>。
  </para>
 </sect1>
 <sect1 xml:id="storage-capacity">
  <title>储存容量</title>

  <para>
   作为防止数据丢失的安全措施，当 Ceph 存储集群接近其容量上限时，Ceph 将阻止您向 Ceph OSD 写入或从中读取数据。因此，让生产集群接近其填满比例不是一种好的做法，因为这样会牺牲高可用性。默认的填满比例设置为 0.95，即容量的 95%。对于所含 OSD 数量较少的测试集群而言，如此设置是非常激进的。
  </para>

  <tip>
   <title>增加存储容量</title>
   <para>
    在监视集群时，请注意与 <literal>nearfull</literal> 比例有关的警告。出现该警告表示，如果一个或多个 OSD 发生故障，某些 OSD 的故障可能会导致服务暂时中断。请考虑添加更多 OSD 以增加存储容量。
   </para>
  </tip>

  <para>
   测试集群的一种常见情境是系统管理员从 Ceph 存储集群中删除 Ceph OSD，等待集群重新达到平衡。然后再删除另一个 Ceph OSD，以此类推，直到集群最终达到填满比例并锁死。我们建议即使使用测试集群时也进行一定的容量规划。通过规划，您可以预估维持高可用性所需的备用容量。从理论上讲，您需要规划能够应对一系列 Ceph OSD 发生故障的情况的方案，使集群无需立即替换这些 Ceph OSD 也可恢复到 <literal>active + clean</literal> 状态。您可以运行 <literal>active + degraded</literal> 状态的集群，但这不适合正常运行状况。
  </para>

  <para>
   下图展示了一个包含 33 个 Ceph 节点的简化 Ceph 存储集群，其中每个主机有一个 Ceph OSD，每个 Ceph OSD 从 3 TB 驱动器读取以及向其中写入数据。此示例集群实际的容量上限为 99 TB。<option>mon osd full ratio</option> 选项设置为 0.95。如果集群的剩余容量降至 5 TB，集群将不允许客户端读取和写入数据。因此，存储集群的运行容量为 95 TB，而不是 99 TB。
  </para>

  <figure>
   <title>Ceph 集群</title>
   <mediaobject>
    <imageobject role="fo">
     <imagedata fileref="ceph_cluster.png" width="85%" format="PNG"/>
    </imageobject>
    <imageobject role="html">
     <imagedata fileref="ceph_cluster.png" width="85%" format="PNG"/>
    </imageobject>
   </mediaobject>
  </figure>

  <para>
   在这样的集群中，有一个或两个 OSD 发生故障属于正常现象。一种不常发生但合乎常理的情况是机柜的路由器或电源发生故障，导致多个 OSD（例如 OSD 7-12）同时停用。在这种情况下，您仍然应该设法使集群保持正常运行并达到 <literal>active + clean</literal> 状态，即使这意味着需要立即添加一些主机及额外的 OSD。如果容量使用率过高，您可能不会丢失数据。但是，如果集群的容量使用率超过填满比例，您虽然解决了故障域内发生的中断问题，却可能会损失数据可用性。因此，我们建议至少进行大致的容量规划。
  </para>

  <para>
   针对您的集群确定以下两个数值：
  </para>

  <orderedlist>
   <listitem>
    <para>
     OSD 的数量。
    </para>
   </listitem>
   <listitem>
    <para>
     集群的总容量。
    </para>
   </listitem>
  </orderedlist>

  <para>
   如果您将集群的总容量除以集群中的 OSD 数量，将得到集群内单个 OSD 的平均容量。将该数值与您预期正常运行期间将同时发生故障的 OSD 数量（一个相对较小的数值）相乘。最后，将集群容量与填满比例相乘得到运行容量上限。然后，减去您预期将发生故障的 OSD 中的数据量，即可得到一个合理的填满比例。使用更高的 OSD 故障数（一整个机柜的 OSD）重复上述过程，即可得到一个合理的接近填满比例数值。
  </para>

  <para>
   以下设置仅在创建集群时才会应用，随后会存储在 OSD 索引中：
  </para>

<screen>
[global]
 mon osd full ratio = .80
 mon osd backfillfull ratio = .75
 mon osd nearfull ratio = .70
</screen>

  <tip>
   <para>
    仅在创建集群时才会应用这些设置。此后，需要使用 <command>ceph osd set-nearfull-ratio</command> 和 <command>ceph osd set-full-ratio</command> 命令在 OSD 索引中更改这些设置。
   </para>
  </tip>

  <variablelist>
   <varlistentry>
    <term>mon osd full ratio</term>
    <listitem>
     <para>
      在将 OSD 视为<literal>满</literal>之前使用的磁盘空间百分比。默认值为 0.95
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>mon osd backfillfull ratio</term>
    <listitem>
     <para>
      在将 OSD 视为过<literal>满</literal>而无法回填之前使用的磁盘空间百分比。默认值为 0.90
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>mon osd nearfull ratio</term>
    <listitem>
     <para>
      在将 OSD 视为<literal>将满</literal>之前使用的磁盘空间百分比。默认值为 0.85
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <tip>
   <title>检查 OSD 权重</title>
   <para>
    如果某些 OSD <literal>将满</literal>，但其他 OSD 的容量充足，则表示<literal>将满</literal> OSD 的 CRUSH 权重可能有问题。
   </para>
  </tip>
 </sect1>
 <sect1 xml:id="op-mon-osd-pg">
  <title>监控 OSD 和归置组</title>

  <para>
   高可用性和高可靠性要求采用容错方法来管理硬件和软件问题。Ceph 没有单一故障点，可以在“已降级”模式下处理数据请求。Ceph 的数据归置引入了一个间接层，以确保数据不会与特定 OSD 地址直接绑定。这表示跟踪系统故障原因需要找到属于问题根源的归置组和底层 OSD。
  </para>

  <tip>
   <title>发生故障时的访问</title>
   <para>
    如果集群的某个部分发生故障，集群可能会阻止您访问特定对象，但这并不意味着您无法访问其他对象。遇到故障时，请执行相关步骤来监视 OSD 和归置组。然后开始进行查错。
   </para>
  </tip>

  <para>
   Ceph 一般情况下会进行自我修复。但如果问题仍然存在，监视 OSD 和归置组将有助于您找到问题所在。
  </para>

  <sect2 xml:id="op-mon-osds">
   <title>监视 OSD</title>
   <para>
    OSD 可能处于<emphasis>在集群内</emphasis>（“in”）状态，也可能处于<emphasis>在集群外</emphasis>（“out”）状态。同时，它也可能处于<emphasis>启用并运行</emphasis>（“up”）或<emphasis>停用且未运行</emphasis>（“down”）状态。如果某个 OSD 处于“up”状态，则它可能在集群内（您可以读取和写入数据），也可能在集群外。如果该 OSD 之前在集群内，最近已移出集群，则 Ceph 会将归置组迁移到其他 OSD。如果某个 OSD 在集群外，CRUSH 将不会为其指定归置组。如果某个 OSD 处于“down”状态，则它应该也处于“out”状态。
   </para>
   <note>
    <title>不健康状态</title>
    <para>
     如果某个 OSD 处于“down”和“in”状态，则表示存在问题，并且集群将处于不健康状态。
    </para>
   </note>
   <para>
    如果您执行 <command>ceph health</command>、<command>ceph -s</command> 或 <command>ceph -w</command> 等命令，可能会注意到集群并非始终回显 <literal>HEALTH OK</literal>。对于 OSD，您应当预期集群在以下情况下<emphasis>不会</emphasis>回显 <literal>HEALTH OK</literal>：
   </para>
   <itemizedlist>
    <listitem>
     <para>
      您尚未启动集群（它不会响应）。
     </para>
    </listitem>
    <listitem>
     <para>
      您已启动或重启动集群，但它尚未准备就绪，因为系统正在创建归置组，并且 OSD 正在互联。
     </para>
    </listitem>
    <listitem>
     <para>
      您已添加或删除某个 OSD。
     </para>
    </listitem>
    <listitem>
     <para>
      您已修改集群索引。
     </para>
    </listitem>
   </itemizedlist>
   <para>
    监视 OSD 的一个重要目的是确保当集群已启用且在运行时，集群中的所有 OSD 也已启用且在运行。要确定是否所有 OSD 都在运行，请执行以下命令：
   </para>
<screen>
<prompt role="root"># </prompt>ceph osd stat
x osds: y up, z in; epoch: eNNNN
</screen>
   <para>
    结果应显示 OSD 总数 (x)、处于“up”状态的 OSD 数量 (y)、处于“in”状态的 OSD 数量 (z)，以及索引版本号 (eNNNN)。如果在集群内（“in”）的 OSD数量大于处于“up”状态的 OSD 数量，请执行以下命令确定未在运行的 <literal>ceph-osd</literal> 守护进程：
   </para>
<screen>
<prompt role="root"># </prompt>ceph osd tree
#ID CLASS WEIGHT  TYPE NAME             STATUS REWEIGHT PRI-AFF
-1       2.00000 pool openstack
-3       2.00000 rack dell-2950-rack-A
-2       2.00000 host dell-2950-A1
0   ssd 1.00000      osd.0                up  1.00000 1.00000
1   ssd 1.00000      osd.1              down  1.00000 1.00000
</screen>
   <para>
    例如，如果 ID 为 1 的 OSD 处于停用状态，请将其启动：
   </para>
<screen>
<prompt>cephuser@osd &gt; </prompt>sudo systemctl start ceph-<replaceable>CLUSTER_ID</replaceable>@osd.0.service
</screen>
   <para>
    有关与已停止或不会重启动的 OSD 相关的问题，请参见<xref linkend="bp-troubleshooting-not-running"/>。
   </para>
  </sect2>

  <sect2 xml:id="op-pgsets">
   <title>指定归置组集</title>
   <para>
    CRUSH 向 OSD 指定归置组时，会查看存储池的副本数量，然后再为 OSD 指定归置组，以便将每个归置组副本都指定给不同的 OSD。例如，如果存储池需要三个归置组副本，CRUSH 可能会将这三个副本分别指定给 <literal>osd.1</literal>、<literal>osd.2</literal> 和 <literal>osd.3</literal>。CRUSH 实际上会寻找一种伪随机归置方法，这种方法会将您在 CRUSH 索引中设置的故障域纳入考量，因此在大型集群中，您很少会看到归置组被指定给最邻近的 OSD 的情况。我们将应包含特定归置组的副本的 OSD 集称为<emphasis>在任集</emphasis>。在某些情况下，在任集中的 OSD 会处于停用状态，或者无法处理要访问归置组中对象的请求。当以下其中一种情况发生时，可能会出现这些情况：
   </para>
   <itemizedlist>
    <listitem>
     <para>
      您添加或删除了某个 OSD。CRUSH 随后会将归置组重新指定给其他 OSD，因而更改了<emphasis>在任集</emphasis>的组成部分，导致系统通过“回填”过程迁移数据。
     </para>
    </listitem>
    <listitem>
     <para>
      某个 OSD 之前处于“down”状态、之前进行了重启动，而现在正在恢复。
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis>在任集</emphasis>中的某个 OSD 处于“down”状态，或者无法处理请求，并且另一个 OSD 已暂代其职。
     </para>
     <para>
      Ceph 使用<emphasis>启用集</emphasis>来处理客户端请求，启用集是实际处理请求的 OSD 集。在大多数情况下，<emphasis>启用集</emphasis>和<emphasis>在任集</emphasis>几乎完全相同。当两者不同时，可能表示 Ceph 正在迁移数据、某个 OSD 正在恢复，或者集群存在问题（例如，在此类情况下，Ceph 通常会回显 <literal>HEALTH WARN</literal> 状态及“stuck stale”消息）。
     </para>
    </listitem>
   </itemizedlist>
   <para>
    要检索归置组列表，请运行以下命令：
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph pg dump
</screen>
   <para>
    要查看哪些 OSD 在给定归置组的<emphasis>在任集</emphasis>或<emphasis>启用集</emphasis>内，请运行以下命令：
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph pg map <replaceable>PG_NUM</replaceable>
osdmap eNNN pg <replaceable>RAW_PG_NUM</replaceable> (<replaceable>PG_NUM</replaceable>) -&gt; up [0,1,2] acting [0,1,2]
</screen>
   <para>
    结果应该会显示 OSD 索引版本号 (eNNN)、归置组数量 (<replaceable>PG_NUM</replaceable>)、<emphasis>启用集</emphasis>（“up”）中的 OSD，以及<emphasis>在任集</emphasis>（“acting”）中的 OSD：
   </para>
   <tip>
    <title>集群问题指示符</title>
    <para>
     如果<emphasis>启用集</emphasis>与<emphasis>在任集</emphasis>不一致，则可能表示集群正在自我重新平衡，或者集群可能存在问题。
    </para>
   </tip>
  </sect2>

  <sect2 xml:id="op-peering">
   <title>正在互联</title>
   <para>
    归置组必须处于 <literal>active</literal> 及 <literal>clean</literal> 状态，您才能将数据写入其中。为了让 Ceph 确定某个归置组的当前状态，该归置组的主 OSD（<emphasis>在任集</emphasis>中的第一个 OSD）会与第二个和第三个 OSD 建立互联，以便就归置组的当前状态达成一致（假设存储池包含三个归置组副本）。
   </para>
   <figure>
    <title>互联纲要</title>
    <mediaobject>
     <imageobject role="fo">
      <imagedata fileref="ceph_peering.png" width="70%" format="PNG"/>
     </imageobject>
     <imageobject role="html">
      <imagedata fileref="ceph_peering.png" width="70%" format="PNG"/>
     </imageobject>
    </mediaobject>
   </figure>
  </sect2>

  <sect2 xml:id="op-mon-pg-states">
   <title>监控归置组状态</title>
   <para>
    如果您执行 <command>ceph health</command>、<command>ceph -s</command> 或 <command>ceph -w</command> 等命令，可能会注意到集群并非始终回显 <literal>HEALTH OK</literal> 消息。检查 OSD 是否正在运行之后，还应检查归置组状态。
   </para>
   <para>
    在一些与归置组互联相关的情况下，集群预期将<emphasis role="bold">不会</emphasis>回显 <literal>HEALTH OK</literal>：
   </para>
   <itemizedlist>
    <listitem>
     <para>
      您已创建存储池，并且归置组尚未互联。
     </para>
    </listitem>
    <listitem>
     <para>
      归置组正在恢复。
     </para>
    </listitem>
    <listitem>
     <para>
      您已向集群添加了 OSD，或已从集群中删除了 OSD。
     </para>
    </listitem>
    <listitem>
     <para>
      您已修改 CRUSH 索引，并且您的归置组正在迁移。
     </para>
    </listitem>
    <listitem>
     <para>
      在不同的归置组副本中存在数据不一致的情况。
     </para>
    </listitem>
    <listitem>
     <para>
      Ceph 正在洗刷归置组的副本。
     </para>
    </listitem>
    <listitem>
     <para>
      Ceph 的存储容量不足，无法完成回填操作。
     </para>
    </listitem>
   </itemizedlist>
   <para>
    如果上述其中一种情况导致 Ceph 回显 <literal>HEALTH WARN</literal>，请不要惊慌。集群在许多情况下都会自行恢复。在有些情况下，您可能需要采取措施。监视归置组的一个重要目的是确保当集群已启用并运行时，所有归置组都处于“active”状态并且最好处于“clean”状态。要查看所有归置组的状态，请运行以下命令：
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph pg stat
x pgs: y active+clean; z bytes data, aa MB used, bb GB / cc GB avail
</screen>
   <para>
    结果应该会显示归置组总数 (x)、处于特定状态（例如“active+clean”）的归置组数量 (y)，以及存储的数据量 (z)。
   </para>
   <para>
    除了归置组状态以外，Ceph 还会回显使用的存储容量 (aa)、剩余的存储容量 (bb)，以及归置组的总存储容量。在以下情况下，这些数值可能非常重要：
   </para>
   <itemizedlist>
    <listitem>
     <para>
      已达到 <option>near full ratio</option> 或 <option>full ratio</option>。
     </para>
    </listitem>
    <listitem>
     <para>
      由于您的 CRUSH 配置中存在错误，您的数据未在集群中分布。
     </para>
    </listitem>
   </itemizedlist>
   <tip>
    <title>归置组 ID</title>
    <para>
     归置组 ID 由存储池编号（并非存储池名称）加一个句点 (.)和归置组 ID（一个十六进制数）组成。您可以在 <command>ceph osd lspools</command> 的输出中查看存储池编号及其名称。例如，默认存储池 <literal>rbd</literal> 与存储池编号 0 对应。完全限定的归置组 ID 的格式如下：
    </para>
<screen>
<replaceable>POOL_NUM</replaceable>.<replaceable>PG_ID</replaceable>
</screen>
    <para>
     通常显示如下：
    </para>
<screen>
0.1f
</screen>
   </tip>
   <para>
    要检索归置组列表，请运行以下命令：
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph pg dump
</screen>
   <para>
    您还可以将输出内容设置为 JSON 格式，并将其保存到文件中：
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph pg dump -o <replaceable>FILE_NAME</replaceable> --format=json
</screen>
   <para>
    要查询特定归置组，请运行以下命令：
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph pg <replaceable>POOL_NUM</replaceable>.<replaceable>PG_ID</replaceable> query
</screen>
   <para>
    以下列表详细说明了常见的归置组状态。
   </para>
   <variablelist>
    <varlistentry>
     <term>CREATING（正在创建）</term>
     <listitem>
      <para>
       当您创建存储池时，Ceph 会创建您指定数量的归置组。Ceph 会在创建一个或多个归置组时回显“creating”。创建归置组之后，属于归置组<emphasis>在任集</emphasis>的各 OSD 将会互联。完成互联过程时，归置组状态应该为“active+clean”，这表示 Ceph 客户端可以开始向归置组写入数据。
      </para>
      <figure>
       <title>归置组状态</title>
       <mediaobject>
        <imageobject role="fo">
         <imagedata fileref="ceph_pg_creating.png" width="80%" format="PNG"/>
        </imageobject>
        <imageobject role="html">
         <imagedata fileref="ceph_pg_creating.png" width="80%" format="PNG"/>
        </imageobject>
       </mediaobject>
      </figure>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>PEERING（正在互联）</term>
     <listitem>
      <para>
       当 Ceph 在对归置组执行互联操作时，会在存储归置组副本的各 OSD 之间就该归置组中的对象和元数据的状态达成一致。当 Ceph 完成互联过程时，便表示存储归置组的各 OSD 之间就归置组的当前状态达成一致。不过，完成互联过程并<emphasis role="bold">不</emphasis>表示每个副本都有最新的内容。
      </para>
      <note>
       <title>权威历史</title>
       <para>
        在<emphasis>在任集</emphasis>的所有 OSD 都持续进行写入操作之前，Ceph 将<emphasis role="bold">不会</emphasis>向客户端确认写入操作。这样做可确保在上次成功完成互联操作之后，至少有一个<emphasis>在任集</emphasis>成员将拥有每个确认的写入操作的记录。
       </para>
       <para>
        通过准确记录每个确认的写入操作，Ceph 可以构建并扩展一个新的权威归置组历史，即一个完整且完全有序的在任集，如果执行该在任集，会将 OSD 的归置组副本更新到最新状态。
       </para>
      </note>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>ACTIVE（活动）</term>
     <listitem>
      <para>
       当 Ceph 完成互联过程时，归置组可能会变为 <literal>active</literal> 状态。<literal>active</literal> 状态表示通常可在主归置组和副本中使用归置组中的数据进行读取和写入操作。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>CLEAN（正常）</term>
     <listitem>
      <para>
       如果归置组处于 <literal>clean</literal> 状态，则表示主 OSD 和副本 OSD 已成功互联，并且该归置组没有流浪副本。Ceph 已将归置组中的所有对象复制正确的次数。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>DEGRADED（已降级）</term>
     <listitem>
      <para>
       当客户端将对象写入主 OSD 时，该主 OSD 负责将副本写入副本 OSD。主 OSD 将对象写入存储空间之后，归置组将保持“degraded”状态，直到主 OSD 收到了副本 OSD 发送的 Ceph 已成功创建副本对象的确认消息。
      </para>
      <para>
       归置组有可能处于“active+degraded”状态，这是因为即使 OSD 尚未存储所有对象，它也可能处于“active”状态。如果某个 OSD 变成停用状态，Ceph 会将指定给该 OSD 的每个归置组都标记为“degraded”。当该 OSD 恢复启用状态后，各 OSD 必须再次互联。不过，如果某个已降级归置组处于“active”状态，客户端仍然可以将新对象写入该归置组。
      </para>
      <para>
       如果某个 OSD 处于“down”状态，并且持续保持“degraded”状况，Ceph 可能会将该停用的 OSD 标记为“out”（表示移出集群），并将停用（“down”）的 OSD 的数据重新映射到另一个 OSD。从将 OSD 标记为“down”到将其标记为“out”相隔的时间通过 <option>mon osd down out interval</option> 选项控制，该选项默认设置为 600 秒。
      </para>
      <para>
       归置组也可能处于“degraded”状态，当 Ceph 找不到应在归置组中的一个或多个对象时便会发生此情况。虽然您无法读取未找到的对象或向其写入数据，却仍然可以访问“degraded”状态的归置组中的所有其他对象。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>RECOVERING（正在恢复）</term>
     <listitem>
      <para>
       Ceph 设计用于在发生硬件和软件问题时进行大规模容错。当 OSD 变成“down”状态时，其内容可能落后于归置组中其他副本的当前状态。当 OSD 恢复“up”状态时，必须更新归置组的内容以反映最新状态。在此期间，OSD 可能会显现出“recovering”状态。
      </para>
      <para>
       恢复并非总是无足轻重的，因为硬件故障可能会导致多个 OSD 发生级联故障。例如，一个机架或机柜的网络交换机可能会发生故障，这可能会导致一些主机的 OSD 落后于集群的当前状态。解决故障之后，必须恢复每个 OSD。
      </para>
      <para>
       Ceph 提供了一些设置，用来平衡新服务请求与恢复数据对象并将归置组恢复到最新状态的需求之间的资源争用。<option>osd recovery delay start</option> 设置允许 OSD 在启动恢复过程之前重启动、重新互联，甚至处理一些重放请求。<option>osd recovery thread timeout</option> 用于设置线程超时，因为有可能会有多个 OSD 交错发生故障、重启动以及重新互联。<option>osd recovery max active</option> 设置用于限制 OSD 将同时处理的恢复请求数，以防止 OSD 无法处理请求。<option>osd recovery max chunk</option> 设置用于限制恢复的数据块大小，以防出现网络拥塞。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>BACK FILLING（正在回填）</term>
     <listitem>
      <para>
       当新 OSD 加入集群时，CRUSH 会将集群中 OSD 的归置组重新指定给新添加的 OSD。强制新 OSD 立即接受重新指定的归置组可能会使新 OSD 过载。向 OSD 回填归置组可让此过程在后台开始。回填完成后，新 OSD 将在准备就绪时开始处理请求。
      </para>
      <para>
       在执行回填操作期间，系统可能会显示以下其中一种状态：“backfill_wait”表示回填操作待处理，但尚未执行；“backfill”表示正在进行回填操作；“backfill_too_full”表示已请求进行回填操作，但由于存储容量不足而无法完成。如果某个归置组无法回填，则可能会被视为“incomplete”。
      </para>
      <para>
       Ceph 提供了一些设置来管理与向某个 OSD（尤其是新 OSD）重新指定归置组有关的负载。默认情况下，<option>osd max backfills</option> 将向或从一个 OSD 同时进行的最大回填数设置为 10。<option>backfill full ratio</option> 允许 OSD 在接近其填满比例（默认为 90%）时拒绝回填请求，并使用 <command>ceph osd set-backfillfull-ratio</command> 命令进行更改。如果某个 OSD 拒绝回填请求，<option>osd backfill retry interval</option> 可让 OSD 重试请求（默认在 10 秒后）。OSD 还可以设置 <option>osd backfill scan min</option> 和 <option>osd backfill scan max</option>，以管理扫描间隔（默认值分别为 64 和 512）。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>REMAPPED（已重新映射）</term>
     <listitem>
      <para>
       当用于处理归置组的<emphasis>在任集</emphasis>发生变化时，数据会从旧<emphasis>在任集</emphasis>迁移到新<emphasis>在任集</emphasis>。新主 OSD 可能需要一段时间才能处理请求。因此，新主 OSD 可能会要求旧主 OSD 继续处理请求，直到归置组迁移完成。数据迁移完成时，映射将使用新<emphasis>在任集</emphasis>的主 OSD。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>STALE（过时）</term>
     <listitem>
      <para>
       尽管 Ceph 使用检测信号来确保主机和守护进程正在运行，但 <literal>ceph-osd</literal> 守护进程也可能会卡住，无法及时报告统计数据（例如，当发生暂时的网络故障时）。默认情况下，OSD 守护进程每半秒钟 (0.5) 报告一次其归置组、引导及故障统计数据，这个频率高于检测信号阈值。如果某个归置组<emphasis>在任集</emphasis>的主 OSD 未能向 Monitor 报告，或者其他 OSD 已将该主 OSD 报告为“down”，则 Monitor 会将该归置组标记为“stale”。
      </para>
      <para>
       当您启动集群后，集群常常会在互联过程完成之前显示为“stale”状态。集群运行一段时间之后，如果归置组显示为“stale”状态，则表示这些归置组的主 OSD 处于停用状态，或者未向 Monitor 报告归置组统计数据。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="op-pg-objectfinding">
   <title>查找对象位置</title>
   <para>
    要在 Ceph 对象存储中存储对象数据，Ceph 客户端需要设置对象名称并指定相关的存储池。Ceph 客户端会检索最新的集群索引，并且 CRUSH 算法会计算如何将对象映射到归置组，然后计算如何以动态方式将该归置组指定给 OSD。要查找对象位置，您只需知道对象名称和存储池名称。例如：
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph osd map <replaceable>POOL_NAME</replaceable> <replaceable>OBJECT_NAME</replaceable> [<replaceable>NAMESPACE</replaceable>]
</screen>
   <example>
    <title>查找对象</title>
    <para>
     作为示范，我们来创建一个对象。在命令行上使用 <command>rados put</command> 命令指定对象名称“test-object-1”、包含一些对象数据的示例文件“testfile.txt”的路径，以及存储池名称“data”。
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>rados put test-object-1 testfile.txt --pool=data
</screen>
    <para>
     要确认 Ceph 对象存储是否已存储对象，请运行以下命令：
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>rados -p data ls
</screen>
    <para>
     现在，我们来确定对象位置。Ceph 将会输出对象的位置：
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph osd map data test-object-1
osdmap e537 pool 'data' (0) object 'test-object-1' -&gt; pg 0.d1743484 \
(0.4) -&gt; up ([1,0], p0) acting ([1,0], p0)
</screen>
    <para>
     要移除示例对象，只需使用 <command>rados rm</command> 命令将其删除：
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>rados rm test-object-1 --pool=data
</screen>
   </example>
  </sect2>
 </sect1>
</chapter>
