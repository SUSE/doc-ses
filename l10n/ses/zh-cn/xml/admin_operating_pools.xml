<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="admin_operating_pools.xml" version="5.0" xml:id="ceph-pools">
 <title>管理存储池</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:translation>是</dm:translation>
   <dm:release>SES 7</dm:release>
  </dm:docmanager>
 </info>
 <para>
  Ceph 将数据存储在存储池中。存储池是用于存储对象的逻辑组。如果您先部署集群而不创建存储池，Ceph 会使用默认存储池来存储数据。下面着重指出与
  Ceph 存储池有关的重要特性：
 </para>
 <itemizedlist mark="bullet" spacing="normal">
  <listitem>
   <para>
    <emphasis>恢复能力</emphasis>：Ceph 存储池通过复制或编码其中包含的数据来提供恢复能力。可将每个存储池设置为
    <literal>replicated</literal> 或 <literal>erasure
    coding</literal>。对于副本存储池，您可以进一步设置存储池中每个数据对象将拥有的副本数。可丢失的副本数（OSD、CRUSH
    存储桶/叶）比副本数少一个。您可以使用纠删码设置 <option>k</option> 和 <option>m</option> 的值，其中
    <option>k</option> 是数据块的数量，<option>m</option>
    是编码块的数量。对于纠删码存储池，编码块的数量决定了在不丢失数据的情况下可丢失的 OSD（CRUSH 存储桶/树叶）数量。
   </para>
  </listitem>
  <listitem>
   <para>
    <emphasis>归置组</emphasis>：您可以设置存储池的归置组数。典型配置为每个 OSD 使用约 100
    个归置组，以提供最佳平衡而又不会耗费太多计算资源。设置多个存储池时，请务将存储池和集群作为整体考虑，确保设置合理的归置组数。
   </para>
  </listitem>
  <listitem>
   <para>
    <emphasis>CRUSH 规则</emphasis>：在存储池中存储数据时，系统会根据映射到该存储池的 CRUSH
    规则集来放置对象及其副本或块（如果是纠删码存储池）。您可为存储池创建自定义 CRUSH 规则。
   </para>
  </listitem>
  <listitem>
   <para>
    <emphasis>快照</emphasis>：使用 <command>ceph osd pool mksnap</command>
    创建快照时，可高效创建特定存储池的快照。
   </para>
  </listitem>
 </itemizedlist>
 <para>
  要将数据组织到存储池中，可以列出、创建和删除存储池。您还可以查看每个存储池的用量统计数字。
 </para>
 <sect1 xml:id="ceph-pools-operate-add-pool">
  <title>创建存储池</title>

  <para>
   可以创建 <literal>replicated</literal>（用于保留对象的多个副本，以便从丢失的 OSD 恢复）或
   <literal>erasure</literal>（用于获得通用 RAID 5 或 6
   功能）类型的存储池。副本存储池所需的原始存储空间较多，而纠删码存储池所需的原始存储空间较少。默认设置为
   <literal>replicated</literal>。有关纠删码存储池的详细信息，请参见<xref linkend="cha-ceph-erasure"/>。
  </para>

  <para>
   要创建副本存储池，请执行以下命令：
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool create <replaceable>POOL_NAME</replaceable></screen>

  <note>
   <para>
    自动扩展器负责处理剩余的可选自变量。有关详细信息，请参见<xref linkend="op-pgs-autoscaler"/>。
   </para>
  </note>

  <para>
   要创建纠删码存储池，请执行以下命令：
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool create <replaceable>POOL_NAME</replaceable> erasure <replaceable>CRUSH_RULESET_NAME</replaceable> \
<replaceable>EXPECTED_NUM_OBJECTS</replaceable></screen>

  <para>
   如果超出每个 OSD 的归置组限制，则 <command>ceph osd pool create</command> 命令可能会失败。该限制通过
   <option>mon_max_pg_per_osd</option> 选项设置。
  </para>

  <variablelist>
   <varlistentry>
    <term>POOL_NAME</term>
    <listitem>
     <para>
      存储池的名称，必须唯一。必须指定此选项。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>POOL_TYPE</term>
    <listitem>
     <para>
      存储池类型，可以是 <literal>replicated</literal>（用于保留对象的多个副本，以便从失败的 OSD 恢复）或
      <literal>erasure</literal>（用于获得某种通用 RAID5 功能）。副本池需要的原始存储较多，但可实现所有 Ceph
      操作。纠删码存储池需要的原始存储较少，但只能实现部分可用的操作。默认 <literal>POOL_TYPE</literal> 设置为
      <literal>replicated</literal>。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>CRUSH_RULESET_NAME</term>
    <listitem>
     <para>
      此存储池的 CRUSH 规则集的名称。如果所指定的规则集不存在，则创建副本存储池的操作将会失败，并显示 -ENOENT。对于副本存储池，它是由
      <varname>osd pool default CRUSH replicated ruleset</varname>
      配置变量指定的规则集。此规则集必须存在。对于纠删码存储池，如果使用默认纠删码配置，则规则集为“erasure-code”，否则为
      <replaceable>POOL_NAME</replaceable>。如果此规则集尚不存在，系统将隐式创建该规则集。
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>erasure_code_profile=profile</term>
    <listitem>
     <para>
      仅适用于纠删码存储池。使用纠删码配置。该配置必须是 <command>osd erasure-code-profile set</command>
      所定义的现有配置。
     </para>
     <note>
      <para>
       如果出于任何原因禁用了存储池上的自动扩展器（<literal>pg_autoscale_mode</literal> 设为
       off），您可以手动计算和设置 PG 数量。有关计算存储池的适当归置组数的详细信息，请参见<xref linkend="op-pgs"/>。
      </para>
     </note>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>EXPECTED_NUM_OBJECTS</term>
    <listitem>
     <para>
      此存储池的预期对象数。如果设置此值（与一个为负数的 <option>filestore merge threshold</option>
      值），系统在创建存储池时会分割 PG 文件夹。这可避免因运行时文件夹拆分导致的延迟影响。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>
 <sect1 xml:id="ceph-listing-pools">
  <title>列出存储池</title>

  <para>
   要列出集群的存储池，请执行以下命令：
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool ls</screen>
 </sect1>
 <sect1 xml:id="ceph-renaming-pool">
  <title>重命名存储池</title>

  <para>
   要重命名存储池，请执行以下命令：
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool rename <replaceable>CURRENT_POOL_NAME</replaceable> <replaceable>NEW_POOL_NAME</replaceable></screen>

  <para>
   如果重命名了存储池，且为经过身份验证的用户使用了按存储池功能，则必须用新的存储池名称更新用户的功能。
  </para>
 </sect1>
 <sect1 xml:id="ceph-pools-operate-del-pool">
  <title>删除存储池</title>

  <warning>
   <title>删除存储池的操作不可逆</title>
   <para>
    存储池中可能包含重要数据。删除存储池会导致存储池中的所有数据消失，且无法恢复。
   </para>
  </warning>

  <para>
   不小心删除存储池十分危险，因此 Ceph 实施了两个机制来防止删除存储池。要删除存储池，必须先禁用这两个机制。
  </para>

  <para>
   第一个机制是 <literal>NODELETE</literal>
   标志。每个存储池都有这个标志，其默认值是“false”。要确定某个存储池的此标志值，请运行以下命令：
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool get <replaceable>pool_name</replaceable> nodelete</screen>

  <para>
   如果命令输出 <literal>nodelete: true</literal>，则只有在使用以下命令更改该标志后，才能删除存储池：
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool set <replaceable>pool_name</replaceable> nodelete false</screen>

  <para>
   第二个机制是集群范围的配置参数 <option>mon allow pool
   delete</option>，其默认值为“false”。这表示默认不能删除存储池。显示的错误讯息是：
  </para>

<screen>Error EPERM: pool deletion is disabled; you must first set the
mon_allow_pool_delete config option to true before you can destroy a pool</screen>

  <para>
   若要规避此安全设置删除存储池，可以临时将 <option>mon allow pool delete</option>
   设置为“true”，删除存储池，然后将该参数恢复为“false”：
  </para>

<screen><prompt>cephuser@adm &gt; </prompt>ceph tell mon.* injectargs --mon-allow-pool-delete=true
<prompt>cephuser@adm &gt; </prompt>ceph osd pool delete pool_name pool_name --yes-i-really-really-mean-it
<prompt>cephuser@adm &gt; </prompt>ceph tell mon.* injectargs --mon-allow-pool-delete=false</screen>

  <para>
   <command>injectargs</command> 命令会显示以下讯息：
  </para>

<screen>injectargs:mon_allow_pool_delete = 'true' (not observed, change may require restart)</screen>

  <para>
   这主要用于确认该命令已成功执行。它不是错误。
  </para>

  <para>
   如果为您创建的存储池创建了自己的规则组和规则，则应该考虑在不再需要该存储池时删除规则组和规则。
  </para>
 </sect1>
 <sect1 xml:id="ceph-pool-other-operations">
  <title>其他操作</title>

  <sect2 xml:id="ceph-pools-associate">
   <title>将存储池与应用关联</title>
   <para>
    在使用存储池之前，需要将它们与应用关联。将与 CephFS 搭配使用或由对象网关自动创建的存储池会自动关联。
   </para>
   <para>
    对于其他情况，可以手动将自由格式的应用名称与存储池关联：
   </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool application enable <replaceable>POOL_NAME</replaceable> <replaceable>APPLICATION_NAME</replaceable></screen>
   <tip>
    <title>默认应用名称</title>
    <para>
     CephFS 使用应用名称 <literal>cephfs</literal>，RADOS 块设备使用
     <literal>rbd</literal>，对象网关使用 <literal>rgw</literal>。
    </para>
   </tip>
   <para>
    一个存储池可以与多个应用关联，每个应用都可具有自己的元数据。要列出与存储池关联的一个（或多个）应用，请发出以下命令：
   </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool application get <replaceable>pool_name</replaceable></screen>
  </sect2>

  <sect2 xml:id="ceph-set-pool-quotas">
   <title>设置存储池配额</title>
   <para>
    您可以设置存储池配额，限定每个存储池的最大字节数和/或最大对象数。
   </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool set-quota <replaceable>POOL_NAME</replaceable> <replaceable>MAX_OBJECTS</replaceable> <replaceable>OBJ_COUNT</replaceable> <replaceable>MAX_BYTES</replaceable> <replaceable>BYTES</replaceable></screen>
   <para>
    例如：
   </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool set-quota data max_objects 10000</screen>
   <para>
    要删除配额，请将其值设置为 0。
   </para>
  </sect2>

  <sect2 xml:id="ceph-showing-pool-statistics">
   <title>显示存储池统计数据</title>
   <para>
    要显示存储池的用量统计数字，请执行以下命令：
   </para>
<screen><prompt>cephuser@adm &gt; </prompt>rados df
 POOL_NAME                    USED OBJECTS CLONES COPIES MISSING_ON_PRIMARY UNFOUND DEGRADED  RD_OPS      RD  WR_OPS      WR USED COMPR UNDER COMPR
 .rgw.root                 768 KiB       4      0     12                  0       0        0      44  44 KiB       4   4 KiB        0 B         0 B
 cephfs_data               960 KiB       5      0     15                  0       0        0    5502 2.1 MiB      14  11 KiB        0 B         0 B
 cephfs_metadata           1.5 MiB      22      0     66                  0       0        0      26  78 KiB     176 147 KiB        0 B         0 B
 default.rgw.buckets.index     0 B       1      0      3                  0       0        0       4   4 KiB       1     0 B        0 B         0 B
 default.rgw.control           0 B       8      0     24                  0       0        0       0     0 B       0     0 B        0 B         0 B
 default.rgw.log               0 B     207      0    621                  0       0        0 5372132 5.1 GiB 3579618     0 B        0 B         0 B
 default.rgw.meta          961 KiB       6      0     18                  0       0        0     155 140 KiB      14   7 KiB        0 B         0 B
 example_rbd_pool          2.1 MiB      18      0     54                  0       0        0 3350841 2.7 GiB     118  98 KiB        0 B         0 B
 iscsi-images              769 KiB       8      0     24                  0       0        0 1559261 1.3 GiB      61  42 KiB        0 B         0 B
 mirrored-pool             1.1 MiB      10      0     30                  0       0        0  475724 395 MiB      54  48 KiB        0 B         0 B
 pool2                         0 B       0      0      0                  0       0        0       0     0 B       0     0 B        0 B         0 B
 pool3                     333 MiB      37      0    111                  0       0        0 3169308 2.5 GiB   14847 118 MiB        0 B         0 B
 pool4                     1.1 MiB      13      0     39                  0       0        0 1379568 1.1 GiB   16840  16 MiB        0 B         0 B
 </screen>
   <para>
    各列的说明如下：
   </para>
   <variablelist>
    <varlistentry>
     <term>USED</term>
     <listitem>
      <para>
       存储池使用的字节数。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>OBJECTS</term>
     <listitem>
      <para>
       存储池中存储的对象数。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>CLONES</term>
     <listitem>
      <para>
       存储池中存储的克隆数。如果在创建快照时某个客户端向对象写入数据，系统将会创建原始对象的克隆，而不是对该对象进行修改，这样便不会修改已截取快照的原始对象内容。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>COPIES</term>
     <listitem>
      <para>
       对象副本的数量。例如，如果某个复制系数为 3 的副本存储池有“x”个对象，它通常将会有 3 * x 个副本。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>MISSING_ON_PRIMARY</term>
     <listitem>
      <para>
       当主 OSD 上的副本缺失时，处于降级状态（不是所有副本都存在）的对象的数量。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>UNFOUND</term>
     <listitem>
      <para>
       未找到的对象数。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>DEGRADED</term>
     <listitem>
      <para>
       已降级的对象数。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>RD_OPS</term>
     <listitem>
      <para>
       针对此存储池请求的读取操作总数。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>RD</term>
     <listitem>
      <para>
       从此存储池读取的字节总数。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>WR_OPS</term>
     <listitem>
      <para>
       针对此存储池请求的写入操作总数。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>WR</term>
     <listitem>
      <para>
       写入存储池的字节总数。请注意，该数值与存储池的用量不同，因为您可能会多次写入同一对象。如此一来，存储池的用量虽然不变，但写入存储池的字节数会增长。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>USED COMPR</term>
     <listitem>
      <para>
       为压缩数据分配的字节数。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>UNDER COMPR</term>
     <listitem>
      <para>
       压缩数据在未压缩时占用的字节数。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="ceph-getting-pool-values">
   <title>获取存储池值</title>
   <para>
    要从存储池中获取值，请运行以下 <command>get</command> 命令：
   </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool get <replaceable>POOL_NAME</replaceable> <replaceable>KEY</replaceable></screen>
   <para>
    您可以获取<xref linkend="ceph-pools-values"/>中所列键以及下列键的值：
   </para>
   <variablelist>
    <varlistentry>
     <term>PG_NUM</term>
     <listitem>
      <para>
       存储池的归置组数。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>PGP_NUM</term>
     <listitem>
      <para>
       计算数据归置时要使用的归置组的有效数量。有效范围等于或小于 <option>PG_NUM</option>。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <tip>
    <title>存储池的所有值</title>
    <para>
     要列出与特定存储池相关的所有值，请运行以下命令：
    </para>
<screen>
 <prompt>cephuser@adm &gt; </prompt>ceph osd pool get <replaceable>POOL_NAME</replaceable> all
 </screen>
   </tip>
  </sect2>

  <sect2 xml:id="ceph-pools-values">
   <title>设置存储池值</title>
   <para>
    要设置存储池的值，请执行以下命令：
   </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool set <replaceable>POOL_NAME</replaceable> <replaceable>KEY</replaceable> <replaceable>VALUE</replaceable></screen>
   <para>
    以下是按存储池类型排序的存储池值列表：
   </para>
   <variablelist>
    <title>通用存储池值</title>
    <varlistentry>
     <term>crash_replay_interval</term>
     <listitem>
      <para>
       允许客户端重放已确认但未提交的请求的秒数。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>pg_num</term>
     <listitem>
      <para>
       存储池的归置组数。如果您将新 OSD 添加到集群，请确认所有存储池上专用于新 OSD 的归置组的值。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>pgp_num</term>
     <listitem>
      <para>
       计算数据归置时要使用的归置组的有效数量。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>crush_ruleset</term>
     <listitem>
      <para>
       用于在集群中映射对象归置的规则组。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>hashpspool</term>
     <listitem>
      <para>
       为给定存储池设置 (1) 或取消设置 (0) HASHPSPOOL 标志。启用此标志会更改算法，以采用更佳的方式将 PG 分配到 OSD
       之间。对之前 HASHPSPOOL 标志设为默认值 0 的存储池启用此标志后，集群会开始回填，以使所有 PG
       恢复正确归置状态。请注意，此操作可能会在集群上产生大量 I/O 负载，因此请勿对负载较高的生产集群启用该标志（由 0 更改为 1）。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>nodelete</term>
     <listitem>
      <para>
       防止删除存储池。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>nopgchange</term>
     <listitem>
      <para>
       防止更改存储池的 <option>pg_num</option> 和 <option>pgp_num</option>。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>noscrub、nodeep-scrub</term>
     <listitem>
      <para>
       禁用（深层）洗刷特定存储池的数据以解决临时高 I/O 负载问题。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>write_fadvise_dontneed</term>
     <listitem>
      <para>
       在给定存储池的读/写请求上设置或取消设置 <literal>WRITE_FADVISE_DONTNEED</literal>
       标志，以绕过将数据放入缓存。默认为 <literal>false</literal>。适用于副本存储池和 EC 存储池。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>scrub_min_interval</term>
     <listitem>
      <para>
       集群负载低时洗刷存储池的最小间隔（秒）。默认值 <literal>0</literal> 表示使用来自 Ceph 配置文件的
       <option>osd_scrub_min_interval</option> 值。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>scrub_max_interval</term>
     <listitem>
      <para>
       不论集群负载如何都洗刷存储池的最大间隔（秒）。默认值 <literal>0</literal> 表示使用来自 Ceph 配置文件的
       <option>osd_scrub_max_interval</option> 值。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>deep_scrub_interval</term>
     <listitem>
      <para>
       <emphasis>深层</emphasis>洗刷存储池的间隔（秒）。默认值 <literal>0</literal> 表示使用来自 Ceph
       配置文件的 <option>osd_deep_scrub</option> 值。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <title>副本存储池值</title>
    <varlistentry>
     <term>size</term>
     <listitem>
      <para>
       设置存储池中对象的副本数。有关更多详细信息，请参见<xref linkend="ceph-pools-options-num-of-replicas"/>。仅用于副本存储池。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>min_size</term>
     <listitem>
      <para>
       设置 I/O
       所需的最小副本数。有关更多详细信息，请参见<xref linkend="ceph-pools-options-num-of-replicas"/>。仅用于副本存储池。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>nosizechange</term>
     <listitem>
      <para>
       防止更改存储池的大小。创建存储池时，默认值取自
       <option>osd_pool_default_flag_nosizechange</option> 参数的值，默认设为
       <literal>false</literal>。仅适用于副本存储池，因为无法更改 EC 存储池的大小。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>hit_set_type</term>
     <listitem>
      <para>
       对缓存池启用命中集跟踪。请参见<link xlink:href="http://en.wikipedia.org/wiki/Bloom_filter">布隆过滤器</link>以了解更多信息。此选项可用的值如下：<literal>bloom</literal>、<literal>explicit_hash</literal>、<literal>explicit_object</literal>。默认值为
       <literal>bloom</literal>，其他值仅用于测试。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>hit_set_count</term>
     <listitem>
      <para>
       要为缓存池存储的命中集数。该数值越高，<systemitem>ceph-osd</systemitem> 守护进程耗用的 RAM 越多。默认值为
       <literal>0</literal>。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>hit_set_period</term>
     <listitem>
      <para>
       缓存池的命中集期间的时长（以秒为单位）。该数值越高，<systemitem>ceph-osd</systemitem> 守护进程耗用的 RAM
       越多。创建存储池时，默认值取自 <option>osd_tier_default_cache_hit_set_period</option>
       参数的值，默认设为 <literal>1200</literal>。仅适用于副本存储池，因为 EC 存储池不能用作缓存层。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>hit_set_fpp</term>
     <listitem>
      <para>
       布隆命中集类型的误报率。请参见<link xlink:href="http://en.wikipedia.org/wiki/Bloom_filter">布隆过滤器</link>以了解更多信息。有效范围是
       0.0 - 1.0，默认值为 <literal>0.05</literal>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>use_gmt_hitset</term>
     <listitem>
      <para>
       为缓存分层创建命中集时，强制 OSD 使用 GMT（格林威治标准时间）时戳。这可确保在不同时区中的节点返回相同的结果。默认值为
       <literal>1</literal>。不应该更改此值。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>cache_target_dirty_ratio</term>
     <listitem>
      <para>
       在缓存分层代理将已修改（脏）对象刷新到后备存储池之前，包含此类对象的缓存池百分比。默认值为 <literal>0.4</literal>。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>cache_target_dirty_high_ratio</term>
     <listitem>
      <para>
       在缓存分层代理将已修改（脏）对象刷新到速度更快的后备存储池之前，包含此类对象的缓存池百分比。默认值为
       <literal>0.6</literal>。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>cache_target_full_ratio</term>
     <listitem>
      <para>
       在缓存分层代理将未修改（正常）对象从缓存池赶出之前，包含此类对象的缓存池百分比。默认值为 <literal>0.8</literal>。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>target_max_bytes</term>
     <listitem>
      <para>
       触发 <option>max_bytes</option> 阈值后，Ceph 将会开始刷新或赶出对象。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>target_max_objects</term>
     <listitem>
      <para>
       触发 <option>max_objects</option> 阈值时，Ceph 将开始刷新或赶出对象。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>hit_set_grade_decay_rate</term>
     <listitem>
      <para>
       两次连续的 <literal>hit_set</literal> 之间的温度降低率。默认值为 <literal>20</literal>。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>hit_set_search_last_n</term>
     <listitem>
      <para>
       计算温度时在 <literal>hit_set</literal> 中对出现的项最多计 <literal>N</literal> 次。默认值为
       <literal>1</literal>。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>cache_min_flush_age</term>
     <listitem>
      <para>
       在缓存分层代理将对象从缓存池刷新到存储池之前的时间（秒）。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>cache_min_evict_age</term>
     <listitem>
      <para>
       在缓存分层代理将对象从缓存池中赶出之前的时间（秒）。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist xml:id="pool-values-ec">
    <title>纠删码存储池值</title>
    <varlistentry>
     <term>fast_read</term>
     <listitem>
      <para>
       如果对纠删码存储池启用此标志，则读取请求会向所有分片发出子读取命令，并一直等到接收到足够解码的分片，才会为客户端提供服务。对于
       <emphasis>jerasure</emphasis> 和 <emphasis>isa</emphasis> 纠删插件，前
       <literal>K</literal> 个副本返回时，就会使用从这些副本解码的数据立即处理客户端的请求。采用此方法会产生较高的 CPU
       负载，而磁盘/网络负载则较低。目前，此标志仅支持用于纠删码存储池。默认值为 <literal>0</literal>。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="ceph-pools-options-num-of-replicas">
   <title>设置对象副本数</title>
   <para>
    要设置副本存储池上的对象副本数，请执行以下命令：
   </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool set <replaceable>poolname</replaceable> size <replaceable>num-replicas</replaceable></screen>
   <para>
    <replaceable>num-replicas</replaceable>
    包括对象本身。例如，如果您想用对象和对象的两个副本组成对象的三个实例，请指定 3。
   </para>
   <warning>
    <title>设置的副本不能少于 3 个</title>
    <para>
     如果将 <replaceable>num-replicas</replaceable> 设置为
     2，数据将只有<emphasis>一个</emphasis>副本。例如，如果一个对象实例发生故障，则需要在恢复期间确定自上次洗刷后，另一个副本没有损坏（有关详细信息，请参见<xref linkend="scrubbing-pgs"/>）。
    </para>
    <para>
     将存储池设置为具有一个副本意味着存储池中的数据对象只有<emphasis>一个</emphasis>实例。如果 OSD
     发生故障，您将丢失数据。如果要短时间存储临时数据，可能就会用到只有一个副本的存储池。
    </para>
   </warning>
   <tip>
    <title>设置 3 个以上的副本</title>
    <para>
     为存储池设置 4 个副本可将可靠性提高 25%。
    </para>
    <para>
     如果有两个数据中心，您至少需要为存储池设置 4
     个副本，使每个数据中心都有两个副本。如此，当其中一个数据中心发生故障时，仍有两个副本存在，并且如果又有一个磁盘发生故障，您仍可确保不会丢失数据。
    </para>
   </tip>
   <note>
    <para>
     对象可以接受降级模式下副本数量低于 <literal>pool size</literal> 的 I/O。要设置 I/O
     所需副本的最小数目，应该使用 <literal>min_size</literal> 设置。例如：
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool set data min_size 2</screen>
    <para>
     这可确保数据池中没有对象会接收到副本数量低于 <literal>min_size</literal> 的 I/O。
    </para>
   </note>
   <tip>
    <title>获取对象副本数</title>
    <para>
     要获取对象副本数，请执行以下命令：
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd dump | grep 'replicated size'</screen>
    <para>
     Ceph 将列出存储池，并高亮显示 <literal>replicated size</literal> 属性。Ceph
     默认会创建对象的两个副本（共三个副本，或者大小为 3）。
    </para>
   </tip>
  </sect2>
 </sect1>
 <sect1 xml:id="pools-migration">
  <title>存储池迁移</title>

  <para>
   创建存储池（请参见<xref linkend="ceph-pools-operate-add-pool"/>）时，您需要指定存储池的初始参数，例如存储池类型或归置组数量。如果您稍后决定更改其中的任一参数（例如将副本存储池转换为纠删码存储池，或者减少归置组数量），您需要将存储池数据迁移到其参数适合您的部署的另一个存储池。
  </para>

  <para>
   本节介绍两种迁移方法：用于常规存储池数据迁移的<emphasis>缓存层</emphasis>方法，以及使用 <command>rbd
   migrate</command> 子命令将 RBD 映像迁移到新存储池的方法。每种方法都包含特定设置和限制。
  </para>

  <sect2 xml:id="pool-migrate-limits">
   <title>限制</title>
   <itemizedlist>
    <listitem>
     <para>
      您可以使用<emphasis>缓存层</emphasis>方法从副本存储池迁移到 EC 存储池或另一个副本存储池。不支持从 EC 存储池迁移。
     </para>
    </listitem>
    <listitem>
     <para>
      您无法将 RBD 映像和 CephFS 导出项从副本存储池迁移到纠删码存储池。原因是 EC 存储池不支持
      <literal>omap</literal>，而 RBD 和 CephFS 会使用 <literal>omap</literal>
      存储其元数据。例如，系统将无法刷新 RBD 的报头对象。但您可以将数据迁移到 EC 存储池，而将元数据保留在副本存储池中。
     </para>
    </listitem>
    <listitem>
     <para>
      使用 <command>rbd migration</command> 方法可确保在迁移映像时最大限度地减少客户端停机时间。您只需在
      <option>prepare</option> 步骤之前停止客户端，并在此后再将其启动即可。请注意，只有支持此特性的
      <systemitem>librbd</systemitem> 客户端（Ceph Nautilus 或更新版本）才能在
      <option>prepare</option> 步骤之后打开映像，而较旧的 <systemitem>librbd</systemitem>
      客户端或 <systemitem>krbd</systemitem> 客户端在执行 <option>commit</option>
      步骤之前都无法打开映像。
     </para>
    </listitem>
   </itemizedlist>
  </sect2>

  <sect2 xml:id="pool-migrate-cache-tier">
   <title>使用缓存层迁移</title>
   <para>
    该方法的原理十分简单，只需将需要迁移的存储池按相反的顺序加入缓存层中即可。下面是将名为“testpool”的副本存储池迁移到纠删码存储池的示例：
   </para>
   <procedure>
    <title>将副本存储池迁移到纠删码存储池</title>
    <step>
     <para>
      创建一个名为“newpool”的新纠删码存储池。有关存储池创建参数的详细说明，请参见<xref linkend="ceph-pools-operate-add-pool"/>。
     </para>
<screen>
 <prompt>cephuser@adm &gt; </prompt>ceph osd pool create newpool erasure default
</screen>
     <para>
      确认使用的客户端密钥环提供的针对“newpool”的用户权限至少与“testpool”的相同。
     </para>
     <para>
      您现在有两个池，即装满数据的原始副本存储池“testpool”和新的空纠删码存储池“newpool”：
     </para>
     <figure>
      <title>迁移前的存储池</title>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="pool_migrate1.png" width="60%"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="pool_migrate1.png" width="60%"/>
       </imageobject>
      </mediaobject>
     </figure>
    </step>
    <step>
     <para>
      设置缓存层，并将副本存储池“testpool”配置为缓存池。通过使用 <option>-force-nonempty</option>
      选项，即使存储池已有数据，您也可以添加缓存层：
     </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph tell mon.* injectargs \
 '--mon_debug_unsafe_allow_tier_with_nonempty_snaps=1'
<prompt>cephuser@adm &gt; </prompt>ceph osd tier add newpool testpool --force-nonempty
<prompt>cephuser@adm &gt; </prompt>ceph osd tier cache-mode testpool proxy
</screen>
     <figure>
      <title>缓存层设置</title>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="pool_migrate2.png" width="60%"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="pool_migrate2.png" width="60%"/>
       </imageobject>
      </mediaobject>
     </figure>
    </step>
    <step>
     <para>
      强制缓存池将所有对象移到新池中：
     </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>rados -p testpool cache-flush-evict-all
</screen>
     <figure>
      <title>数据刷新</title>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="pool_migrate3.png" width="60%"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="pool_migrate3.png" width="60%"/>
       </imageobject>
      </mediaobject>
     </figure>
    </step>
    <step>
     <para>
      您需要指定一个覆盖层，以便在旧池中搜索对象，直到所有数据都已刷新到新的纠删码存储池。
     </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph osd tier set-overlay newpool testpool
</screen>
     <para>
      有了覆盖层，所有操作都会转到旧的副本存储池“testpool”：
     </para>
     <figure>
      <title>设置覆盖层</title>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="pool_migrate4.png" width="60%"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="pool_migrate4.png" width="60%"/>
       </imageobject>
      </mediaobject>
     </figure>
     <para>
      现在，您可以将所有客户端都切换为访问新池中的对象。
     </para>
    </step>
    <step>
     <para>
      所有数据都迁移到纠删码存储池“newpool”后，删除覆盖层和旧超速缓冲池“testpool”：
     </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph osd tier remove-overlay newpool
<prompt>cephuser@adm &gt; </prompt>ceph osd tier remove newpool testpool
</screen>
     <figure>
      <title>迁移完成</title>
      <mediaobject>
       <imageobject role="fo">
        <imagedata fileref="pool_migrate5.png" width="60%"/>
       </imageobject>
       <imageobject role="html">
        <imagedata fileref="pool_migrate5.png" width="60%"/>
       </imageobject>
      </mediaobject>
     </figure>
    </step>
    <step>
     <para>
      运行
     </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph tell mon.* injectargs \
 '--mon_debug_unsafe_allow_tier_with_nonempty_snaps=0'
</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="migrate-rbd-image">
   <title>迁移 RBD 映像</title>
   <para>
    建议采用如下方式将 RBD 映像从一个副本存储池迁移到另一个副本存储池。
   </para>
   <procedure>
    <step>
     <para>
      禁止客户端（例如虚拟机）访问 RBD 映像。
     </para>
    </step>
    <step>
     <para>
      在目标存储池中创建新映像，将其父项设置为源映像：
     </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>rbd migration prepare <replaceable>SRC_POOL</replaceable>/<replaceable>IMAGE</replaceable> <replaceable>TARGET_POOL</replaceable>/<replaceable>IMAGE</replaceable>
</screen>
     <tip>
      <title>仅将数据迁移到纠删码存储池</title>
      <para>
       如果您只需将映像数据迁移到新 EC 存储池，而将元数据保留在原始副本存储池中，请改为运行以下命令：
      </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>rbd migration prepare <replaceable>SRC_POOL</replaceable>/<replaceable>IMAGE</replaceable> \
 --data-pool <replaceable>TARGET_POOL</replaceable>/<replaceable>IMAGE</replaceable>
</screen>
     </tip>
    </step>
    <step>
     <para>
      让客户端访问目标存储池中的映像。
     </para>
    </step>
    <step>
     <para>
      将数据迁移到目标存储池：
     </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>rbd migration execute <replaceable>SRC_POOL</replaceable>/<replaceable>IMAGE</replaceable>
</screen>
    </step>
    <step>
     <para>
      删除旧映像：
     </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>rbd migration commit <replaceable>SRC_POOL</replaceable>/<replaceable>IMAGE</replaceable>
</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
 <sect1 xml:id="cha-ceph-snapshots-pool">
  <title>存储池快照</title>

  <para>
   存储池快照是整个 Ceph
   存储池的状态快照。通过存储池快照，可以保留存储池状态的历史。创建存储池快照会占用与存储池大小成正比的存储空间。在创建存储池快照之前，始终需要检查相关存储是否有足够的磁盘空间。
  </para>

  <sect2 xml:id="ceph-make-snapshot-pool">
   <title>创建存储池快照</title>
   <para>
    要创建存储池快照，请运行以下命令：
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph osd pool mksnap <replaceable>POOL-NAME</replaceable> <replaceable>SNAP-NAME</replaceable>
</screen>
   <para>
    例如：
   </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool mksnap pool1 snap1
created pool pool1 snap snap1</screen>
  </sect2>

  <sect2 xml:id="ceph-listing-snapshots-pool">
   <title>列出存储池快照</title>
   <para>
    要列出存储池的现有快照，请运行以下命令：
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>rados lssnap -p <replaceable>POOL_NAME</replaceable>
</screen>
   <para>
    例如：
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>rados lssnap -p pool1
1	snap1	2018.12.13 09:36:20
2	snap2	2018.12.13 09:46:03
2 snaps
</screen>
  </sect2>

  <sect2 xml:id="ceph-removing-snapshot-pool">
   <title>删除存储池快照</title>
   <para>
    要删除存储池的某个快照，请运行以下命令：
   </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool rmsnap <replaceable>POOL-NAME</replaceable> <replaceable>SNAP-NAME</replaceable></screen>
  </sect2>
 </sect1>
 <sect1 xml:id="sec-ceph-pool-compression">
  <title>数据压缩</title>

  <para>
   BlueStore（有关更多详细信息，请参见<xref linkend="about-bluestore"/>）提供即时数据压缩，以节省磁盘空间。压缩率取决于系统中存储的数据。请注意，压缩/解压缩需要额外的
   CPU 资源。
  </para>

  <para>
   您可以全局配置数据压缩（请参见<xref linkend="sec-ceph-pool-bluestore-compression-options"/>），然后覆盖各个存储池的特定压缩设置。
  </para>

  <para>
   无论存储池是否包含数据，您都可以启用或禁用存储池数据压缩，或者随时更改压缩算法和模式。
  </para>

  <para>
   启用存储池压缩之后，将不会向现有数据应用压缩。
  </para>

  <para>
   禁用某个存储池的压缩之后，将会解压缩该存储池的所有数据。
  </para>

  <sect2 xml:id="sec-ceph-pool-compression-enable">
   <title>启用压缩</title>
   <para>
    要对名为 <replaceable>POOL_NAME</replaceable> 的存储池启用数据压缩，请运行以下命令：
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt><command>ceph</command> osd pool set <replaceable>POOL_NAME</replaceable> compression_algorithm <replaceable>COMPRESSION_ALGORITHM</replaceable>
<prompt>cephuser@adm &gt; </prompt><command>ceph</command> osd pool set <replaceable>POOL_NAME</replaceable> compression_mode <replaceable>COMPRESSION_MODE</replaceable>
</screen>
   <tip>
    <title>禁用存储池压缩</title>
    <para>
     要对存储池禁用数据压缩，请使用“none”压缩算法：
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt><command>ceph</command> osd pool set <replaceable>POOL_NAME</replaceable> compression_algorithm none
</screen>
   </tip>
  </sect2>

  <sect2 xml:id="sec-ceph-pool-compression-options">
   <title>存储池压缩选项</title>
   <para>
    完整的压缩设置列表：
   </para>
   <variablelist>
    <varlistentry xml:id="compr-algorithm">
     <term>compression_algorithm</term>
     <listitem>
      <para>
       可用的值有
       <literal>none</literal>、<literal>zstd</literal>、<literal>snappy</literal>。默认值为
       <literal>snappy</literal>。
      </para>
      <para>
       使用的压缩算法取决于特定使用情形。以下是一些相关的建议：
      </para>
      <itemizedlist>
       <listitem>
        <para>
         只要您没有充分的理由更改默认值 <literal>snappy</literal>，就请使用该值。
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>zstd</literal> 可提供较佳的压缩率，但当压缩少量数据时，会导致 CPU 开销较高。
        </para>
       </listitem>
       <listitem>
        <para>
         针对实际数据的样本运行这些算法的基准测试，观察集群的 CPU 和内存使用率。
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry xml:id="compr-mode">
     <term>compression_mode</term>
     <listitem>
      <para>
       可用的值有
       <literal>none</literal>、<literal>aggressive</literal>、<literal>passive</literal>、<literal>force</literal>。默认值为
       <literal>none</literal>。
      </para>
      <itemizedlist>
       <listitem>
        <para>
         <literal>none</literal>：从不压缩
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>passive</literal>：如果提示 <literal>COMPRESSIBLE</literal>，则压缩
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>aggressive</literal>：除非提示
         <literal>INCOMPRESSIBLE</literal>，才压缩
        </para>
       </listitem>
       <listitem>
        <para>
         <literal>force</literal>：始终压缩
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry xml:id="compr-ratio">
     <term>compression_required_ratio</term>
     <listitem>
      <para>
       值：双精度型，比例 = SIZE_COMPRESSED / SIZE_ORIGINAL。默认值为
       <literal>0.875</literal>，这表示如果压缩未将占用空间至少减少 12.5%，将不会压缩对象。
      </para>
      <para>
       由于净增益低，存储高于此比例的对象时不会压缩。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>compression_max_blob_size</term>
     <listitem>
      <para>
       值：无符号整数，大小以字节为单位。默认值：<literal>0</literal>
      </para>
      <para>
       所压缩对象的最大大小。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>compression_min_blob_size</term>
     <listitem>
      <para>
       值：无符号整数，大小以字节为单位。默认值：<literal>0</literal>
      </para>
      <para>
       所压缩对象的最小大小。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="sec-ceph-pool-bluestore-compression-options">
   <title>全局压缩选项</title>
   <para>
    可在 Ceph 配置中设置以下配置选项，并将其应用于所有 OSD
    而不仅仅是单个存储池。<xref linkend="sec-ceph-pool-compression-options"/>中列出的存储池特定配置优先。
   </para>
   <variablelist>
    <varlistentry>
     <term>bluestore_compression_algorithm</term>
     <listitem>
      <para>
       请参见 <xref linkend="compr-algorithm"/>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>bluestore_compression_mode</term>
     <listitem>
      <para>
       请参见 <xref linkend="compr-mode"/>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>bluestore_compression_required_ratio</term>
     <listitem>
      <para>
       请参见 <xref linkend="compr-ratio"/>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>bluestore_compression_min_blob_size</term>
     <listitem>
      <para>
       值：无符号整数，大小以字节为单位。默认值：<literal>0</literal>
      </para>
      <para>
       所压缩对象的最小大小。系统默认会忽略该设置，并使用
       <option>bluestore_compression_min_blob_size_hdd</option> 和
       <option>bluestore_compression_min_blob_size_ssd</option>
       的值。如果设置为非零值，则该设置优先。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>bluestore_compression_max_blob_size</term>
     <listitem>
      <para>
       值：无符号整数，大小以字节为单位。默认值：<literal>0</literal>
      </para>
      <para>
       在将对象分割为更小的块之前所压缩对象的最大大小。系统默认会忽略该设置，并使用
       <option>bluestore_compression_max_blob_size_hdd</option> 和
       <option>bluestore_compression_max_blob_size_ssd</option>
       的值。如果设置为非零值，则该设置优先。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>bluestore_compression_min_blob_size_ssd</term>
     <listitem>
      <para>
       值：无符号整数，大小以字节为单位。默认值：<literal>8K</literal>
      </para>
      <para>
       压缩并存储在固态硬盘上的对象的最小大小。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>bluestore_compression_max_blob_size_ssd</term>
     <listitem>
      <para>
       值：无符号整数，大小以字节为单位。默认值：<literal>64K</literal>
      </para>
      <para>
       在将对象分割为更小的块之前压缩并存储在固态硬盘上的对象的最大大小。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>bluestore_compression_min_blob_size_hdd</term>
     <listitem>
      <para>
       值：无符号整数，大小以字节为单位。默认值：<literal>128K</literal>
      </para>
      <para>
       压缩并存储在普通硬盘上的对象的最小大小。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>bluestore_compression_max_blob_size_hdd</term>
     <listitem>
      <para>
       值：无符号整数，大小以字节为单位。默认值：<literal>512K</literal>
      </para>
      <para>
       在将对象分割为更小的块之前压缩并存储在硬盘上的对象的最大大小。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>
 </sect1>
</chapter>
