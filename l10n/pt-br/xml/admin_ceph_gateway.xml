<?xml version="1.0" encoding="UTF-8"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:xlink="http://www.w3.org/1999/xlink" xml:base="admin_ceph_gateway.xml" version="5.0" xml:id="cha-ceph-gw">

 <title>Gateway de Objetos do Ceph</title>
 <info>
  <dm:docmanager xmlns:dm="urn:x-suse:ns:docmanager">
   <dm:translation>sim</dm:translation>
   <dm:release>SES 7</dm:release>
  </dm:docmanager>
 </info>
 <para>
  Este capítulo apresenta detalhes sobre as tarefas de administração relacionadas ao Gateway de Objetos, como verificação de status do serviço, gerenciamento de contas, gateways multissite ou autenticação LDAP.
 </para>
 <sect1 xml:id="sec-ceph-rgw-limits">
  <title>Restrições e limitações de nomeação do Gateway de Objetos</title>

  <para>
   Veja a seguir uma lista dos limites importantes do Gateway de Objetos:
  </para>

  <sect2 xml:id="ogw-limits-bucket">
   <title>Limitações de compartimento de memória</title>
   <para>
    Ao usar o Gateway de Objetos por meio da API do S3, há um limite para os nomes de compartimento de memória que devem ser compatíveis com DNS e podem ter um traço “-”. Ao usar o Gateway de Objetos por meio da API do Swift, você pode aplicar qualquer combinação de caracteres UTF-8 permitidos, exceto a barra “/”. O tamanho máximo do nome de um compartimento de memória é de 255 caracteres. Os nomes de compartimento de memória devem ser exclusivos.
   </para>
   <tip>
    <title>Usar nomes de compartimento de memória compatíveis com DNS</title>
    <para>
     Embora seja possível usar qualquer nome de compartimento de memória baseado em UTF-8 por meio da API do Swift, é recomendável nomear os compartimentos de memória de acordo com as limitações de nomeação do S3 para evitar problemas ao acessar o mesmo compartimento de memória pela API do S3.
    </para>
   </tip>
  </sect2>

  <sect2 xml:id="ogw-limits-object">
   <title>Limitações de objetos armazenados</title>
   <variablelist>
    <varlistentry>
     <term>Número máximo de objetos por usuário</term>
     <listitem>
      <para>
       Por padrão, nenhuma restrição (limitado por ~ 2^63).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Número máximo de objetos por compartimento de memória</term>
     <listitem>
      <para>
       Por padrão, nenhuma restrição (limitado por ~ 2^63).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Tamanho máximo de um objeto para upload/armazenamento</term>
     <listitem>
      <para>
       Cada upload está restrito a 5 GB. Use várias partes para tamanhos de objetos maiores. O número máximo de pacotes de várias partes é 10.000.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="ogw-limits-http">
   <title>Limitações de cabeçalho HTTP</title>
   <para>
    A limitação de cabeçalho HTTP e de solicitação depende do front end da Web usado. O Beast padrão restringe o tamanho do cabeçalho HTTP a 16 kB.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-deploy">
  <title>Implantando o Gateway de Objetos</title>

  <para>
   A implantação do Gateway de Objetos do Ceph segue o mesmo procedimento da implantação de outros serviços do Ceph: por meio do cephadm. Para obter mais detalhes, consulte o <xref linkend="cephadm-service-and-placement-specs"/>, especificamente o <xref linkend="deploy-cephadm-day2-service-ogw"/>.
  </para>
 </sect1>
 <sect1 xml:id="ceph-rgw-operating">
  <title>Operando o serviço Gateway de Objetos</title>

  <para>
   Você pode operar os Gateways de Objetos da mesma forma que os outros serviços do Ceph, identificando primeiro o nome do serviço com o comando <command>ceph orch ps</command> e executando o seguinte comando para os serviços operacionais, por exemplo:
  </para>

<screen>ceph orch daemon restart <replaceable>OGW_SERVICE_NAME</replaceable></screen>

  <para>
   Consulte o <xref linkend="cha-ceph-operating"/> para obter informações completas sobre como operar os serviços do Ceph.
  </para>
 </sect1>
 <sect1 xml:id="ogw-config-parameters">
  <title>Opções de configuração</title>

  <para>
   Consulte a <xref linkend="config-ogw"/> para ver uma lista de opções de configuração do Gateway de Objetos.
  </para>
 </sect1>
 <sect1 xml:id="ceph-rgw-access">
  <title>Gerenciando o acesso ao Gateway de Objetos</title>

  <para>
   Você pode se comunicar com o Gateway de Objetos usando qualquer interface compatível com S3 ou Swift. A interface do S3 é compatível com um grande subconjunto da API RESTful do Amazon S3. A interface do Swift é compatível com um grande subconjunto da API do OpenStack Swift.
  </para>

  <para>
   As duas interfaces exigem que você crie um usuário específico e instale o software cliente relevante para comunicação com o gateway usando a chave secreta do usuário.
  </para>

  <sect2 xml:id="accessing-ragos-gateway">
   <title>Acessando o Gateway de Objetos</title>
   <sect3 xml:id="ogw-s3-interface-access">
    <title>Acesso à interface do S3</title>
    <para>
     Para acessar a interface do S3, você precisa de um cliente REST. <command>S3cmd</command> é um cliente S3 de linha de comando. Você pode encontrá-lo em <link xlink:href="https://build.opensuse.org/package/show/Cloud:Tools/s3cmd">OpenSUSE Build Service</link>. O repositório contém as versões para ambas as distribuições baseadas no SUSE Linux Enterprise e no openSUSE.
    </para>
    <para>
     Para testar o acesso à interface do S3, você também pode gravar um pequeno script do Python. O script se conectará ao Gateway de Objetos, criará um novo compartimento de memória e listará todos os compartimentos de memória. Os valores para <option>aws_access_key_id</option> e <option>aws_secret_access_key</option> são extraídos dos valores de <option>access_key</option> e <option>secret_key</option> retornados pelo comando <command>radosgw_admin</command> da <xref linkend="adding-s3-swift-users"/>.
    </para>
    <procedure>
     <step>
      <para>
       Instale o pacote <systemitem>python-boto</systemitem>:
      </para>
<screen><prompt role="root">root # </prompt>zypper in python-boto</screen>
     </step>
     <step>
      <para>
       Crie um novo script do Python denominado <filename>s3test.py</filename> com o seguinte conteúdo: <remark role="fixme">Provide script in RPM? Is it really necessary to create pool? This script is not necessary at all, remove it from documentation?</remark>
      </para>
<screen>import boto
import boto.s3.connection
access_key = '11BS02LGFB6AL6H1ADMW'
secret_key = 'vzCEkuryfn060dfee4fgQPqFrncKEIkh3ZcdOANY'
conn = boto.connect_s3(
aws_access_key_id = access_key,
aws_secret_access_key = secret_key,
host = '<replaceable>HOSTNAME</replaceable>',
is_secure=False,
calling_format = boto.s3.connection.OrdinaryCallingFormat(),
)
bucket = conn.create_bucket('my-new-bucket')
for bucket in conn.get_all_buckets():
  print "<replaceable>NAME</replaceable>\t<replaceable>CREATED</replaceable>".format(
  name = bucket.name,
  created = bucket.creation_date,
  )</screen>
      <para>
       Substitua <literal><replaceable>HOSTNAME</replaceable></literal> pelo nome de host no qual você configurou o serviço do Gateway de Objetos. Por exemplo, <literal>gateway_host</literal>.
      </para>
     </step>
     <step>
      <para>
       Execute o script:
      </para>
<screen>python s3test.py</screen>
      <para>
       A saída do script é parecida com o seguinte:
      </para>
<screen>my-new-bucket 2015-07-22T15:37:42.000Z</screen>
     </step>
    </procedure>
   </sect3>
   <sect3 xml:id="swift-interface-access">
    <title>Acesso à interface do Swift</title>
    <para>
     Para acessar o Gateway de Objetos pela interface do Swift, você precisa do cliente de linha de comando <command>swift</command>. A página de manual dele <command>man 1 swift</command> apresenta mais detalhes sobre as opções de linha de comando.
    </para>
    <para>
     O pacote está incluído no módulo “Public Cloud” para o SUSE Linux Enterprise 12 a partir do SP3 e o SUSE Linux Enterprise 15. Antes de instalar o pacote, você precisa ativar o módulo e atualizar o repositório de software:
    </para>
<screen><prompt role="root">root # </prompt>SUSEConnect -p sle-module-public-cloud/12/<replaceable>SYSTEM-ARCH</replaceable>
sudo zypper refresh</screen>
    <para>
     Ou
    </para>
<screen><prompt role="root">root # </prompt>SUSEConnect -p sle-module-public-cloud/15/<replaceable>SYSTEM-ARCH</replaceable>
<prompt role="root">root # </prompt>zypper refresh</screen>
    <para>
     Para instalar o comando <command>swift</command>, execute o seguinte:
    </para>
<screen><prompt role="root">root # </prompt>zypper in python-swiftclient</screen>
    <para>
     O acesso ao swift usa a seguinte sintaxe:
    </para>
<screen><prompt>tux &gt; </prompt>swift -A http://<replaceable>IP_ADDRESS</replaceable>/auth/1.0 \
-U example_user:swift -K '<replaceable>SWIFT_SECRET_KEY</replaceable>' list</screen>
    <para>
     Substitua <replaceable>IP_ADDRESS</replaceable> pelo endereço IP do servidor gateway, e <replaceable>SWIFT_SECRET_KEY</replaceable> pelo respectivo valor da saída do comando <command>radosgw-admin key create</command> executado para o usuário <systemitem>swift</systemitem> na <xref linkend="adding-s3-swift-users"/>.
    </para>
    <para>
     Por exemplo:
    </para>
<screen><prompt>tux &gt; </prompt>swift -A http://gateway.example.com/auth/1.0 -U example_user:swift \
-K 'r5wWIxjOCeEO7DixD1FjTLmNYIViaC6JVhi3013h' list</screen>
    <para>
     A saída é:
    </para>
<screen>my-new-bucket</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="s3-swift-accounts-managment">
   <title>Gerenciar contas do S3 e do Swift</title>
   <sect3 xml:id="adding-s3-swift-users">
    <title>Adicionando usuários do S3 e do Swift</title>
    <para>
     É necessário criar um usuário, uma chave de acesso e um segredo para permitir que os usuários finais interajam com o gateway. Há dois tipos de usuário: <emphasis>usuário</emphasis> e <emphasis>subusuário</emphasis>. Os <emphasis>usuários</emphasis> são usados para interagir com a interface do S3, os <emphasis>subusuários</emphasis> são usuáros da interface do Swift. Cada subusuário está associado a um usuário.
    </para>
    <para>
     Para criar um usuário do Swift, siga as etapas:
    </para>
    <procedure>
     <step>
      <para>
       Para criar um usuário do Swift, que é um <emphasis>subusuário</emphasis> em nossa terminologia, você precisa criar primeiro o <emphasis>usuário</emphasis> associado.
      </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin user create --uid=<replaceable>USERNAME</replaceable> \
 --display-name="<replaceable>DISPLAY-NAME</replaceable>" --email=<replaceable>EMAIL</replaceable></screen>
      <para>
       Por exemplo:
      </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin user create \
   --uid=example_user \
   --display-name="Example User" \
   --email=penguin@example.com</screen>
     </step>
     <step>
      <para>
       Para criar um subusuário (interface do Swift) para o usuário, você deve especificar o ID de usuário (--uid=<replaceable>USERNAME</replaceable>), um ID de subusuário e o nível de acesso para o subusuário.
      </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin subuser create --uid=<replaceable>UID</replaceable> \
 --subuser=<replaceable>UID</replaceable> \
 --access=[ <replaceable>read | write | readwrite | full</replaceable> ]</screen>
      <para>
       Por exemplo:
      </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin subuser create --uid=example_user \
 --subuser=example_user:swift --access=full</screen>
     </step>
     <step>
      <para>
       Gere uma chave secreta para o usuário.
      </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin key create \
   --gen-secret \
   --subuser=example_user:swift \
   --key-type=swift</screen>
     </step>
     <step>
      <para>
       Os dois comandos resultarão em dados formatados em JSON que mostram o estado do usuário. Observe as linhas a seguir e lembre-se do valor <literal>secret_key</literal>:
      </para>
<screen>"swift_keys": [
   { "user": "example_user:swift",
     "secret_key": "r5wWIxjOCeEO7DixD1FjTLmNYIViaC6JVhi3013h"}],</screen>
     </step>
    </procedure>
    <para/>
    <para>
     Ao acessar o Gateway de Objetos por meio da interface do S3, você precisa criar um usuário do S3 executando:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin user create --uid=<replaceable>USERNAME</replaceable> \
 --display-name="<replaceable>DISPLAY-NAME</replaceable>" --email=<replaceable>EMAIL</replaceable></screen>
    <para>
     Por exemplo:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin user create \
   --uid=example_user \
   --display-name="Example User" \
   --email=penguin@example.com</screen>
    <para>
     O comando também cria o acesso do usuário e a chave secreta. Verifique a saída para as palavras-chave <literal>access_key</literal> e <literal>secret_key</literal> e seus valores:
    </para>
<screen>[...]
 "keys": [
       { "user": "example_user",
         "access_key": "11BS02LGFB6AL6H1ADMW",
         "secret_key": "vzCEkuryfn060dfee4fgQPqFrncKEIkh3ZcdOANY"}],
 [...]</screen>
   </sect3>
   <sect3 xml:id="removing-s3-swift-users">
    <title>Removendo usuários do S3 e do Swift</title>
    <para>
     O procedimento para apagar usuários é semelhante para os usuários do S3 e do Swift. No caso dos usuários do Swift, porém, você pode precisar apagar o usuário com os subusuários incluídos.
    </para>
    <para>
     Para remover um usuário do S3 ou do Swift (incluindo todos os subusuários), especifique <option>user rm</option> e o ID de usuário no seguinte comando:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin user rm --uid=example_user</screen>
    <para>
     Para remover um subusuário, especifique <option>subuser rm</option> e o ID de subusuário.
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin subuser rm --uid=example_user:swift</screen>
    <para>
     Você pode usar as seguintes opções:
    </para>
    <variablelist>
     <varlistentry>
      <term>--purge-data</term>
      <listitem>
       <para>
        Purga todos os dados associados ao ID de usuário.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--purge-keys</term>
      <listitem>
       <para>
        Purga todas as chaves associadas ao ID de usuário.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <tip>
     <title>Removendo um subusuário</title>
     <para>
      Ao remover um subusuário, você remove o acesso à interface do Swift. O usuário permanecerá no sistema.
     </para>
    </tip>
   </sect3>
   <sect3 xml:id="changing-s3-swift-users-password">
    <title>Mudando o acesso e as chaves secretas do usuário do S3 e do Swift</title>
    <para>
     Os parâmetros <literal>access_key</literal> e <literal>secret_key</literal> identificam o usuário do Gateway de Objetos ao acessar o gateway. A mudança das chaves existentes de usuário é o mesmo que criar novas chaves, pois as chaves antigas são sobregravadas.
    </para>
    <para>
     Para usuários do S3, execute o seguinte:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin key create --uid=<replaceable>EXAMPLE_USER</replaceable> --key-type=s3 --gen-access-key --gen-secret</screen>
    <para>
     Para usuários do Swift, execute o seguinte:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin key create --subuser=<replaceable>EXAMPLE_USER</replaceable>:swift --key-type=swift --gen-secret</screen>
    <variablelist>
     <varlistentry>
      <term><option>--key-type=<replaceable>TYPE</replaceable></option></term>
      <listitem>
       <para>
        Especifica o tipo de chave. Pode ser <literal>swift</literal> ou <literal>s3</literal>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--gen-access-key</option></term>
      <listitem>
       <para>
        Gera uma chave de acesso aleatória (por padrão, para o usuário do S3).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--gen-secret</option></term>
      <listitem>
       <para>
        Gera uma chave secreta aleatória.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--secret=<replaceable>KEY</replaceable></option></term>
      <listitem>
       <para>
        Especifica uma chave secreta. Por exemplo, gerada manualmente.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="user-quota-managment">
    <title>Habilitando o gerenciamento de cotas de usuários</title>
    <para>
     O Gateway de Objetos do Ceph permite definir cotas para usuários e compartimentos de memória pertencentes aos usuários. As cotas incluem o número máximo de objetos em um compartimento de memória e o tamanho máximo de armazenamento em megabytes.
    </para>
    <para>
     Antes de habilitar uma cota de usuário, você precisa definir os respectivos parâmetros:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin quota set --quota-scope=user --uid=<replaceable>EXAMPLE_USER</replaceable> \
 --max-objects=1024 --max-size=1024</screen>
    <variablelist>
     <varlistentry>
      <term><option>--max-objects</option></term>
      <listitem>
       <para>
        Especifica o número máximo de objetos. Um valor negativo desabilita a verificação.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--max-size</option></term>
      <listitem>
       <para>
        Especifica o número máximo de bytes. Um valor negativo desabilita a verificação.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>--quota-scope</option></term>
      <listitem>
       <para>
        Define o escopo para a cota. As opções são <literal>bucket</literal> e <literal>user</literal>. As cotas de compartimento de memória aplicam-se aos compartimentos de memória que um usuário possui. As cotas de usuário aplicam-se a um usuário.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Após definir uma cota de usuário, você poderá habilitá-la:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin quota enable --quota-scope=user --uid=<replaceable>EXAMPLE_USER</replaceable></screen>
    <para>
     Para desabilitar uma cota:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin quota disable --quota-scope=user --uid=<replaceable>EXAMPLE_USER</replaceable></screen>
    <para>
     Para listar as configurações de cota:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin user info --uid=<replaceable>EXAMPLE_USER</replaceable></screen>
    <para>
     Para atualizar as estatísticas de cota:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin user stats --uid=<replaceable>EXAMPLE_USER</replaceable> --sync-stats</screen>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-http-frontends">
  <title>Front ends HTTP</title>

  <para>
   O Gateway de Objetos do Ceph suporta dois front ends HTTP incorporados: <emphasis>Beast</emphasis> e <emphasis>Civetweb</emphasis>.
  </para>

  <para>
   O front end Beast usa a biblioteca Boost.Beast para análise de HTTP e a biblioteca Boost.Asio para E/S de rede assíncrona.
  </para>

  <para>
   O front end Civetweb usa a biblioteca HTTP Civetweb, que é uma bifurcação do Mongoose.
  </para>

  <para>
   Você pode configurá-la com a opção <option>rgw_frontends</option>. Consulte a <xref linkend="config-ogw"/> para ver uma lista de opções de configuração.
  </para>
 </sect1>
 <sect1 xml:id="ceph-rgw-https">
  <title>Habilitar HTTPS/SSL para Gateways de Objetos</title>

  <para>
   Para habilitar a comunicação segura do Gateway de Objetos por meio de SSL, você precisa ter um certificado emitido por uma CA ou criar um autoassinado.
  </para>

  <sect2 xml:id="ogw-selfcert">
   <title>Criando um certificado autoassinado</title>
   <tip>
    <para>
     Ignore esta seção se você já tem um certificado válido assinado por uma CA.
    </para>
   </tip>
   <para>
    O procedimento a seguir descreve como gerar um certificado SSL autoassinado no Master Salt.
   </para>
   <procedure>
    <step>
     <para>
      Se você precisar que o Gateway de Objetos seja reconhecido por outras identidades de assunto, adicione-as à opção <option>subjectAltName</option> na seção <literal>[v3_req]</literal> do arquivo <filename>/etc/ssl/openssl.cnf</filename>:
     </para>
<screen>
[...]
[ v3_req ]
subjectAltName = DNS:server1.example.com DNS:server2.example.com
[...]
</screen>
     <tip>
      <title>Endereços IP em <option>subjectAltName</option></title>
      <para>
       Para usar endereços IP no lugar de nomes de domínio na opção <option>subjectAltName</option>, substitua a linha de exemplo pelo seguinte:
      </para>
<screen>
subjectAltName = IP:10.0.0.10 IP:10.0.0.11
</screen>
     </tip>
    </step>
    <step>
     <para>
      Crie a chave e o certificado usando <command>openssl</command>. Insira todos os dados que você precisa incluir em seu certificado. É recomendável inserir o FQDN como nome comum. Antes de assinar o certificado, verifique se “X509v3 Subject Alternative Name:” está incluído nas extensões solicitadas e se o certificado resultante tem "X509v3 Subject Alternative Name:" definido.
     </para>
<screen>
<prompt>root@master # </prompt>openssl req -x509 -nodes -days 1095 \
 -newkey rsa:4096 -keyout rgw.key
 -out rgw.pem
</screen>
    </step>
    <step>
     <para>
      Anexe a chave ao arquivo de certificado:
     </para>
<screen>
<prompt>root@master # </prompt>cat rgw.key &gt;&gt; rgw.pem
</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="ogw-sssl-config">
   <title>Configurando o Gateway de Objetos com SSL</title>
   <para>
    Para configurar o Gateway de Objetos para usar certificados SSL, use a opção <option>rgw_frontends</option>. Por exemplo:
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph config set <replaceable>WHO</replaceable> rgw_frontends \
 beast ssl_port=443 ssl_certificate=config://<replaceable>CERT</replaceable> ssl_key=config://<replaceable>KEY</replaceable>
</screen>
   <para>
    Se você não especificar as chaves de configuração <replaceable>CERT</replaceable> e <replaceable>KEY</replaceable>, o serviço Gateway de Objetos procurará o certificado SSL e a chave nas seguintes chaves de configuração:
   </para>
<screen>
rgw/cert/<replaceable>RGW_REALM</replaceable>/<replaceable>RGW_ZONE</replaceable>.key
rgw/cert/<replaceable>RGW_REALM</replaceable>/<replaceable>RGW_ZONE</replaceable>.crt
</screen>
   <para>
    Para anular a chave SSL padrão e o local do certificado, importe-os para o banco de dados de configuração usando o seguinte comando:
   </para>
<screen>ceph config-key set <replaceable>CUSTOM_CONFIG_KEY</replaceable> -i <replaceable>PATH_TO_CERT_FILE</replaceable></screen>
   <para>
    Em seguida, use as chaves de configuração personalizadas com a diretiva <literal>config://</literal>.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph-rgw-sync">
  <title>Módulos de sincronização</title>

  <para>
   O Gateway de Objetos é implantado como um serviço multissite, enquanto você pode espelhar dados e metadados entre as zonas. Os <emphasis>módulos de sincronização</emphasis> foram desenvolvidos com base na estrutura multissite, que permite encaminhar dados e metadados para uma camada externa diferente. Um módulo de sincronização permite a execução de um conjunto de ações sempre que há uma mudança nos dados (por exemplo, operações de metadados como criação de compartimento de memória ou de usuário). Como as mudanças de multissite do Gateway de Objetos acabam sendo consistentes em sites remotos, elas são propagadas de forma assíncrona. Isso abrange casos de uso como backup de armazenamento de objetos em um cluster de nuvem externo, solução de backup personalizada que usa unidades de fita ou indexação de metadados no ElasticSearch.
  </para>

  <sect2 xml:id="ogw-sync-general-config">
   <title>Configurando módulos de sincronização</title>
   <para>
    Todos os módulos de sincronização são configurados de forma semelhante. Você precisa criar uma nova zona (consulte a <xref linkend="ceph-rgw-fed"/> para obter mais detalhes) e definir a opção <option>--tier_type</option> dela, por exemplo, <option>--tier-type=cloud</option> para o módulo de sincronização de nuvem:
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zone create --rgw-zonegroup=<replaceable>ZONE-GROUP-NAME</replaceable> \
 --rgw-zone=<replaceable>ZONE-NAME</replaceable> \
 --endpoints=http://endpoint1.example.com,http://endpoint2.example.com, [...] \
 --tier-type=cloud
</screen>
   <para>
    Você pode configurar a camada específica usando o seguinte comando:
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zone modify --rgw-zonegroup=<replaceable>ZONE-GROUP-NAME</replaceable> \
 --rgw-zone=<replaceable>ZONE-NAME</replaceable> \
 --tier-config=<replaceable>KEY1</replaceable>=<replaceable>VALUE1</replaceable>,<replaceable>KEY2</replaceable>=<replaceable>VALUE2</replaceable>
</screen>
   <para>
    A <replaceable>KEY</replaceable> (CHAVE) na configuração especifica a variável de configuração que você deseja atualizar, e o <replaceable>VALUE</replaceable> (VALOR) especifica o novo valor dela. É possível usar um ponto para acessar os valores aninhados. Por exemplo:
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zone modify --rgw-zonegroup=<replaceable>ZONE-GROUP-NAME</replaceable> \
 --rgw-zone=<replaceable>ZONE-NAME</replaceable> \
 --tier-config=connection.access_key=<replaceable>KEY</replaceable>,connection.secret=<replaceable>SECRET</replaceable>
</screen>
   <para>
    Você pode acessar entradas de matriz anexando colchetes “[]” com a entrada referenciada. Você pode adicionar uma nova entrada de matriz usando colchetes “[]”. O valor do índice de -1 faz referência à última entrada na matriz. Não é possível criar uma nova entrada e fazer referência a ela novamente no mesmo comando. Por exemplo, veja a seguir um comando para criar um novo perfil para compartimentos de memória que começam com <replaceable>PREFIX</replaceable>:
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zone modify --rgw-zonegroup=<replaceable>ZONE-GROUP-NAME</replaceable> \
 --rgw-zone=<replaceable>ZONE-NAME</replaceable> \
 --tier-config=profiles[].source_bucket=<replaceable>PREFIX</replaceable>'*'
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zone modify --rgw-zonegroup=<replaceable>ZONE-GROUP-NAME</replaceable> \
 --rgw-zone=<replaceable>ZONE-NAME</replaceable> \
 --tier-config=profiles[-1].connection_id=<replaceable>CONNECTION_ID</replaceable>,profiles[-1].acls_id=<replaceable>ACLS_ID</replaceable>
</screen>
   <tip>
    <title>Adicionando e removendo entradas de configuração</title>
    <para>
     Você pode adicionar uma nova entrada de configuração de camada usando o parâmetro <option>--tier-config-add=<replaceable>KEY</replaceable>=<replaceable>VALUE</replaceable></option>.
    </para>
    <para>
     Você pode remover uma entrada existente usando <option>--tier-config-rm=<replaceable>KEY</replaceable></option>.
    </para>
   </tip>
  </sect2>

  <sect2 xml:id="ceph-rgw-sync-zones">
   <title>Sincronizando zonas</title>
   <para>
    A configuração de um módulo de sincronização é local para uma zona. O módulo de sincronização determina se a zona exporta os dados ou apenas pode consumir os dados que foram modificados em outra zona. A partir do Luminous, os plug-ins de sincronização suportados são <literal>ElasticSearch</literal>, <literal>rgw</literal>, que é o plug-in padrão que sincroniza dados entre zonas, e <literal>log</literal>, que é o plug-in comum que registra a operação de metadados executada nas zonas remotas. As seções a seguir foram elaboradas com o exemplo de uma zona que usa o módulo de sincronização <literal>ElasticSearch</literal>. O mesmo processo pode ser aplicado para configurar qualquer outro plug-in de sincronização.
   </para>
   <note>
    <title>Plug-in de sincronização padrão</title>
    <para>
     <literal>rgw</literal> é o plug-in de sincronização padrão, e não há necessidade de configurá-lo explicitamente.
    </para>
   </note>
   <sect3 xml:id="ceph-rgw-sync-zones-req">
    <title>Requisitos e considerações</title>
    <para>
     Vamos considerar uma configuração multissite simples, conforme descrito na <xref linkend="ceph-rgw-fed"/>, com 2 zonas: <literal>us-east</literal> e <literal>us-west</literal>. Agora, adicionamos uma terceira zona <literal>us-east-es</literal>, que processará apenas os metadados de outros sites. Essa zona pode estar no mesmo ou em um cluster do Ceph diferente do <literal>us-east</literal>. Essa zona consumirá apenas os metadados de outras zonas, e os Gateways de Objetos nela não atenderão diretamente nenhuma solicitação de usuário final.
    </para>
   </sect3>
   <sect3 xml:id="ceph-rgw-sync-zones-configure">
    <title>Configurando zonas</title>
    <procedure>
     <step>
      <para>
       Crie a terceira zona semelhante àquelas descritas na <xref linkend="ceph-rgw-fed"/>. Por exemplo,
      </para>
<screen>
<prompt>cephuser@adm &gt; </prompt><command>radosgw-admin</command> zone create --rgw-zonegroup=us --rgw-zone=us-east-es \
--access-key=<replaceable>SYSTEM-KEY</replaceable> --secret=<replaceable>SECRET</replaceable> --endpoints=http://rgw-es:80
      </screen>
     </step>
     <step>
      <para>
       É possível configurar um módulo de sincronização para essa zona por meio do seguinte comando:
      </para>
<screen>
<prompt>cephuser@adm &gt; </prompt><command>radosgw-admin</command> zone modify --rgw-zone=<replaceable>ZONE-NAME</replaceable> --tier-type=<replaceable>TIER-TYPE</replaceable> \
--tier-config={set of key=value pairs}
      </screen>
     </step>
     <step>
      <para>
       Por exemplo, no módulo de sincronização <literal>ElasticSearch</literal>
      </para>
<screen>
<prompt>cephuser@adm &gt; </prompt><command>radosgw-admin</command> zone modify --rgw-zone=<replaceable>ZONE-NAME</replaceable> --tier-type=elasticsearch \
--tier-config=endpoint=http://localhost:9200,num_shards=10,num_replicas=1
      </screen>
      <para>
       Para as várias opções de configuração de camada suportadas, consulte a <xref linkend="ceph-rgw-sync-elastic"/>.
      </para>
     </step>
     <step>
      <para>
       Por fim, atualize o período
      </para>
<screen>
<prompt>cephuser@adm &gt; </prompt><command>radosgw-admin</command> period update --commit
      </screen>
     </step>
     <step>
      <para>
       Agora, inicie o Gateway de Objetos na zona
      </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph orch start rgw.<replaceable>REALM-NAME</replaceable>.<replaceable>ZONE-NAME</replaceable>
      </screen>
     </step>
    </procedure>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-sync-elastic">
   <title>Módulo de sincronização ElasticSearch</title>
   <para>
    Esse módulo de sincronização grava os metadados de outras zonas no ElasticSearch. A partir do Luminous, é o JSON dos campos de dados que armazenamos no ElasticSearch atualmente.
   </para>
<screen>
{
  "_index" : "rgw-gold-ee5863d6",
  "_type" : "object",
  "_id" : "34137443-8592-48d9-8ca7-160255d52ade.34137.1:object1:null",
  "_score" : 1.0,
  "_source" : {
    "bucket" : "testbucket123",
    "name" : "object1",
    "instance" : "null",
    "versioned_epoch" : 0,
    "owner" : {
      "id" : "user1",
      "display_name" : "user1"
    },
    "permissions" : [
      "user1"
    ],
    "meta" : {
      "size" : 712354,
      "mtime" : "2017-05-04T12:54:16.462Z",
      "etag" : "7ac66c0f148de9519b8bd264312c4d64"
    }
  }
}
   </screen>
   <sect3 xml:id="ceph-rgw-sync-elastic-config">
    <title>Parâmetros de configuração de tipo de camada do ElasticSearch</title>
    <variablelist>
     <varlistentry>
      <term>endpoint</term>
      <listitem>
       <para>
        Especifica o endpoint do servidor ElasticSearch a ser acessado.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>num_shards</term>
      <listitem>
       <para>
        <emphasis>(número inteiro)</emphasis> O número de fragmentos com os quais o ElasticSearch será configurado na inicialização da sincronização de dados. Observe que ele não pode ser mudado após a inicialização. Qualquer mudança aqui requer a reconstrução do índice do ElasticSearch e a reinicialização do processo de sincronização de dados.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>num_replicas</term>
      <listitem>
       <para>
        <emphasis>(número inteiro)</emphasis> O número de réplicas com as quais o ElasticSearch será configurado na inicialização da sincronização de dados.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>explicit_custom_meta</term>
      <listitem>
       <para>
        <emphasis>(true | false) </emphasis> Especifica se todos os metadados personalizados do usuário serão indexados ou se o usuário precisará configurar (no nível do compartimento de memória) quais entradas de metadados do cliente devem ser indexadas. Por padrão, isso é “false”
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>index_buckets_list</term>
      <listitem>
       <para>
        <emphasis>(lista de strings separadas por vírgulas) </emphasis> Se vazia, todos os compartimentos de memória serão indexados. Do contrário, apenas os compartimentos de memória especificados nela serão indexados. É possível inserir prefixos (por exemplo, “foo*”) ou sufixos (por exemplo, “*bar”) de compartimento de memória.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>approved_owners_list</term>
      <listitem>
       <para>
        <emphasis>(lista de strings separadas por vírgulas)</emphasis> Se vazia, os compartimentos de memória de todos os proprietários serão indexados (sujeito a outras restrições); do contrário, apenas os compartimentos de memória pertencentes a determinados proprietários serão indexados. É possível também inserir prefixos e sufixos.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>override_index_path</term>
      <listitem>
       <para>
        <emphasis>(string)</emphasis> Se não estiver vazia, essa string será usada como o caminho do índice do ElasticSearch. Do contrário, o caminho do índice será determinado e gerado na inicialização da sincronização.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>username</term>
      <listitem>
       <para>
        Especifica um nome de usuário para o ElasticSearch se a autenticação for necessária.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>password</term>
      <listitem>
       <para>
        Especifica uma senha para o ElasticSearch se a autenticação for necessária.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="ceph-rgw-sync-elastic-query">
    <title>Consultas de metadados</title>
    <para>
     Como o cluster do ElasticSearch agora armazena metadados de objetos, é importante não expor o endpoint do ElasticSearch ao público e mantê-lo acessível apenas aos administradores de cluster. A própria exposição das consultas de metadados ao usuário final representa um problema, já que desejamos que o usuário consulte apenas os metadados dele, e não de quaisquer outros usuários. Para isso, o cluster do ElasticSearch deve autenticar os usuários de modo similar ao RGW, o que representa um problema.
    </para>
    <para>
     A partir do Luminous, o RGW na zona master de metadados agora pode atender às solicitações de usuários finais. Isso evita a exposição do endpoint do ElasticSearch ao público e resolve também o problema de autenticação e autorização, pois o próprio RGW pode autenticar as solicitações de usuário final. Para essa finalidade, o RGW inclui uma nova consulta nas APIs de compartimento de memória que pode atender às solicitações de serviço do ElasticSearch. Todas essas solicitações devem ser enviadas para a zona master de metadados.
    </para>
    <variablelist>
     <varlistentry>
      <term>Obter uma consulta do ElasticSearch</term>
      <listitem>
<screen>
GET /<replaceable>BUCKET</replaceable>?query=<replaceable>QUERY-EXPR</replaceable>
       </screen>
       <para>
        parâmetros de solicitação:
       </para>
       <itemizedlist>
        <listitem>
         <para>
          max-keys: número máx. de entradas a retornar
         </para>
        </listitem>
        <listitem>
         <para>
          marker: marcador de paginação
         </para>
        </listitem>
       </itemizedlist>
<screen>
expression := [(]&lt;arg&gt; &lt;op&gt; &lt;value&gt; [)][&lt;and|or&gt; ...]
       </screen>
       <para>
        op é um dos seguintes: &lt;, &lt;=, ==, &gt;=, &gt;
       </para>
       <para>
        Por exemplo:
       </para>
<screen>
GET /?query=name==foo
       </screen>
       <para>
        Retornará todas as chaves indexadas para as quais o usuário tem permissão de leitura e que são denominadas “foo”. A saída será uma lista de chaves em XML, que é semelhante à resposta de compartimentos de memória da lista do S3.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Configurar campos personalizados de metadados</term>
      <listitem>
       <para>
        Defina quais entradas de metadados personalizados devem ser indexadas (no compartimento de memória especificado) e quais são os tipos das chaves. Se for configurada a indexação explícita de metadados personalizados, esse procedimento será necessário para o rgw indexar os valores de metadados personalizados especificados. Do contrário, ele será necessário nos casos em que as chaves dos metadados indexados são de um tipo diferente de string.
       </para>
<screen>
POST /<replaceable>BUCKET</replaceable>?mdsearch
x-amz-meta-search: &lt;key [; type]&gt; [, ...]
       </screen>
       <para>
        Vários campos de metadados devem ser separados por vírgula. É possível forçar um tipo para um campo com “;”. Os tipos permitidos atualmente são string (padrão), número inteiro e data. Por exemplo, para indexar metadados de um objeto personalizado x-amz-meta-year como número inteiro, x-amz-meta-date como o tipo data e x-amz-meta-title como string, faça o seguinte
       </para>
<screen>
POST /mybooks?mdsearch
x-amz-meta-search: x-amz-meta-year;int, x-amz-meta-release-date;date, x-amz-meta-title;string
       </screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Apague a configuração de metadados personalizados</term>
      <listitem>
       <para>
        Apague a configuração de compartimento de memória dos metadados personalizados.
       </para>
<screen>
DELETE /<replaceable>BUCKET</replaceable>?mdsearch
       </screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Obter a configuração dos metadados personalizados</term>
      <listitem>
       <para>
        Recupere a configuração de compartimento de memória dos metadados personalizados.
       </para>
<screen>
GET /<replaceable>BUCKET</replaceable>?mdsearch
       </screen>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 xml:id="ogw-cloud-sync">
   <title>Módulo de sincronização de nuvem</title>
   <para>
    Esta seção apresenta um módulo que sincroniza os dados da zona com um serviço de nuvem remoto. A sincronização é apenas unidirecional, os dados não são sincronizados de volta da zona remota. O principal objetivo deste módulo é habilitar a sincronização de dados com vários provedores de serviços de nuvem. Atualmente, ele suporta provedores de nuvem compatíveis com a AWS (S3).
   </para>
   <para>
    Para sincronizar os dados com um serviço de nuvem remoto, você precisa configurar as credenciais do usuário. Como muitos serviços de nuvem apresentam limites quanto ao número de compartimentos de memória que cada usuário pode criar, é possível configurar o mapeamento de objetos e compartimentos de memória de origem, destinos diferentes para compartimentos de memória distintos e prefixos de compartimento de memória. Observe que as listas de acesso de origem (ACLs) não serão preservadas. É possível mapear permissões de usuários de origem específicos para usuários de destino específicos.
   </para>
   <para>
    Devido às limitações da API, não existe um modo de preservar o horário de modificação do objeto original e a tag da entidade HTTP (ETag). O módulo de sincronização de nuvem armazena essas informações como atributos de metadados nos objetos de destino.
   </para>
   <sect3 xml:id="cloud-sync-module">
    <title>Configurando o módulo de sincronização de nuvem</title>
    <para>
     Veja a seguir exemplos de uma configuração comum e não comum para o módulo de sincronização de nuvem. Observe que a configuração comum pode ser diferente da não comum.
    </para>
    <example>
     <title>Configuração comum</title>
<screen>
{
  "connection": {
    "access_key": <replaceable>ACCESS</replaceable>,
    "secret": <replaceable>SECRET</replaceable>,
    "endpoint": <replaceable>ENDPOINT</replaceable>,
    "host_style": <replaceable>path | virtual</replaceable>,
  },
  "acls": [ { "type": <replaceable>id | email | uri</replaceable>,
    "source_id": <replaceable>SOURCE_ID</replaceable>,
    "dest_id": <replaceable>DEST_ID</replaceable> } ... ],
  "target_path": <replaceable>TARGET_PATH</replaceable>,
}
</screen>
    </example>
    <example>
     <title>Configuração não comum</title>
<screen>
{
  "default": {
    "connection": {
      "access_key": <replaceable>ACCESS</replaceable>,
      "secret": <replaceable>SECRET</replaceable>,
      "endpoint": <replaceable>ENDPOINT</replaceable>,
      "host_style" <replaceable>path | virtual</replaceable>,
    },
    "acls": [
    {
      "type": <replaceable>id | email | uri</replaceable>,   #  optional, default is id
      "source_id": <replaceable>ID</replaceable>,
      "dest_id": <replaceable>ID</replaceable>
    } ... ]
    "target_path": <replaceable>PATH</replaceable> # optional
  },
  "connections": [
  {
    "connection_id": <replaceable>ID</replaceable>,
    "access_key": <replaceable>ACCESS</replaceable>,
    "secret": <replaceable>SECRET</replaceable>,
    "endpoint": <replaceable>ENDPOINT</replaceable>,
    "host_style": <replaceable>path | virtual</replaceable>,  # optional
  } ... ],
  "acl_profiles": [
  {
    "acls_id": <replaceable>ID</replaceable>, # acl mappings
    "acls": [ {
      "type": <replaceable>id | email | uri</replaceable>,
      "source_id": <replaceable>ID</replaceable>,
      "dest_id": <replaceable>ID</replaceable>
    } ... ]
  }
  ],
  "profiles": [
  {
   "source_bucket": <replaceable>SOURCE</replaceable>,
   "connection_id": <replaceable>CONNECTION_ID</replaceable>,
   "acls_id": <replaceable>MAPPINGS_ID</replaceable>,
   "target_path": <replaceable>DEST</replaceable>,          # optional
  } ... ],
}
</screen>
    </example>
    <para>
     Veja a seguir a explicação dos termos de configuração usados:
    </para>
    <variablelist>
     <varlistentry>
      <term>connection</term>
      <listitem>
       <para>
        Representa uma conexão com o serviço de nuvem remota. Contém "connection_id", "access_key", "secret", "endpoint" e "host_style".
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>access_key</term>
      <listitem>
       <para>
        A chave de acesso à nuvem remota que será usada para a conexão específica.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>secret</term>
      <listitem>
       <para>
        A chave secreta para o serviço de nuvem remota.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>endpoint</term>
      <listitem>
       <para>
        URL do endpoint do serviço de nuvem remota.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>host_style</term>
      <listitem>
       <para>
        Tipo de estilo do host ("path" ou "virtual") a ser usado quando acessar o endpoint da nuvem remota. O padrão é “path” (caminho).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>acls</term>
      <listitem>
       <para>
        Matriz de mapeamentos da lista de acesso.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>acl_mapping</term>
      <listitem>
       <para>
        Cada estrutura "acl_mapping" contém "type", "source_id" e "dest_id". Eles definirão a mutação da ACL para cada objeto. Uma mutação da ACL permite converter o ID de usuário de origem em um ID de destino.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>type</term>
      <listitem>
       <para>
        Tipo de ACL: “id” define o ID de usuário, “email” define o usuário por e-mail e “uri” define o usuário por URI (grupo).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>source_id</term>
      <listitem>
       <para>
        ID do usuário na zona de origem.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>dest_id</term>
      <listitem>
       <para>
        ID do usuário no destino.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>target_path</term>
      <listitem>
       <para>
        Uma string que define como o caminho de destino é criado. O caminho de destino especifica um prefixo ao qual o nome do objeto de origem é anexado. O caminho de destino configurável pode incluir qualquer uma das seguintes variáveis:
       </para>
       <variablelist>
        <varlistentry>
         <term>SID</term>
         <listitem>
          <para>
           Uma string exclusiva que representa o ID da instância de sincronização.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>ZONEGROUP</term>
         <listitem>
          <para>
           Nome do grupo de zonas.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>ZONEGROUP_ID</term>
         <listitem>
          <para>
           ID do grupo de zonas.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>ZONE</term>
         <listitem>
          <para>
           Nome da zona.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>ZONE_ID</term>
         <listitem>
          <para>
           ID da zona.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>BUCKET</term>
         <listitem>
          <para>
           Nome do compartimento de memória de origem.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>OWNER</term>
         <listitem>
          <para>
           ID do proprietário do compartimento de memória de origem.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
       <para>
        Por exemplo: target_path = rgwx-<replaceable>ZONE</replaceable>-<replaceable>SID</replaceable>/<replaceable>OWNER</replaceable>/<replaceable>BUCKET</replaceable>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>acl_profiles</term>
      <listitem>
       <para>
        Uma matriz de perfis da lista de acesso.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>acl_profile</term>
      <listitem>
       <para>
        Cada perfil contém: “acls_id”, que representa o perfil, e uma matriz de “acls”, que armazena uma lista de “acl_mappings”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>profiles</term>
      <listitem>
       <para>
        Uma lista de perfis. Cada perfil contém o seguinte:
       </para>
       <variablelist>
        <varlistentry>
         <term>source_bucket</term>
         <listitem>
          <para>
           Nome ou prefixo do compartimento de memória (se terminar com *), que define o(s) compartimento(s) de memória de origem para este perfil.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>target_path</term>
         <listitem>
          <para>
           Veja a explicação acima.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>connection_id</term>
         <listitem>
          <para>
           ID da conexão que será usada para este perfil.
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term>acls_id</term>
         <listitem>
          <para>
           ID do perfil da ACL que será usado para este perfil.
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="s3-specific-configurables">
    <title>Elementos de configuração específicos do S3</title>
    <para>
     O módulo de sincronização de nuvem apenas funcionará com back ends compatíveis com o AWS S3. Há alguns elementos de configuração que podem ser usados para ajustar o comportamento ao acessar serviços de nuvem do S3:
    </para>
<screen>
{
  "multipart_sync_threshold": <replaceable>OBJECT_SIZE</replaceable>,
  "multipart_min_part_size": <replaceable>PART_SIZE</replaceable>
}
</screen>
    <variablelist>
     <varlistentry>
      <term>multipart_sync_threshold</term>
      <listitem>
       <para>
        Os objetos cujo tamanho é igual ou maior do que esse valor serão sincronizados com o serviço de nuvem por meio do upload de várias partes.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>multipart_min_part_size</term>
      <listitem>
       <para>
        Tamanho mínimo das partes para usar na sincronização de objetos por meio do upload de várias partes.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>

  <sect2 xml:id="archive-sync-module">
   <title>Módulo de sincronização de arquivo</title>
   <para>
    O <emphasis>módulo de sincronização de arquivo</emphasis> usa o recurso de controle de versão dos objetos do S3 no Gateway de Objetos. Você pode configurar uma <emphasis>zona de arquivo</emphasis>, que captura as diferentes versões dos objetos do S3 à medida que surgem nas outras zonas ao longo do tempo. O histórico de versões que a zona de arquivo mantém apenas pode ser eliminado pelos gateways associados à zona de arquivo.
   </para>
   <para>
    Com essa arquitetura, várias zonas sem controle versão podem espelhar seus dados e metadados por meio de seus gateways de zona, oferecendo alta disponibilidade aos usuários finais, enquanto a zona de arquivo captura todas as atualizações de dados para consolidá-los como versões dos objetos do S3.
   </para>
   <para>
    Ao incluir a zona de arquivo em uma configuração de várias zonas, você ganha a flexibilidade de um histórico de objetos do S3 em uma zona, além de economizar o espaço que as réplicas dos objetos do S3 com controle de versão consomem nas zonas restantes.
   </para>
   <sect3 xml:id="archive-sync-module-configuration">
    <title>Configurando o módulo de sincronização de arquivo</title>
    <tip>
     <title>Mais informações</title>
     <para>
      Consulte a <xref linkend="ceph-rgw-fed"/> para obter detalhes sobre a configuração de gateways multissite.
     </para>
     <para>
      Consulte a <xref linkend="ceph-rgw-sync"/> para obter detalhes sobre a configuração de módulos de sincronização.
     </para>
    </tip>
    <para>
     Para usar o módulo de sincronização de arquivo, você precisa criar uma nova zona com o tipo de camada definido como <literal>arquivo</literal>:
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zone create --rgw-zonegroup=<replaceable>ZONE_GROUP_NAME</replaceable> \
 --rgw-zone=<replaceable>OGW_ZONE_NAME</replaceable> \
 --endpoints=<replaceable>http://OGW_ENDPOINT1_URL[,http://OGW_ENDPOINT2_URL,...]</replaceable>
 --tier-type=archive
</screen>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph-rgw-ldap">
  <title>Autenticação LDAP</title>

  <para>
   Além da autenticação de usuário local padrão, o Gateway de Objetos pode usar os serviços do servidor LDAP para autenticar também os usuários.
  </para>

  <sect2 xml:id="ceph-rgw-ldap-how-works">
   <title>Mecanismo de autenticação</title>
   <para>
    O Gateway de Objetos extrai as credenciais de LDAP do usuário de um token. Um filtro de pesquisa é construído com base no nome de usuário. O Gateway de Objetos usa a conta de serviço configurada para pesquisar uma entrada correspondente no diretório. Se uma entrada for encontrada, o Gateway de Objetos tentará se vincular ao nome exclusivo encontrado com a senha do token. Se as credenciais forem válidas, o vínculo será bem-sucedido, e o Gateway de Objetos concederá o acesso.
   </para>
   <para>
    Você pode limitar os usuários permitidos definindo a base para a pesquisa como uma unidade organizacional específica ou especificando um filtro de pesquisa personalizado. Por exemplo, exigir a participação em um grupo específico, classes de objetos ou atributos personalizados.
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-ldap-reqs">
   <title>Requisitos</title>
   <itemizedlist>
    <listitem>
     <para>
      <emphasis>LDAP ou Active Directory</emphasis>: Uma instância LDAP em execução acessível pelo Gateway de Objetos.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis>Conta de serviço</emphasis>: Credenciais LDAP para uso do Gateway de Objetos com permissões de pesquisa.
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis>Conta de usuário</emphasis>: Pelo menos, uma conta do usuário no diretório LDAP.
     </para>
    </listitem>
   </itemizedlist>
   <important>
    <title>não sobreponha usuários LDAP e locais</title>
    <para>
     Você não deve usar os mesmos nomes para usuários locais e usuários autenticados por LDAP. O Gateway de Objetos não pode diferenciá-los e os trata como se fossem os mesmos usuários.
    </para>
   </important>
   <tip>
    <title>Verificações de integridade</title>
    <para>
     Use o utilitário <command>ldapsearch</command> para verificar a conta de serviço ou a conexão LDAP. Por exemplo:
    </para>
<screen><prompt>tux &gt; </prompt>ldapsearch -x -D "uid=ceph,ou=system,dc=example,dc=com" -W \
-H ldaps://example.com -b "ou=users,dc=example,dc=com" 'uid=*' dn</screen>
    <para>
     Use os mesmos parâmetros LDAP que o arquivo de configuração do Ceph para evitar possíveis problemas.
    </para>
   </tip>
  </sect2>

  <sect2 xml:id="ceph-rgw-ldap-config">
   <title>Configurando o Gateway de Objetos para usar a autenticação LDAP</title>
   <para>
    Os parâmetros a seguir estão relacionados à autenticação LDAP:
   </para>
   <variablelist>
    <varlistentry>
     <term><option>rgw_ldap_uri</option></term>
     <listitem>
      <para>
       Especifica o servidor LDAP a ser usado. Use o parâmetro <literal>ldaps://<replaceable>FQDN</replaceable>:<replaceable>PORT</replaceable></literal> para evitar a transmissão aberta de credenciais de texto simples.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>rgw_ldap_binddn</option></term>
     <listitem>
      <para>
       O DN (Distinguished Name – Nome Exclusivo) da conta de serviço usada pelo Gateway de Objetos.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>rgw_ldap_secret</option></term>
     <listitem>
      <para>
       A senha para a conta de serviço.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>rgw_ldap_searchdn</term>
     <listitem>
      <para>
       Especifica a base na árvore de informações do diretório para pesquisar usuários. Ela pode ser a unidade organizacional de usuários ou alguma OU (Organizational Unit – Unidade Organizacional) mais específica.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>rgw_ldap_dnattr</option></term>
     <listitem>
      <para>
       O atributo que está sendo usado no filtro de pesquisa construído para corresponder um nome de usuário. Dependendo da DIT (Directory Information Tree – Árvore de Informações do Diretório), ele provavelmente será <literal>uid</literal> ou <literal>cn</literal>.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>rgw_search_filter</option></term>
     <listitem>
      <para>
       Se não for especificado, o Gateway de Objetos construirá automaticamente o filtro de pesquisa com a configuração <option>rgw_ldap_dnattr</option>. Use esse parâmetro para restringir a lista de usuários permitidos com muita flexibilidade. Consulte a <xref linkend="ceph-rgw-ldap-filter"/> para obter detalhes.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </sect2>

  <sect2 xml:id="ceph-rgw-ldap-filter">
   <title>Usando um filtro de pesquisa personalizado para limitar o acesso do usuário</title>
   <para>
    Você pode usar o parâmetro <option>rgw_search_filter</option> de duas maneiras.
   </para>
   <sect3 xml:id="partial-filter-search-filter">
    <title>Filtro parcial para limitar ainda mais o filtro de pesquisa construído</title>
    <para>
     Veja a seguir um exemplo de filtro parcial:
    </para>
<screen>"objectclass=inetorgperson"</screen>
    <para>
     O Gateway de Objetos gerará o filtro de pesquisa como de costume com o nome de usuário extraído do token e o valor de <option>rgw_ldap_dnattr</option>. Em seguida, o filtro construído será combinado ao filtro parcial com base no atributo <option>rgw_search_filter</option>. Dependendo do nome de usuário e das configurações, o filtro de pesquisa final poderá ser:
    </para>
<screen>"(&amp;(uid=hari)(objectclass=inetorgperson))"</screen>
    <para>
     Nesse caso, o usuário “hari” apenas receberá acesso se for encontrado no diretório LDAP, se tiver uma classe de objeto “inetorgperson” e se especificar uma senha válida.
    </para>
   </sect3>
   <sect3 xml:id="complete-filter">
    <title>Filtro completo</title>
    <para>
     Um filtro completo deve conter um token <option>USERNAME</option> que será substituído pelo nome de usuário durante a tentativa de autenticação. O parâmetro <option>rgw_ldap_dnattr</option> não é mais usado neste caso. Por exemplo, para limitar os usuários válidos a um grupo específico, use o filtro a seguir:
    </para>
<screen>"(&amp;(uid=USERNAME)(memberOf=cn=ceph-users,ou=groups,dc=mycompany,dc=com))"</screen>
    <note>
     <title>Atributo <literal>memberOf</literal></title>
     <para>
      O uso do atributo <literal>memberOf</literal> nas pesquisas LDAP requer suporte da sua implementação de servidor LDAP específica.
     </para>
    </note>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-ldap-token">
   <title>Gerando um token de acesso para autenticação LDAP</title>
   <para>
    O utilitário <command>radosgw-token</command> gera o token de acesso com base no nome de usuário e na senha LDAP. Ele emite uma string codificada com base64, que é o token de acesso real. Use seu cliente S3 favorito (consulte a <xref linkend="accessing-ragos-gateway"/>), especifique o token como a chave de acesso e use uma chave secreta vazia.
   </para>
<screen><prompt>tux &gt; </prompt>export RGW_ACCESS_KEY_ID="<replaceable>USERNAME</replaceable>"
<prompt>tux &gt; </prompt>export RGW_SECRET_ACCESS_KEY="<replaceable>PASSWORD</replaceable>"
<prompt>cephuser@adm &gt; </prompt>radosgw-token --encode --ttype=ldap</screen>
   <important>
    <title>credenciais de texto sem criptografia</title>
    <para>
     O token de acesso é uma estrutura JSON codificada com base64 que contém as credenciais LDAP como texto sem criptografia.
    </para>
   </important>
   <note>
    <title>Active Directory</title>
    <para>
     Para o Active Directory, use o parâmetro <option>--ttype=ad</option>.
    </para>
   </note>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-bucket-sharding">
  <title>Fragmentação de índice do compartimento de memória</title>

  <para>
   O Gateway de Objetos armazena os dados de índice do compartimento de memória em um pool de índice, que assume <literal>.rgw.buckets.index</literal> como padrão. Se você colocar um número excessivo (centenas de milhares) de objetos em um único compartimento de memória, e a cota para o número máximo de objetos por compartimento de memória (<option>rgw bucket default quota max objects</option>) não for definida, o desempenho do pool de índice poderá ser prejudicado. A <emphasis>fragmentação de índice do compartimento de memória</emphasis> impede essa redução no desempenho e permite um alto número de objetos por compartimento de memória.
  </para>

  <sect2 xml:id="ogw-bucket-reshard">
   <title>Refragmentação de índice do compartimento de memória</title>
   <para>
    Se um compartimento de memória ficar muito grande e sua configuração inicial não for mais suficiente, será necessário refragmentar o pool de índice dele. Você pode usar a refragmentação de índice do compartimento de memória automática online (consulte a <xref linkend="ogw-bucket-sharding-dyn"/>) ou refragmentar o índice do compartimento de memória offline manualmente (consulte a <xref linkend="ogw-bucket-sharding-re"/>).
   </para>
   <sect3 xml:id="ogw-bucket-sharding-dyn">
    <title>Refragmentação dinâmica</title>
    <para>
     A partir do SUSE Enterprise Storage 5, oferecemos suporte à refragmentação do compartimento de memória online. Ela detecta se o número de objetos por compartimento de memória atinge determinado limite e aumenta automaticamente o número de fragmentos usados pelo índice do compartimento de memória. Esse processo reduz o número de entradas em cada fragmento de índice do compartimento de memória.
    </para>
    <para>
     O processo de detecção é executado:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Quando novos objetos são adicionados ao compartimento de memória.
      </para>
     </listitem>
     <listitem>
      <para>
       Em um processo em segundo plano que explora periodicamente todos os compartimentos de memória. Isso é necessário para resolver a questão de compartimentos de memória existentes que não são atualizados.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     Um compartimento de memória que requer refragmentação é adicionado à fila <option>reshard_log</option> e será programado para ser refragmentado posteriormente. Os threads de refragmentação são executados em segundo plano e executam a refragmentação programada, uma de cada vez.
    </para>
    <variablelist>
     <title>Configurando a refragmentação dinâmica</title>
     <varlistentry>
      <term><option>rgw_dynamic_resharding</option></term>
      <listitem>
       <para>
        Habilita ou desabilita a refragmentação dinâmica de índice do compartimento de memória. Os valores possíveis são “true” (verdadeiro) ou “false” (falso). O padrão é “true”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw_reshard_num_logs</option></term>
      <listitem>
       <para>
        Número de fragmentos para o registro da refragmentação. O padrão é 16.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw_reshard_bucket_lock_duration</option></term>
      <listitem>
       <para>
        Duração do bloqueio do objeto do compartimento de memória durante a refragmentação. O padrão é 120 segundos.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw_max_objs_per_shard</option></term>
      <listitem>
       <para>
        Número máximo de objetos por fragmento de índice do compartimento de memória. O padrão é 100.000 objetos.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw_reshard_thread_interval</option></term>
      <listitem>
       <para>
        Tempo máxithread de refragmentaçãomo entre os ciclos de processamento do . O padrão é 600 segundos.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <variablelist>
     <title>Comandos para administrar o processo de refragmentação</title>
     <varlistentry>
      <term>Adicionar um compartimento de memória à fila de refragmentação:</term>
      <listitem>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin reshard add \
 --bucket <replaceable>BUCKET_NAME</replaceable> \
 --num-shards <replaceable>NEW_NUMBER_OF_SHARDS</replaceable>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Listar a fila de refragmentação:</term>
      <listitem>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin reshard list
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Processar/Programar a refragmentação de um compartimento de memória:</term>
      <listitem>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin reshard process
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Exibir o status da refragmentação do compartimento de memória:</term>
      <listitem>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin reshard status --bucket <replaceable>BUCKET_NAME</replaceable>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Cancelar uma refragmentação pendente do compartimento de memória:</term>
      <listitem>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin reshard cancel --bucket <replaceable>BUCKET_NAME</replaceable>
</screen>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
   <sect3 xml:id="ogw-bucket-sharding-re">
    <title>Refragmentação manual</title>
    <para>
     A refragmentação dinâmica mencionada na <xref linkend="ogw-bucket-sharding-dyn"/> é suportada apenas nas configurações simples do Gateway de Objetos. Para configurações multissite, use a refragmentação manual descrita nesta seção.
    </para>
    <para>
     Para refragmentar o índice do compartimento de memória manualmente offline, use o seguinte comando:
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin bucket reshard
</screen>
    <para>
     O comando <command>bucket reshard</command> executa o seguinte:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       Cria um novo conjunto de objetos de índice do compartimento de memória para o objeto especificado.
      </para>
     </listitem>
     <listitem>
      <para>
       Distribui todas as entradas desses objetos de índice.
      </para>
     </listitem>
     <listitem>
      <para>
       Cria uma nova instância do compartimento de memória.
      </para>
     </listitem>
     <listitem>
      <para>
       Vincula a nova instância do compartimento de memória ao compartimento de memória para que todas as novas operações de índice passem pelos novos índices do compartimento de memória.
      </para>
     </listitem>
     <listitem>
      <para>
       Imprime o ID do compartimento de memória antigo e novo para a saída padrão.
      </para>
     </listitem>
    </itemizedlist>
    <tip>
     <para>
      Ao escolher um número de fragmentos, observe o seguinte: especifique no máximo 100.000 entradas por fragmento. Os fragmentos de índice do compartimento de memória que são números primos costumam funcionar melhor na distribuição uniforme das entradas de índice do compartimento de memória entre os fragmentos. Por exemplo, 503 fragmentos de índice do compartimento de memória são melhores do que 500, pois o primeiro é número primo.
     </para>
    </tip>
    <procedure>
     <title>Refragmentando o índice do compartimento de memória</title>
     <step>
      <para>
       Verifique se todas as operações no compartimento de memória foram interrompidas.
      </para>
     </step>
     <step>
      <para>
       Faça backup do índice original do compartimento de memória:
      </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin bi list \
 --bucket=<replaceable>BUCKET_NAME</replaceable> \
 &gt; <replaceable>BUCKET_NAME</replaceable>.list.backup
</screen>
     </step>
     <step>
      <para>
       Refragmente o índice do compartimento de memória:
      </para>
<screen>
 <prompt>cephuser@adm &gt; </prompt>radosgw-admin bucket reshard \
 --bucket=<replaceable>BUCKET_NAME</replaceable> \
 --num-shards=<replaceable>NEW_SHARDS_NUMBER</replaceable>
</screen>
      <tip>
       <title>ID do compartimento de memória antigo</title>
       <para>
        Como parte da saída, esse comando também imprime o ID do compartimento de memória novo e antigo.
       </para>
      </tip>
     </step>
    </procedure>
   </sect3>
  </sect2>

  <sect2 xml:id="ogw-bucket-sharding-new">
   <title>Fragmentação de índice para novos compartimentos de memória</title>
   <para>
    Há duas opções que afetam a fragmentação de índice do compartimento de memória:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Use a opção <option>rgw_override_bucket_index_max_shards</option> para configurações simples.
     </para>
    </listitem>
    <listitem>
     <para>
      Use a opção <option>bucket_index_max_shards</option> para configurações multissite.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    A definição das opções como <literal>0</literal> desabilita a fragmentação de índice do compartimento de memória. Um valor maior do que <literal>0</literal> habilita a fragmentação de índice do compartimento de memória e define o número máximo de fragmentos.
   </para>
   <para>
    A fórmula a seguir ajuda você a calcular o número recomendado de fragmentos:
   </para>
<screen>
number_of_objects_expected_in_a_bucket / 100000
</screen>
   <para>
    Esteja ciente de que o número máximo de fragmentos é 7877.
   </para>
   <sect3 xml:id="multisite-config-bucket">
    <title>Configurações multissite</title>
    <para>
     As configurações multissite podem ter um pool de índice diferente para gerenciar o failover. Para configurar um número consistente de fragmentos para as zonas em um grupo de zonas, defina a opção <option>bucket_index_max_shards</option> na configuração do grupo de zonas:
    </para>
    <procedure>
     <step>
      <para>
       Exporte a configuração do grupo de zonas para o arquivo <filename>zonegroup.json</filename>:
      </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zonegroup get &gt; zonegroup.json
</screen>
     </step>
     <step>
      <para>
       Edite o arquivo <filename>zonegroup.json</filename> e defina a opção <option>bucket_index_max_shards</option> para cada zona nomeada.
      </para>
     </step>
     <step>
      <para>
       Redefina o grupo de zonas:
      </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zonegroup set &lt; zonegroup.json
</screen>
     </step>
     <step>
      <para>
       Atualize o período. Consulte a <xref linkend="ceph-rgw-fed-masterzone-updateperiod"/>.
      </para>
     </step>
    </procedure>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-keystone">
  <title>Integração do OpenStack Keystone</title>

  <para>
   O OpenStack Keystone é um serviço de identidade que faz parte do produto OpenStack. Você pode integrar o Gateway de Objetos ao Keystone para configurar um gateway que aceita o token de autenticação do Keystone. Um usuário autorizado pelo Keystone a acessar o gateway será verificado no Gateway de Objetos do Ceph e criado automaticamente, se necessário. O Gateway de Objetos consulta o Keystone periodicamente para obter uma lista de tokens revogados.
  </para>

  <sect2 xml:id="ogw-keystone-ostack">
   <title>Configurando o OpenStack</title>
   <para>
    Antes de configurar o Gateway de Objetos do Ceph, você precisa configurar o OpenStack Keystone para habilitar o serviço Swift e apontá-lo para o Gateway de Objetos do Ceph:
   </para>
   <procedure>
    <step>
     <para>
      <emphasis>Defina o serviço Swift.</emphasis> Para usar o OpenStack para validar usuários do Swift, crie primeiro o serviço Swift:
     </para>
<screen>
<prompt>tux &gt; </prompt>openstack service create \
 --name=swift \
 --description="Swift Service" \
 object-store
</screen>
    </step>
    <step>
     <para>
      <emphasis>Defina os endpoints.</emphasis> Após criar o serviço Swift, aponte para o Gateway de Objetos do Ceph. Substitua <replaceable>REGION_NAME</replaceable> pelo nome do grupo de zonas ou da região do gateway.
     </para>
<screen>
<prompt>tux &gt; </prompt>openstack endpoint create --region <replaceable>REGION_NAME</replaceable> \
 --publicurl   "http://radosgw.example.com:8080/swift/v1" \
 --adminurl    "http://radosgw.example.com:8080/swift/v1" \
 --internalurl "http://radosgw.example.com:8080/swift/v1" \
 swift
</screen>
    </step>
    <step>
     <para>
      <emphasis>Verifique as configurações.</emphasis> Após criar o serviço Swift e definir os endpoints, mostre os endpoints para verificar se todas as configurações estão corretas.
     </para>
<screen>
<prompt>tux &gt; </prompt>openstack endpoint show object-store
</screen>
    </step>
   </procedure>
  </sect2>

  <sect2 xml:id="ogw-keystone-ogw">
   <title>Configurando o Gateway de Objetos do Ceph</title>
   <sect3>
    <title>Configurar certificados SSL</title>
    <para>
     O Gateway de Objetos do Ceph consulta o Keystone periodicamente para obter uma lista de tokens revogados. Essas solicitações são codificadas e assinadas. É possível também configurar o Keystone para fornecer tokens autoassinados, que também são codificados e assinados. Você precisa configurar o gateway para que possa decodificar e verificar essas mensagens assinadas. Portanto, os certificados OpenSSL que o Keystone usa para criar as solicitações precisam ser convertidos no formato “nss db”:
    </para>
<screen>
<prompt role="root">root # </prompt>mkdir /var/ceph/nss
<prompt role="root">root # </prompt>openssl x509 -in /etc/keystone/ssl/certs/ca.pem \
 -pubkey | certutil -d /var/ceph/nss -A -n ca -t "TCu,Cu,Tuw"
<systemitem class="username">root</systemitem>openssl x509 -in /etc/keystone/ssl/certs/signing_cert.pem \
 -pubkey | certutil -A -d /var/ceph/nss -n signing_cert -t "P,P,P"
</screen>
    <para>
     Para permitir que o Gateway de Objetos do Ceph interaja com o OpenStack Keystone, o OpenStack Keystone pode usar um certificado SSL autoassinado. Instale o certificado SSL do Keystone no nó que executa o Gateway de Objetos do Ceph ou, se preferir, defina o valor da opção <option>rgw keystone verify ssl</option> como “false”. A definição de <option>rgw keystone verify ssl</option> como “false” indica que o gateway não tentará verificar o certificado.
    </para>
   </sect3>
   <sect3 xml:id="config-ogw-options">
    <title>Configurar as opções do Gateway de Objetos</title>
    <para>
     Você pode configurar a integração com o Keystone usando as seguintes opções:
    </para>
    <variablelist>
     <varlistentry>
      <term><option>rgw keystone api version</option></term>
      <listitem>
       <para>
        Versão da API do Keystone. As opções válidas são 2 ou 3. O padrão é 2.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone url</option></term>
      <listitem>
       <para>
        O URL e o número da porta da API RESTful administrativa no servidor Keystone. Segue o padrão <replaceable>URL_SERVIDOR:NÚMERO_DA_PORTA</replaceable>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone admin token</option></term>
      <listitem>
       <para>
        O token ou segredo compartilhado configurado internamente no Keystone para solicitações administrativas.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone accepted roles</option></term>
      <listitem>
       <para>
        As funções necessárias para atender às solicitações. O padrão é “Member, admin”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone accepted admin roles</option></term>
      <listitem>
       <para>
        A lista de funções que permite a um usuário obter privilégios administrativos.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone token cache size</option></term>
      <listitem>
       <para>
        O número máximo de entradas no cache de token do Keystone.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone revocation interval</option></term>
      <listitem>
       <para>
        O número de segundos antes de verificar se há tokens revogados. O padrão é 15 * 60.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone implicit tenants</option></term>
      <listitem>
       <para>
        Criar novos usuários em seus próprios locatários de mesmo nome. O padrão é “false”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw s3 auth use keystone</option></term>
      <listitem>
       <para>
        Se definido como “true”, o Gateway de Objetos do Ceph autenticará os usuários com o Keystone. O padrão é “false”.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>nss db path</option></term>
      <listitem>
       <para>
        O caminho para o banco de dados NSS.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Também é possível configurar o locatário de serviço, o usuário e a senha do Keystone (para a versão 2.0 da API do OpenStack Identity), do mesmo modo que os serviços do OpenStack costumam ser configurados. Dessa forma, você pode evitar a definição do segredo compartilhado <option>rgw keystone admin token</option> no arquivo de configuração, que deve ser desabilitado em ambientes de produção. As credenciais do locatário de serviço devem ter privilégios de admin. Para obter mais detalhes, consulte a <link xlink:href="https://docs.openstack.org/keystone/latest/#setting-up-projects-users-and-roles">documentação oficial do OpenStack Keystone</link>. Veja a seguir as opções de configuração relacionadas:
    </para>
    <variablelist>
     <varlistentry>
      <term><option>rgw keystone admin user</option></term>
      <listitem>
       <para>
        Nome do usuário administrador do Keystone.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone admin password</option></term>
      <listitem>
       <para>
        Senha do usuário administrador do Keystone.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone admin tenant</option></term>
      <listitem>
       <para>
        Locatário do usuário administrador do Keystone versão 2.0.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Um usuário do Gateway de Objetos do Ceph é mapeado para um locatário do Keystone. Um usuário do Keystone tem funções diferentes atribuídas, possivelmente em mais do que um locatário. Quando o Gateway de Objetos do Ceph recebe o ticket, ele examina o locatário e as funções do usuário atribuídas a esse ticket e aceita ou rejeita a solicitação de acordo com a configuração da opção <option>rgw keystone accepted roles</option>.
    </para>
    <tip>
     <title>Mapeando para locatários do OpenStack</title>
     <para>
      Embora os locatários do Swift sejam mapeados para o usuário do Gateway de Objetos por padrão, eles também podem ser mapeados para os locatários do OpenStack por meio da opção <option>rgw keystone implicit tenants</option>. Isso fará com que os containers usem o namespace do locatário em vez do namespace global do tipo do S3 que o Gateway de Objetos usa como padrão. É recomendável decidir sobre o método de mapeamento na fase de planejamento para evitar confusão. O motivo dessa recomendação é que alternar a opção posteriormente afeta apenas as solicitações mais recentes que são mapeadas em um locatário, enquanto os compartimentos de memória mais antigos criados antes ainda continuam em um namespace global.
     </para>
    </tip>
    <para>
     Para obter a versão 3 da API do OpenStack Identity, você deve substituir a opção <option>rgw keystone admin tenant</option> por:
    </para>
    <variablelist>
     <varlistentry>
      <term><option>rgw keystone admin domain</option></term>
      <listitem>
       <para>
        Domínio do usuário administrador do Keystone.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><option>rgw keystone admin project</option></term>
      <listitem>
       <para>
        Projeto do usuário administrador do Keystone.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect3>
  </sect2>
 </sect1>
 <sect1 xml:id="ogw-storage-classes">
  <title>Posicionamento do pool e classes de armazenamento</title>

  <sect2 xml:id="ogw-storage-classes-placement-targets">
   <title>Exibindo destinos de posicionamento</title>
   <para>
    Os destinos de posicionamento controlam os pools que serão associados a um determinado compartimento de memória. O destino de posicionamento de um compartimento de memória é selecionado na criação e não pode ser modificado. Você pode executar o comando a seguir para exibir a respectiva regra <literal>placement_rule</literal>:
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin bucket stats
</screen>
   <para>
    A configuração do grupo de zonas contém uma lista de destinos de posicionamento com um destino inicial chamado "default-placement". A configuração da zona mapeia cada nome de destino de posicionamento do grupo de zonas para o respectivo armazenamento local. Essas informações de posicionamento de zona incluem o nome "index_pool" para o índice de compartimento de memória, o nome "data_extra_pool" para os metadados sobre uploads de várias partes incompletos e um nome "data_pool" para cada classe de armazenamento.
   </para>
  </sect2>

  <sect2 xml:id="ogw-storage-classes-itself">
   <title>Classes de armazenamento</title>
   <para>
    As classes de armazenamento ajudam a personalizar o posicionamento dos dados de objetos. As regras de Ciclo de Vida de Compartimento de Memória do S3 podem automatizar a transição dos objetos entre as classes de armazenamento.
   </para>
   <para>
    As classes de armazenamento são definidas em termos de destinos de posicionamento. Cada destino de posicionamento do grupo de zonas lista suas classes de armazenamento disponíveis com uma classe inicial chamada “STANDARD”. A configuração da zona é responsável por conceder um nome de pool "data_pool" a cada uma das classes de armazenamento do grupo de zonas.
   </para>
  </sect2>

  <sect2 xml:id="ogw-storage-classes-zone-config">
   <title>Configurando grupos de zonas e zonas</title>
   <para>
    Use o comando <command>radosgw-admin</command> nos grupos de zonas e nas zonas para configurar o respectivo posicionamento. Você pode consultar a configuração de posicionamento do grupo de zonas usando o seguinte comando:
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zonegroup get
{
    "id": "ab01123f-e0df-4f29-9d71-b44888d67cd5",
    "name": "default",
    "api_name": "default",
    ...
    "placement_targets": [
        {
            "name": "default-placement",
            "tags": [],
            "storage_classes": [
                "STANDARD"
            ]
        }
    ],
    "default_placement": "default-placement",
    ...
}
</screen>
   <para>
    Para consultar a configuração de posicionamento da zona, execute:
   </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zone get
{
    "id": "557cdcee-3aae-4e9e-85c7-2f86f5eddb1f",
    "name": "default",
    "domain_root": "default.rgw.meta:root",
    ...
    "placement_pools": [
        {
            "key": "default-placement",
            "val": {
                "index_pool": "default.rgw.buckets.index",
                "storage_classes": {
                    "STANDARD": {
                        "data_pool": "default.rgw.buckets.data"
                    }
                },
                "data_extra_pool": "default.rgw.buckets.non-ec",
                "index_type": 0
            }
        }
    ],
    ...
}
</screen>
   <note>
    <title>Sem configuração multissite anterior</title>
    <para>
     Se você não fez nenhuma configuração de multissite anterior, uma zona e um grupo de zonas “padrão” são criados para você, e as mudanças feitas neles não entrarão em vigor até você reiniciar os Gateways de Objetos do Ceph. Se você criou um domínio Kerberos para multissite, as mudanças feitas na zona/grupo de zonas entrarão em vigor depois que você confirmá-las com o comando <command>radosgw-admin period update --commit</command>.
    </para>
   </note>
   <sect3 xml:id="adding-placement-target">
    <title>Adicionando um destino de posicionamento</title>
    <para>
     Para criar um novo destino de posicionamento chamado "temporary", comece adicionando-o ao grupo de zonas:
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zonegroup placement add \
      --rgw-zonegroup default \
      --placement-id temporary
</screen>
    <para>
     Em seguida, insira as informações de posicionamento da zona para esse destino:
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zone placement add \
      --rgw-zone default \
      --placement-id temporary \
      --data-pool default.rgw.temporary.data \
      --index-pool default.rgw.temporary.index \
      --data-extra-pool default.rgw.temporary.non-ec
</screen>
   </sect3>
   <sect3 xml:id="adding-storage-class">
    <title>Adicionando uma classe de armazenamento</title>
    <para>
     Para adicionar uma nova classe de armazenamento chamada “COLD” ao destino de posicionamento padrão, comece adicionando-a ao grupo de zonas:
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zonegroup placement add \
      --rgw-zonegroup default \
      --placement-id default-placement \
      --storage-class COLD
</screen>
    <para>
     Em seguida, insira as informações de posicionamento da zona para essa classe de armazenamento:
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zone placement add \
      --rgw-zone default \
      --placement-id default-placement \
      --storage-class COLD \
      --data-pool default.rgw.cold.data \
      --compression lz4
</screen>
   </sect3>
  </sect2>

  <sect2 xml:id="ogw-storage-classes-customizing-placement">
   <title>Personalização de posicionamento</title>
   <sect3 xml:id="edit-default-zgroup-placement">
    <title>Editando o posicionamento do grupo de zonas padrão</title>
    <para>
     Por padrão, os novos compartimentos de memória usarão o destino <literal>default_placement</literal> do grupo de zonas. Você pode mudar essa configuração do grupo de zonas com:
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin zonegroup placement default \
      --rgw-zonegroup default \
      --placement-id new-placement
</screen>
   </sect3>
   <sect3 xml:id="edit-default-user-placement">
    <title>Editando o posicionamento do usuário padrão</title>
    <para>
     Um usuário do Gateway de Objetos do Ceph pode anular o destino de posicionamento padrão do grupo de zonas definindo um campo <literal>default_placement</literal> não vazio nas informações do usuário. Da mesma forma, a <literal>default_storage_class</literal> pode anular a classe de armazenamento <option>STANDARD</option> aplicada aos objetos por padrão.
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin user info --uid testid
{
    ...
    "default_placement": "",
    "default_storage_class": "",
    "placement_tags": [],
    ...
}
</screen>
    <para>
     Se o destino de posicionamento do grupo de zonas incluir tags, os usuários não poderão criar compartimentos de memória com esse destino de posicionamento, a menos que as informações de usuário deles contenham pelo menos uma tag correspondente no respectivo campo "placement_tags". Isso pode ser útil para restringir o acesso a determinados tipos de armazenamento.
    </para>
    <para>
     O comando <command>radosgw-admin</command> não pode modificar esses campos diretamente, portanto, você precisa editar o formato JSON manualmente:
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>radosgw-admin metadata get user:<replaceable>USER-ID</replaceable> &gt; user.json
<prompt>tux &gt; </prompt>vi user.json     # edit the file as required
<prompt>cephuser@adm &gt; </prompt>radosgw-admin metadata put user:<replaceable>USER-ID</replaceable> &lt; user.json
</screen>
   </sect3>
   <sect3 xml:id="s3-bucket-default-placement">
    <title>Editando o posicionamento do compartimento de memória padrão do S3</title>
    <para>
     Ao criar um compartimento de memória com o protocolo S3, é possível inserir um destino de posicionamento como parte de <option>LocationConstraint</option> para anular os destinos de posicionamento padrão do usuário e do grupo de zonas.
    </para>
    <para>
     Normalmente, o <option>LocationConstraint</option> precisa corresponder ao <option>api_name</option> do grupo de zonas:
    </para>
<screen>&lt;LocationConstraint&gt;default&lt;/LocationConstraint&gt;</screen>
    <para>
     É possível adicionar um destino de posicionamento personalizado ao <option>api_name</option> após dois-pontos:
    </para>
<screen>&lt;LocationConstraint&gt;default:new-placement&lt;/LocationConstraint&gt;</screen>
   </sect3>
   <sect3 xml:id="swift-default-bucket-placement">
    <title>Editando o posicionamento do compartimento de memória do Swift</title>
    <para>
     Ao criar um compartimento de memória com o protocolo Swift, você pode fornecer um destino de posicionamento em <literal>X-Storage-Policy</literal> do cabeçalho HTTP:
    </para>
<screen>X-Storage-Policy: <replaceable>NEW-PLACEMENT</replaceable></screen>
   </sect3>
  </sect2>

  <sect2 xml:id="ogw-storage-classes-usage">
   <title>Usando classes de armazenamento</title>
   <para>
    Todos os destinos de posicionamento têm uma classe de armazenamento <option>STANDARD</option>, que é aplicada a novos objetos por padrão. Você pode anular esse padrão com <literal>default_storage_class</literal>.
   </para>
   <para>
    Para criar um objeto em uma classe de armazenamento não padrão, insira o nome dessa classe de armazenamento em um cabeçalho HTTP com a solicitação. O protocolo S3 usa o cabeçalho <literal>X-Amz-Storage-Class</literal>, enquanto o protocolo Swift usa o cabeçalho <literal>X-Object-Storage-Class</literal>.
   </para>
   <para>
    É possível usar o <emphasis>Gerenciamento do Ciclo de Vida de Objeto do S3</emphasis> para mover dados de objetos entre classes de armazenamento por meio das ações de <option>Transição</option>.
   </para>
  </sect2>
 </sect1>
 <sect1 xml:id="ceph-rgw-fed">
  <title>Gateways de Objetos multissite</title>

  <para>
   O Ceph suporta várias opções de configuração multissite para o Gateway de Objetos do Ceph:
  </para>

  <variablelist>
   <varlistentry>
    <term>Várias zonas</term>
    <listitem>
     <para>
      Uma configuração que consiste em um grupo de zonas e várias zonas, cada uma com uma ou mais instâncias de <systemitem class="daemon">ceph-radosgw</systemitem>. Cada zona é acompanhada de seu próprio Cluster de Armazenamento do Ceph. Várias zonas em um grupo de zonas fornecem recuperação de desastre para o grupo de zonas, caso uma das zonas apresente uma falha significativa. Cada zona é ativa e pode receber operações de gravação. Além da recuperação de desastre, várias zonas ativas também podem servir como base para redes de distribuição de conteúdo.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Vários grupos de zonas</term>
    <listitem>
     <para>
      O Gateway de Objetos do Ceph suporta vários grupos de zonas, cada um com uma ou mais zonas. Os objetos armazenados em zonas de um grupo de zonas no mesmo domínio que outro grupo de zonas compartilham um namespace de objeto global, garantindo IDs de objeto exclusivos em todos os grupos de zonas e as zonas.
     </para>
     <note>
      <para>
       É importante observar que os grupos de zonas sincronizam <emphasis>apenas</emphasis> metadados entre eles. Os dados e os metadados são replicados entre as zonas do grupo de zonas. Não são compartilhados dados ou metadados em um domínio.
      </para>
     </note>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term>Vários domínios</term>
    <listitem>
     <para>
      O Gateway de Objetos do Ceph suporta a noção de domínios: um namespace globalmente exclusivo. Vários domínios são suportados, o que pode abranger um ou diversos grupos de zonas.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   Você pode configurar cada Gateway de Objetos para operar em uma configuração de zona ativa-ativa, permitindo gravações em zonas não master. A configuração multissite é armazenada em um container chamado domínio. O domínio armazena grupos de zonas, zonas e um período com várias épocas para monitorar as mudanças na configuração. Os daemons <systemitem class="daemon">rgw</systemitem> processam a sincronização, eliminando a necessidade de um agente de sincronização separado. Essa abordagem de sincronização permite que o Gateway de Objetos do Ceph opere com uma configuração ativa-ativa, e não ativa-passiva.
  </para>

  <sect2 xml:id="ceph-rgw-multi-req-assump">
   <title>Requisitos e considerações</title>
   <para>
    Uma configuração multissite requer pelo menos dois clusters de armazenamento do Ceph e, no mínimo, duas instâncias do Gateway de Objetos do Ceph, uma para cada cluster de armazenamento do Ceph. A configuração a seguir considera que pelo menos dois clusters de armazenamento do Ceph estão em locais geograficamente separados. No entanto, a configuração pode funcionar no mesmo site. Por exemplo, <literal>rgw1</literal> e <literal>rgw2</literal> nomeados.
   </para>
   <para>
    Uma configuração multissite requer um grupo de zonas master e uma zona master. Uma zona master é a fonte da verdade em relação a todas as operações de metadados em um cluster multissite. Além disso, cada grupo de zonas requer uma zona master. Os grupos de zonas podem ter uma ou mais zonas secundárias ou não master. Neste guia, o host <literal>rgw1</literal> atua como a zona master do grupo de zonas master, e o host <literal>rgw2</literal> atua como a zona secundária do grupo de zonas master.
   </para>
  </sect2>

  <sect2 xml:id="ceph-rgw-config-master-zone">
   <title>Configurando uma zona master</title>
   <para>
    Todos os gateways em uma configuração multissite recuperam sua configuração de um daemon <systemitem class="daemon">ceph-radosgw</systemitem> em um host no grupo de zonas master e na zona master. Para configurar seus gateways em uma configuração multissite, selecione uma instância de <systemitem class="daemon">ceph-radosgw</systemitem> para configurar o grupo de zonas master e a zona master.
   </para>
   <sect3 xml:id="ceph-rgw-fed-realm">
    <title>Criando um domínio</title>
    <para>
     Um domínio representa um namespace globalmente exclusivo que consiste em um ou mais grupos de zonas com uma ou mais zonas. As zonas contêm compartimentos de memória que, por sua vez, contêm objetos. Um domínio permite que o Gateway de Objetos do Ceph suporte vários namespaces e a respectiva configuração no mesmo hardware. Um domínio engloba a noção de períodos. Cada período representa o estado da configuração do grupo de zonas e da zona no tempo. Sempre que você modificar um grupo de zonas ou uma zona, atualize e confirme o período. Por padrão, o Gateway de Objetos do Ceph não cria um domínio para compatibilidade retroativa. Como melhor prática, recomendamos criar domínios para os novos clusters.
    </para>
    <para>
     Crie um novo domínio chamado <literal>gold</literal> para a configuração multissite abrindo uma interface de linha de comando em um host identificado para atuar no grupo de zonas master e na zona. Em seguida, execute o seguinte:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin realm create --rgw-realm=gold --default</screen>
    <para>
     Se o cluster tiver um único domínio, especifique o flag <option>--default</option>. Se <option>--default</option> for especificado, <command>radosgw-admin</command> usará esse domínio por padrão. Se <option>--default</option> não for especificado, a adição de grupos de zonas e zonas exigirá que o flag <option>--rgw-realm</option> ou <option>--realm-id</option> seja especificado para identificar o domínio ao adicionar grupos de zonas e zonas.
    </para>
    <para>
     Após criar o domínio, <command>radosgw-admin</command> retornará a configuração do domínio:
    </para>
<screen>
{
  "id": "4a367026-bd8f-40ee-b486-8212482ddcd7",
  "name": "gold",
  "current_period": "09559832-67a4-4101-8b3f-10dfcd6b2707",
  "epoch": 1
}</screen>
    <note>
     <para>
      O Ceph gera um ID exclusivo para o domínio, o que permite renomear um domínio se houver necessidade.
     </para>
    </note>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-createmasterzonegrp">
    <title>Criando um grupo de zonas master</title>
    <para>
     Um domínio deve ter pelo menos um grupo de zonas para atuar como o grupo de zonas master do domínio. Crie um novo grupo de zonas master para a configuração multissite abrindo uma interface de linha de comando em um host identificado para atuar no grupo de zonas master e na zona. Execute o seguinte comando para criar um grupo de zonas master chamado <literal>us</literal>:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin zonegroup create --rgw-zonegroup=us \
--endpoints=http://rgw1:80 --master --default</screen>
    <para>
     Se o domínio tiver apenas um grupo de zonas, especifique o flag <option>--default</option>. Se <option>--default</option> for especificado, <command>radosgw-admin</command> usará esse grupo de zonas por padrão ao adicionar novas zonas. Se <option>--default</option> não for especificado, a adição de zonas exigirá o flag <option>--rgw-zonegroup</option> ou <option>‑‑zonegroup-id</option> para identificar o grupo de zonas ao adicionar ou modificar zonas.
    </para>
    <para>
     Após criar o grupo de zonas master, <command>radosgw-admin</command> retornará a configuração do grupo de zonas. Por exemplo:
    </para>
<screen>{
 "id": "d4018b8d-8c0d-4072-8919-608726fa369e",
 "name": "us",
 "api_name": "us",
 "is_master": "true",
 "endpoints": [
     "http:\/\/rgw1:80"
 ],
 "hostnames": [],
 "hostnames_s3website": [],
 "master_zone": "",
 "zones": [],
 "placement_targets": [],
 "default_placement": "",
 "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
}</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-masterzone">
    <title>Criando uma zona master</title>
    <important>
     <para>
      As zonas precisam ser criadas em um nó do Gateway de Objetos do Ceph que estará na zona.
     </para>
    </important>
    <para>
     Crie uma nova zona master para a configuração multissite abrindo uma interface de linha de comando em um host identificado para atuar no grupo de zonas master e na zona. Execute o seguinte:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin zone create --rgw-zonegroup=us --rgw-zone=us-east-1 \
--endpoints=http://rgw1:80 --access-key=<replaceable>SYSTEM_ACCESS_KEY</replaceable> --secret=<replaceable>SYSTEM_SECRET_KEY</replaceable></screen>
    <note>
     <para>
      As opções <option>--access-key</option> e <option>--secret</option> não estão especificadas no exemplo acima. Essas configurações são adicionadas à zona quando o usuário é criado na próxima seção.
     </para>
    </note>
    <para>
     Após criar a zona master, <command>radosgw-admin</command> retornará a configuração da zona. Por exemplo:
    </para>
<screen>
  {
      "id": "56dfabbb-2f4e-4223-925e-de3c72de3866",
      "name": "us-east-1",
      "domain_root": "us-east-1.rgw.meta:root",
      "control_pool": "us-east-1.rgw.control",
      "gc_pool": "us-east-1.rgw.log:gc",
      "lc_pool": "us-east-1.rgw.log:lc",
      "log_pool": "us-east-1.rgw.log",
      "intent_log_pool": "us-east-1.rgw.log:intent",
      "usage_log_pool": "us-east-1.rgw.log:usage",
      "reshard_pool": "us-east-1.rgw.log:reshard",
      "user_keys_pool": "us-east-1.rgw.meta:users.keys",
      "user_email_pool": "us-east-1.rgw.meta:users.email",
      "user_swift_pool": "us-east-1.rgw.meta:users.swift",
      "user_uid_pool": "us-east-1.rgw.meta:users.uid",
      "otp_pool": "us-east-1.rgw.otp",
      "system_key": {
          "access_key": "1555b35654ad1656d804",
          "secret_key": "h7GhxuBLTrlhVUyxSPUKUV8r/2EI4ngqJxD7iBdBYLhwluN30JaT3Q=="
      },
      "placement_pools": [
          {
              "key": "us-east-1-placement",
              "val": {
                  "index_pool": "us-east-1.rgw.buckets.index",
                  "storage_classes": {
                      "STANDARD": {
                          "data_pool": "us-east-1.rgw.buckets.data"
                      }
                  },
                  "data_extra_pool": "us-east-1.rgw.buckets.non-ec",
                  "index_type": 0
              }
          }
      ],
      "metadata_heap": "",
      "realm_id": ""
  }</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-deldefzonegrp">
    <title>Apagando a zona e o grupo padrão</title>
    <important>
     <para>
      As etapas a seguir consideram uma configuração multissite que usa sistemas recém-instalados que ainda não estão armazenando dados. <emphasis role="bold">Não apague</emphasis> a zona padrão e seus pools se você já a estiver usando para armazenar dados; do contrário, os dados serão apagados de modo irrecuperável.
     </para>
    </important>
    <para>
     A instalação padrão do Gateway de Objetos cria o grupo de zonas padrão chamado <literal>default</literal>. Apague a zona padrão, se ela existir. Remova-a primeiro do grupo de zonas padrão.
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin zonegroup delete --rgw-zonegroup=default</screen>
    <para>
     Apague os pools padrão do cluster de armazenamento do Ceph, se existirem:
    </para>
    <important>
     <para>
      A etapa a seguir considera uma configuração multissite que usa sistemas recém-instalados que não estão armazenando dados no momento. <emphasis role="bold">Não apague</emphasis> o grupo de zonas padrão se você já o estiver usando para armazenar dados.
     </para>
    </important>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool rm default.rgw.control default.rgw.control --yes-i-really-really-mean-it
<prompt>cephuser@adm &gt; </prompt>ceph osd pool rm default.rgw.data.root default.rgw.data.root --yes-i-really-really-mean-it
<prompt>cephuser@adm &gt; </prompt>ceph osd pool rm default.rgw.gc default.rgw.gc --yes-i-really-really-mean-it
<prompt>cephuser@adm &gt; </prompt>ceph osd pool rm default.rgw.log default.rgw.log --yes-i-really-really-mean-it
<prompt>cephuser@adm &gt; </prompt>ceph osd pool rm default.rgw.meta default.rgw.meta --yes-i-really-really-mean-it</screen>
    <warning>
     <para>
      Se você apagar o grupo de zonas padrão, também apagará o usuário do sistema. Se as chaves de usuário admin não forem propagadas, haverá falha na funcionalidade de gerenciamento do Gateway de Objetos do Ceph Dashboard. Avance para a próxima seção para recriar o usuário do sistema, se você prosseguir com esta etapa.
     </para>
    </warning>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-masterzone-createuser">
    <title>Criando usuários do sistema</title>
    <para>
     Os daemons <systemitem class="daemon">ceph-radosgw</systemitem> devem ser autenticados antes de extrair informações de domínio e período. Na zona master, crie um usuário do sistema para simplificar a autenticação entre daemons:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin user create --uid=zone.user \
--display-name="Zone User" --access-key=<replaceable>SYSTEM_ACCESS_KEY</replaceable> \
--secret=<replaceable>SYSTEM_SECRET_KEY</replaceable> --system</screen>
    <para>
     Anote a <option>access_key</option> e a <option>secret_key</option>, pois as zonas secundárias precisam delas para autenticação na zona master.
    </para>
    <para>
     Adicione o usuário do sistema à zona master:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin zone modify --rgw-zone=us-east-1 \
--access-key=<replaceable>ACCESS-KEY</replaceable> --secret=<replaceable>SECRET</replaceable></screen>
    <para>
     Atualize o período para que as mudanças entrem em vigor:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin period update --commit</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-masterzone-updateperiod">
    <title>Atualize o período</title>
    <para>
     Após atualizar a configuração da zona master, atualize o período:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin period update --commit</screen>
    <para>
     Após atualizar o período, <command>radosgw-admin</command> retornará a configuração do período. Por exemplo:
    </para>
<screen>{
  "id": "09559832-67a4-4101-8b3f-10dfcd6b2707", "epoch": 1, "predecessor_uuid": "", "sync_status": [], "period_map":
  {
    "id": "09559832-67a4-4101-8b3f-10dfcd6b2707", "zonegroups": [], "short_zone_ids": []
  }, "master_zonegroup": "", "master_zone": "", "period_config":
  {
     "bucket_quota": {
     "enabled": false, "max_size_kb": -1, "max_objects": -1
     }, "user_quota": {
       "enabled": false, "max_size_kb": -1, "max_objects": -1
     }
  }, "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7", "realm_name": "gold", "realm_epoch": 1
}</screen>
    <note>
     <para>
      A atualização do período muda a época e garante que as outras zonas recebam a configuração atualizada.
     </para>
    </note>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-masterzone-startrgw">
    <title>Iniciar o gateway</title>
    <para>
     No host do Gateway de Objetos, inicie e habilite o serviço Gateway de Objetos do Ceph. Para identificar o FSID exclusivo do cluster, execute <command>ceph fsid</command>. Para identificar o nome do daemon do Gateway de Objetos, execute <command>ceph orch ps --hostname <replaceable>HOSTNAME</replaceable></command>.
    </para>
<screen><prompt>cephuser@ogw &gt; </prompt>systemctl start ceph-<replaceable>FSID</replaceable>@<replaceable>DAEMON_NAME</replaceable>
<prompt>cephuser@ogw &gt; </prompt>systemctl enable ceph-<replaceable>FSID</replaceable>@<replaceable>DAEMON_NAME</replaceable></screen>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-config-secondaryzone">
   <title>Configurar zonas secundárias</title>
   <para>
    As zonas dentro de um grupo de zonas replicam todos os dados para garantir que cada zona tenha os mesmos dados. Ao criar a zona secundária, execute todas as operações a seguir em um host identificado para processar a zona secundária.
   </para>
   <note>
    <para>
     Para adicionar uma terceira zona, siga os mesmos procedimentos da adição da zona secundária. Use um nome de zona diferente.
    </para>
   </note>
   <important>
    <para>
     Você deve executar operações de metadados, como criação de usuário, em um host na zona master. A zona master e a zona secundária podem receber operações de compartimento de memória, mas a zona secundária redireciona essas operações para a zona master. Se a zona master estiver inativa, haverá falha nas operações de compartimento de memória.
    </para>
   </important>
   <sect3 xml:id="ceph-rgw-pull-realm">
    <title>Extraindo do domínio</title>
    <para>
     Usando o caminho de URL, a chave de acesso e o segredo da zona master no grupo de zonas master, extraia a configuração do domínio para o host. Para extrair de um domínio não padrão, especifique o domínio usando as opções de configuração <option>--rgw-realm</option> ou <option>--realm-id</option>.
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin realm pull --url=<replaceable>url-to-master-zone-gateway</replaceable> --access-key=<replaceable>access-key</replaceable> --secret=<replaceable>secret</replaceable></screen>
    <note>
     <para>
      A extração do domínio também recupera a configuração do período atual remoto e também o torna o período atual neste host.
     </para>
    </note>
    <para>
     Se esse for o único domínio ou o padrão, defina o domínio como padrão.
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin realm default --rgw-realm=<replaceable>REALM-NAME</replaceable></screen>
   </sect3>
   <sect3 xml:id="cceph-rgw-create-secondaryzone">
    <title>Criando uma zona secundária</title>
    <para>
     Crie uma zona secundária para a configuração multissite abrindo uma interface de linha de comando em um host identificado para atender à zona secundária. Especifique o ID do grupo de zonas, o novo nome da zona e um endpoint para a zona. <emphasis>Não</emphasis> use o flag <option>--master</option>. Por padrão, todas as zonas são executadas em uma configuração ativa-ativa. Se a zona secundária não aceitar operações de gravação, especifique o flag <option>--read-only</option> para criar uma configuração ativa-passiva entre a zona master e a zona secundária. Além disso, insira a <option>access_key</option> e a <option>secret_key</option> do usuário do sistema gerado armazenado na zona master do grupo de zonas master. Execute o seguinte:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin zone create --rgw-zonegroup=<replaceable>ZONE-GROUP-NAME</replaceable>\
                            --rgw-zone=<replaceable>ZONE-NAME</replaceable> --endpoints=<replaceable>URL</replaceable> \
                            --access-key=<replaceable>SYSTEM-KEY</replaceable> --secret=<replaceable>SECRET</replaceable>\
                            --endpoints=http://<replaceable>FQDN</replaceable>:80 \
                            [--read-only]</screen>
    <para>
     Por exemplo:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin zone create --rgw-zonegroup=us --endpoints=http://rgw2:80 \
--rgw-zone=us-east-2 --access-key=<replaceable>SYSTEM_ACCESS_KEY</replaceable> --secret=<replaceable>SYSTEM_SECRET_KEY</replaceable>
{
  "id": "950c1a43-6836-41a2-a161-64777e07e8b8",
  "name": "us-east-2",
  "domain_root": "us-east-2.rgw.data.root",
  "control_pool": "us-east-2.rgw.control",
  "gc_pool": "us-east-2.rgw.gc",
  "log_pool": "us-east-2.rgw.log",
  "intent_log_pool": "us-east-2.rgw.intent-log",
  "usage_log_pool": "us-east-2.rgw.usage",
  "user_keys_pool": "us-east-2.rgw.users.keys",
  "user_email_pool": "us-east-2.rgw.users.email",
  "user_swift_pool": "us-east-2.rgw.users.swift",
  "user_uid_pool": "us-east-2.rgw.users.uid",
  "system_key": {
      "access_key": "1555b35654ad1656d804",
      "secret_key": "h7GhxuBLTrlhVUyxSPUKUV8r\/2EI4ngqJxD7iBdBYLhwluN30JaT3Q=="
  },
  "placement_pools": [
      {
          "key": "default-placement",
          "val": {
              "index_pool": "us-east-2.rgw.buckets.index",
              "data_pool": "us-east-2.rgw.buckets.data",
              "data_extra_pool": "us-east-2.rgw.buckets.non-ec",
              "index_type": 0
          }
      }
  ],
  "metadata_heap": "us-east-2.rgw.meta",
  "realm_id": "815d74c2-80d6-4e63-8cfc-232037f7ff5c"
}</screen>
    <important>
     <para>
      As etapas a seguir consideram uma configuração multissite que usa sistemas recém-instalados que ainda não estão armazenando dados. <emphasis role="bold">Não apague</emphasis> a zona padrão e seus pools se você já a estiver usando para armazenar dados; do contrário, os dados serão perdidos de modo irrecuperável.
     </para>
    </important>
    <para>
     Apague a zona padrão, se necessário:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin zone rm --rgw-zone=default</screen>
    <para>
     Apague os pools padrão do cluster de armazenamento do Ceph, se necessário:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph osd pool rm default.rgw.control default.rgw.control --yes-i-really-really-mean-it
<prompt>cephuser@adm &gt; </prompt>ceph osd pool rm default.rgw.data.root default.rgw.data.root --yes-i-really-really-mean-it
<prompt>cephuser@adm &gt; </prompt>ceph osd pool rm default.rgw.gc default.rgw.gc --yes-i-really-really-mean-it
<prompt>cephuser@adm &gt; </prompt>ceph osd pool rm default.rgw.log default.rgw.log --yes-i-really-really-mean-it
<prompt>cephuser@adm &gt; </prompt>ceph osd pool rm default.rgw.users.uid default.rgw.users.uid --yes-i-really-really-mean-it</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-secondzone-update-config">
    <title>Atualizando o arquivo de configuração do Ceph</title>
    <para>
     Atualize o arquivo de configuração do Ceph nos hosts da zona secundária adicionando a opção de configuração <literal>rgw_zone</literal> e o nome da zona secundária à entrada da instância.
    </para>
    <para>
     Para isso, execute o seguinte comando:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph config set <replaceable>SERVICE_NAME</replaceable> rgw_zone us-west</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-secondzone-updateperiod">
    <title>Atualizando o período</title>
    <para>
     Após atualizar a configuração da zona master, atualize o período:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin period update --commit
{
  "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
  "epoch": 2,
  "predecessor_uuid": "09559832-67a4-4101-8b3f-10dfcd6b2707",
  "sync_status": [ "[...]"
  ],
  "period_map": {
      "id": "b5e4d3ec-2a62-4746-b479-4b2bc14b27d1",
      "zonegroups": [
          {
              "id": "d4018b8d-8c0d-4072-8919-608726fa369e",
              "name": "us",
              "api_name": "us",
              "is_master": "true",
              "endpoints": [
                  "http:\/\/rgw1:80"
              ],
              "hostnames": [],
              "hostnames_s3website": [],
              "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "zones": [
                  {
                      "id": "83859a9a-9901-4f00-aa6d-285c777e10f0",
                      "name": "us-east-1",
                      "endpoints": [
                          "http:\/\/rgw1:80"
                      ],
                      "log_meta": "true",
                      "log_data": "false",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  },
                  {
                      "id": "950c1a43-6836-41a2-a161-64777e07e8b8",
                      "name": "us-east-2",
                      "endpoints": [
                          "http:\/\/rgw2:80"
                      ],
                      "log_meta": "false",
                      "log_data": "true",
                      "bucket_index_max_shards": 0,
                      "read_only": "false"
                  }

              ],
              "placement_targets": [
                  {
                      "name": "default-placement",
                      "tags": []
                  }
              ],
              "default_placement": "default-placement",
              "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7"
          }
      ],
      "short_zone_ids": [
          {
              "key": "83859a9a-9901-4f00-aa6d-285c777e10f0",
              "val": 630926044
          },
          {
              "key": "950c1a43-6836-41a2-a161-64777e07e8b8",
              "val": 4276257543
          }

      ]
  },
  "master_zonegroup": "d4018b8d-8c0d-4072-8919-608726fa369e",
  "master_zone": "83859a9a-9901-4f00-aa6d-285c777e10f0",
  "period_config": {
      "bucket_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      },
      "user_quota": {
          "enabled": false,
          "max_size_kb": -1,
          "max_objects": -1
      }
  },
  "realm_id": "4a367026-bd8f-40ee-b486-8212482ddcd7",
  "realm_name": "gold",
  "realm_epoch": 2
}</screen>
    <note>
     <para>
      A atualização do período muda a época e garante que as outras zonas recebam a configuração atualizada.
     </para>
    </note>
   </sect3>
   <sect3 xml:id="ceph-rgw-fed-secondzone-startrgw">
    <title>Iniciando o Gateway de Objetos</title>
    <para>
     No host do Gateway de Objetos, inicie e habilite o serviço Gateway de Objetos do Ceph:
    </para>
<screen>
<prompt>cephuser@adm &gt; </prompt>ceph orch start rgw.us-east-2
</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-check-sync-status">
    <title>Verificando o status da sincronização</title>
    <para>
     Quando a zona secundária estiver ativa e em execução, verifique o status da sincronização. A sincronização copia os usuários e compartimentos de memória criados na zona master para a zona secundária.
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin sync status</screen>
    <para>
     A saída mostra o status das operações de sincronização. Por exemplo:
    </para>
<screen>realm f3239bc5-e1a8-4206-a81d-e1576480804d (gold)
    zonegroup c50dbb7e-d9ce-47cc-a8bb-97d9b399d388 (us)
         zone 4c453b70-4a16-4ce8-8185-1893b05d346e (us-west)
metadata sync syncing
              full sync: 0/64 shards
              metadata is caught up with master
              incremental sync: 64/64 shards
    data sync source: 1ee9da3e-114d-4ae3-a8a4-056e8a17f532 (us-east)
                      syncing
                      full sync: 0/128 shards
                      incremental sync: 128/128 shards
                      data is caught up with source</screen>
    <note>
     <para>
      As zonas secundárias aceitam operações de compartimento de memória, mas elas redirecionam essas operações para a zona master e, em seguida, são sincronizadas com a zona master para receber o resultado das operações. Se a zona master estiver inativa, haverá falha nas operações de compartimento de memória executadas na zona secundária, mas as operações de objeto deverão ser bem-sucedidas.
     </para>
    </note>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-maintenance">
   <title>Manutenção geral do Gateway de Objetos</title>
   <sect3 xml:id="ceph-rgw-check-sync">
    <title>Verificando o status da sincronização</title>
    <para>
     As informações sobre o status da replicação de uma zona podem ser consultadas com:
    </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin sync status
        realm b3bc1c37-9c44-4b89-a03b-04c269bea5da (gold)
    zonegroup f54f9b22-b4b6-4a0e-9211-fa6ac1693f49 (us)
         zone adce11c9-b8ed-4a90-8bc5-3fc029ff0816 (us-west)
        metadata sync syncing
              full sync: 0/64 shards
              incremental sync: 64/64 shards
              metadata is behind on 1 shards
              oldest incremental change not applied: 2017-03-22 10:20:00.0.881361s
data sync source: 341c2d81-4574-4d08-ab0f-5a2a7b168028 (us-east)
                  syncing
                  full sync: 0/128 shards
                  incremental sync: 128/128 shards
                  data is caught up with source
          source: 3b5d1a3f-3f27-4e4a-8f34-6072d4bb1275 (us-3)
                  syncing
                  full sync: 0/128 shards
                  incremental sync: 128/128 shards
                  data is caught up with source</screen>
   </sect3>
   <sect3 xml:id="ceph-rgw-metadata-master">
    <title>Mudando a zona master de metadados</title>
    <important>
     <para>
      Tenha cuidado ao mudar a zona que é master de metadados. Se uma zona não concluiu a sincronização de metadados da zona master atual, ela não pode processar as entradas restantes ao ser promovida a master, e essas mudanças são perdidas. Por esse motivo, recomendamos aguardar até o status da sincronização de <command>radosgw-admin</command> de uma zona concluir a sincronização de metadados antes de promovê-la a master. Da mesma forma, se as mudanças nos metadados estiverem sendo processadas pela zona master atual enquanto outra zona for promovida a master, essas mudanças provavelmente serão perdidas. Para evitar isso, recomendamos encerrar quaisquer instâncias do Gateway de Objetos na zona master anterior. Após promover outra zona, será possível buscar seu novo período com a extração de período de <command>radosgw-admin</command> e reiniciar o(s) gateway(s).
     </para>
    </important>
    <para>
     Para promover uma zona (por exemplo, a zona <literal>us-west</literal> no grupo de zonas <literal>us</literal>) a master de metadados, execute os seguintes comandos nessa zona:
    </para>
<screen><prompt>cephuser@ogw &gt; </prompt>radosgw-admin zone modify --rgw-zone=us-west --master
<prompt>cephuser@ogw &gt; </prompt>radosgw-admin zonegroup modify --rgw-zonegroup=us --master
<prompt>cephuser@ogw &gt; </prompt>radosgw-admin period update --commit</screen>
    <para>
     Isso gera um novo período, e a(s) instância(s) do Gateway de Objetos na zona <literal>us-west</literal> envia(m) esse período para as outras zonas.
    </para>
   </sect3>
  </sect2>

  <sect2 xml:id="ceph-rgw-failover-dr">
   <title>Executando failover e recuperação de desastre</title>
   <para>
    Se a zona master falhar, faça o failover para a zona secundária para recuperação de desastre.
   </para>
   <procedure>
    <step>
     <para>
      Converta a zona secundária na zona master e padrão. Por exemplo:
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin zone modify --rgw-zone=<replaceable>ZONE-NAME</replaceable> --master --default</screen>
     <para>
      Por padrão, o Gateway de Objetos do Ceph é executado em uma configuração ativa-ativa. Se o cluster foi configurado para ser executado em uma configuração ativa-passiva, a zona secundária é uma zona apenas leitura. Remova o status <option>--read-only</option> para permitir que a zona receba as operações de gravação. Por exemplo:
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin zone modify --rgw-zone=<replaceable>ZONE-NAME</replaceable> --master --default \
                                                   --read-only=false
</screen>
    </step>
    <step>
     <para>
      Atualize o período para que as mudanças entrem em vigor:
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin period update --commit</screen>
    </step>
    <step>
     <para>
      Reinicie o Gateway de Objetos do Ceph:
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph orch restart rgw</screen>
    </step>
   </procedure>
   <para>
    Se a zona master anterior for recuperada, reverta a operação.
   </para>
   <procedure>
    <step>
     <para>
      Da zona recuperada, extraia a configuração mais recente do domínio da zona master atual.
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin realm pull --url=<replaceable>URL-TO-MASTER-ZONE-GATEWAY</replaceable> \
                           --access-key=<replaceable>ACCESS-KEY</replaceable> --secret=<replaceable>SECRET</replaceable>
</screen>
    </step>
    <step>
     <para>
      Converta a zona recuperada na zona master e padrão:
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin zone modify --rgw-zone=<replaceable>ZONE-NAME</replaceable> --master --default</screen>
    </step>
    <step>
     <para>
      Atualize o período para que as mudanças entrem em vigor:
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin period update --commit</screen>
    </step>
    <step>
     <para>
      Reinicie o Gateway de Objetos do Ceph na zona recuperada:
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph orch restart rgw@rgw</screen>
    </step>
    <step>
     <para>
      Se a zona secundária precisar de uma configuração apenas leitura, atualize-a:
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin zone modify --rgw-zone=<replaceable>ZONE-NAME</replaceable> --read-only</screen>
    </step>
    <step>
     <para>
      Atualize o período para que as mudanças entrem em vigor:
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>radosgw-admin period update --commit</screen>
    </step>
    <step>
     <para>
      Reinicie o Gateway de Objetos do Ceph na zona secundária:
     </para>
<screen><prompt>cephuser@adm &gt; </prompt>ceph orch restart@rgw</screen>
    </step>
   </procedure>
  </sect2>
 </sect1>
</chapter>
